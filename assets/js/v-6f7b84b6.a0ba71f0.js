"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3529],{7071:(e,t,a)=>{a.r(t),a.d(t,{default:()=>M});var i=a(1534);const l=a.p+"assets/img/Untitled.81305dbb.png",r=a.p+"assets/img/Untitled-1.a51817f7.png",n=a.p+"assets/img/Untitled-2.04283994.png",d=a.p+"assets/img/Untitled-3.19271f20.png",p=a.p+"assets/img/Untitled-4.dd471972.png",h=a.p+"assets/img/Untitled-5.774244fd.png",s=a.p+"assets/img/Untitled-6.37bb2451.png",c=a.p+"assets/img/Untitled-7.5373e1c6.png",g=a.p+"assets/img/Untitled-8.97898013.png",o=a.p+"assets/img/Untitled-9.54c50ee0.png",m=a.p+"assets/img/Untitled-10.084107d5.png",u=a.p+"assets/img/Untitled-11.024a2b41.png",k=a.p+"assets/img/Untitled-12.8642c2c5.png",b=a.p+"assets/img/Untitled-13.91350e6c.png",P=a.p+"assets/img/Untitled-14.f574a3ed.png",U=a.p+"assets/img/Untitled-15.33fd09ca.png",f=a.p+"assets/img/Untitled-16.ae8bece5.png",C=a.p+"assets/img/Untitled-17.3d81f4e9.png",v=a.p+"assets/img/Untitled-18.70ebe09a.png",x=a.p+"assets/img/Untitled-19.bf38a4f2.png",A=a.p+"assets/img/Untitled-20.0fe474c2.png",T=a.p+"assets/img/Untitled-21.d962c492.png",I=a.p+"assets/img/Untitled-22.a151c7c8.png",w=[(0,i.uE)('<h2 id="创建嵌套字" tabindex="-1"><a class="header-anchor" href="#创建嵌套字" aria-hidden="true">#</a> 创建嵌套字</h2><h3 id="协议栈的内部结构" tabindex="-1"><a class="header-anchor" href="#协议栈的内部结构" aria-hidden="true">#</a> 协议栈的内部结构</h3><p><strong>浏览器、邮件等一般应用程序收发数据时用TCP； DNS 查询等收发较短的控制数据时用UDP。</strong></p><p><img src="'+l+'" alt="Untitled"></p><h3 id="套接字的实体就是通信控制信息" tabindex="-1"><a class="header-anchor" href="#套接字的实体就是通信控制信息" aria-hidden="true">#</a> 套接字的实体就是通信控制信息</h3><p>在协议栈内部有一块用于存放控制信息的内存空间，这里记录了用于控制通信操作的控制信息，例如通信对象的IP 地址、端口号、通信操作的进行状态等</p><p><strong>协议栈是根据套接字中记录的控制信息来工作的。</strong></p><p><img src="'+r+'" alt="Untitled"></p><h3 id="调用socket时的操作" tabindex="-1"><a class="header-anchor" href="#调用socket时的操作" aria-hidden="true">#</a> 调用socket时的操作</h3><p>创建套接字时，首先分配一个套接字所需的内存空间，然后向其中写入初始状态。</p><p><img src="'+n+'" alt="Untitled"></p><h2 id="连接服务器" tabindex="-1"><a class="header-anchor" href="#连接服务器" aria-hidden="true">#</a> 连接服务器</h2><p>创建套接字之后，应用程序（浏览器）就会调用connect，随后协议栈会将本地的套接字与服务器的套接字进行连接。</p><h3 id="保存控制信息的头部" tabindex="-1"><a class="header-anchor" href="#保存控制信息的头部" aria-hidden="true">#</a> 保存控制信息的头部</h3><p>客户端和服务器在通信中会将必要的信息记录在头部并相互确认</p><p>控制信息大体上分为两类。</p><p>第一类是客户端和服务器相互联络时交换的控制信息。</p><p>另外一类，那就是保存在套接字中，用来控制协议栈操作的信息</p><p><img src="'+d+'" alt="Untitled"></p><p>通信操作中使用的控制信息分为两类。 （1） 头部中记录的信息 （2） 套接字（协议栈中的内存空间）中记录的信息</p><h3 id="连接操作的实际过程" tabindex="-1"><a class="header-anchor" href="#连接操作的实际过程" aria-hidden="true">#</a> 连接操作的实际过程</h3><p>连接操作的第一步是在TCP 模块处创建表示连接控制信息的头部。</p><p>通过TCP 头部中的发送方和接收方端口号可以找到要连接的套接字。</p><h2 id="收发数据" tabindex="-1"><a class="header-anchor" href="#收发数据" aria-hidden="true">#</a> 收发数据</h2><h3 id="将http-请求消息交给协议栈" tabindex="-1"><a class="header-anchor" href="#将http-请求消息交给协议栈" aria-hidden="true">#</a> 将HTTP 请求消息交给协议栈</h3><h3 id="对较大的数据进行拆分" tabindex="-1"><a class="header-anchor" href="#对较大的数据进行拆分" aria-hidden="true">#</a> 对较大的数据进行拆分</h3><p><img src="'+p+'" alt="Untitled"></p><h3 id="使用ack号确认网络包已收到" tabindex="-1"><a class="header-anchor" href="#使用ack号确认网络包已收到" aria-hidden="true">#</a> 使用ACK号确认网络包已收到</h3><p><img src="'+h+'" alt="Untitled"></p><p><img src="'+s+'" alt="Untitled"></p><p><img src="'+c+'" alt="Untitled"></p><h3 id="根据网络包平均往返时间调整ack-号等待时间" tabindex="-1"><a class="header-anchor" href="#根据网络包平均往返时间调整ack-号等待时间" aria-hidden="true">#</a> 根据网络包平均往返时间调整ACK 号等待时间</h3><p>这个等待时间叫超时时间</p><h3 id="使用窗口有效管理ack号" tabindex="-1"><a class="header-anchor" href="#使用窗口有效管理ack号" aria-hidden="true">#</a> 使用窗口有效管理ACK号</h3><p>能够接收的最大数据量称为窗口大小</p><p><img src="'+g+'" alt="Untitled"></p><p>当接收方的TCP 收到包后，会先将数据存放到接收缓冲区中。</p><p><img src="'+o+'" alt="Untitled"></p><h3 id="ack与窗口的合并" tabindex="-1"><a class="header-anchor" href="#ack与窗口的合并" aria-hidden="true">#</a> ACK与窗口的合并</h3><p>返回ACK号和更新窗口的时机？</p><p>其实没必要每次都向发送方更新窗口大小，因为只要发送方在每次发送数据时减掉已发送的数据长度就可以自行计算出当前窗口的剩余长度。</p><p><strong>接收方在发送ACK 号和窗口更新时，并不会马上把包发送出去，而是会等待一段时间</strong></p><p>因为ACK 号表示的是已收到的数据量，也就是说，它是告诉发送方目前已接收的数据的最后位置在哪里，因此当需要连续发送ACK 号时，只要发送最后一个ACK 号就可以了</p><h3 id="接受http响应消息" tabindex="-1"><a class="header-anchor" href="#接受http响应消息" aria-hidden="true">#</a> 接受HTTP响应消息</h3><p>协议栈会检查收到的数据块和TCP 头部的内容，判断是否有数据丢失，如果没有问题则返回ACK 号</p><p>协议栈将数据块暂存到接收缓冲区中，并将数据块按顺序连接起来还原出原始的数据，最后将数据交给应用程序</p><p>协议栈会将接收到的数据复制到应用程序指定的内存地址中，然后将控制流程交回应用程序</p><h2 id="从服务器断开并删除嵌套字" tabindex="-1"><a class="header-anchor" href="#从服务器断开并删除嵌套字" aria-hidden="true">#</a> 从服务器断开并删除嵌套字</h2><h3 id="数据发送完毕后断开连接" tabindex="-1"><a class="header-anchor" href="#数据发送完毕后断开连接" aria-hidden="true">#</a> 数据发送完毕后断开连接</h3><p><img src="'+m+'" alt="Untitled"></p><h3 id="删除套接字" tabindex="-1"><a class="header-anchor" href="#删除套接字" aria-hidden="true">#</a> 删除套接字</h3><p>（1）客户端发送FIN （2）服务器返回ACK 号 （3）服务器发送FIN （4）客户端返回ACK 号</p><h3 id="数据收发操作小结" tabindex="-1"><a class="header-anchor" href="#数据收发操作小结" aria-hidden="true">#</a> 数据收发操作小结</h3><p>创建套接字之后，客户端会向服务器发起连接操作。</p><p>客户端会生成一个SYN 为1 的TCP 包并发送给服务器</p><p><img src="'+u+'" alt="Untitled"></p><h2 id="ip与以太网的包收发操" tabindex="-1"><a class="header-anchor" href="#ip与以太网的包收发操" aria-hidden="true">#</a> ip与以太网的包收发操</h2><h3 id="包的基本知识" tabindex="-1"><a class="header-anchor" href="#包的基本知识" aria-hidden="true">#</a> 包的基本知识</h3><p>TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托IP 模块将数据封装成包发送给通信对象。</p><p><img src="'+k+'" alt="Untitled"></p><p><img src="'+b+'" alt="Untitled"></p><p>（1）路由器根据目标地址判断下一个路由器的位置 （2）集线器在子网中将网络包传输到下一个路由</p><p>（1）IP 协议根据目标地址判断下一个IP 转发设备的位置 （2）子网中的以太网协议将包传输到下一个转发设备</p><p><img src="'+P+'" alt="Untitled"></p><h3 id="包收发操作概览" tabindex="-1"><a class="header-anchor" href="#包收发操作概览" aria-hidden="true">#</a> 包收发操作概览</h3><p><img src="'+U+'" alt="Untitled"></p><p><strong>包收发操作的起点是TCP 模块委托IP 模块发送包的操作</strong></p><p>这个委托的过程就是TCP 模块在数据块的前面加上TCP头部，然后整个传递给IP 模块，这部分就是网络包的内容。</p><p>收到委托后，IP 模块会将包的内容当作一整块数据，在前面加上包含制信息的头部</p><blockquote><p>IP 模块负责添加如下两个头部。 （1） MAC 头部：以太网用的头部，包含MAC 地址 （2） IP 头部：IP 用的头部，包含IP 地址</p></blockquote><h3 id="生成包含接收方ip地址的ip头部" tabindex="-1"><a class="header-anchor" href="#生成包含接收方ip地址的ip头部" aria-hidden="true">#</a> 生成包含接收方IP地址的IP头部</h3><p><img src="'+f+'" alt="Untitled"></p><h3 id="生成以太网用的mac头部" tabindex="-1"><a class="header-anchor" href="#生成以太网用的mac头部" aria-hidden="true">#</a> 生成以太网用的MAC头部</h3><h3 id="通过arp查询目标路由器的mac地址" tabindex="-1"><a class="header-anchor" href="#通过arp查询目标路由器的mac地址" aria-hidden="true">#</a> 通过ARP查询目标路由器的MAC地址</h3><p><strong>查询MAC 地址需要使用ARP。</strong></p><h3 id="以太网的基本知识" tabindex="-1"><a class="header-anchor" href="#以太网的基本知识" aria-hidden="true">#</a> 以太网的基本知识</h3><p>以太网是一种为多台计算机能够彼此自由和廉价地相互通信而设计的通信技术</p><p><img src="'+C+'" alt="Untitled"></p><h3 id="将ip包转换为电或光信号发送出去" tabindex="-1"><a class="header-anchor" href="#将ip包转换为电或光信号发送出去" aria-hidden="true">#</a> 将IP包转换为电或光信号发送出去</h3><p>生成的网络包只是存放在内存中的一串数字信息，没有办法直接发送给对方。因此，我们需要将数字信息转换为电或光信号，才能在网线上传输，也就是说，这才是真正的数据发送过程。负责执行这一操作的是网卡</p><p><img src="'+v+'" alt="Untitled"></p><p><strong>网卡的ROM 中保存着全世界唯一的MAC 地址，这是在生产网卡时写入的</strong></p><p><strong>网卡中保存的MAC 地址会由网卡驱动程序读取并分配给MAC模块。</strong></p><h3 id="给网络包加3个控制数据" tabindex="-1"><a class="header-anchor" href="#给网络包加3个控制数据" aria-hidden="true">#</a> 给网络包加3个控制数据</h3><p>网卡驱动从IP 模块获取包之后，会将其复制到网卡内的缓冲区中，然后向MAC 模块发送发送包的命令</p><p>MAC 模块会将包从缓冲区中取出，并在开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</p><p><img src="'+x+'" alt="Untitled"></p><p><img src="'+A+'" alt="Untitled"></p><p>用电信号来表达数字信息时，我们需要让0 和1 两种比特分别对应特定的电压和电流</p><p>在数据信号之外再发送一组用来区分比特间隔的时钟信号</p><p><img src="'+T+'" alt="Untitled"></p><h2 id="向集线器发送网络包" tabindex="-1"><a class="header-anchor" href="#向集线器发送网络包" aria-hidden="true">#</a> 向集线器发送网络包</h2><p><img src="'+I+'" alt="Untitled"></p><p><strong>网卡的MAC 模块生成通用信号，然后由PHY（MAU）模块转换成可在网线中传输的格式，并通过网线发送出去。</strong></p>',94)],K={},M=(0,a(1935).Z)(K,[["render",function(e,t){return(0,i.wg)(),(0,i.iD)("div",null,w)}]])},1935:(e,t)=>{t.Z=(e,t)=>{const a=e.__vccOpts||e;for(const[e,i]of t)a[e]=i;return a}},1190:(e,t,a)=>{a.r(t),a.d(t,{data:()=>i});const i=JSON.parse('{"key":"v-6f7b84b6","path":"/network/how-networks-work-part2.html","title":"电信号传输TCP/IP数据","lang":"zh-CN","frontmatter":{"title":"电信号传输TCP/IP数据","category":["Network"],"tag":["网络是怎样连接的"],"date":"2021-11-15T00:00:00.000Z","summary":"创建嵌套字 协议栈的内部结构 **浏览器、邮件等一般应用程序收发数据时用TCP； DNS 查询等收发较短的控制数据时用UDP。** 套接字的实体就是通信控制信息 在协议栈内部有一块用于存放控制信息的内存空间，这里记录了用于控制通信操作的控制信息，例如通信对象的IP 地址、端口号、通信操作的进行状态等 协议栈是根据套接字中记录的控制信息来工作的。 调用sock","head":[["meta",{"property":"og:url","content":"https://luxiag.github.io/network/how-networks-work-part2.html"}],["meta",{"property":"og:title","content":"电信号传输TCP/IP数据"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://luxiag.github.io/"}],["meta",{"property":"og:updated_time","content":"2023-01-08T13:32:53.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"电信号传输TCP/IP数据"}],["meta",{"property":"article:tag","content":"网络是怎样连接的"}],["meta",{"property":"article:published_time","content":"2021-11-15T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-01-08T13:32:53.000Z"}]]},"excerpt":"","headers":[{"level":2,"title":"创建嵌套字","slug":"创建嵌套字","link":"#创建嵌套字","children":[{"level":3,"title":"协议栈的内部结构","slug":"协议栈的内部结构","link":"#协议栈的内部结构","children":[]},{"level":3,"title":"套接字的实体就是通信控制信息","slug":"套接字的实体就是通信控制信息","link":"#套接字的实体就是通信控制信息","children":[]},{"level":3,"title":"调用socket时的操作","slug":"调用socket时的操作","link":"#调用socket时的操作","children":[]}]},{"level":2,"title":"连接服务器","slug":"连接服务器","link":"#连接服务器","children":[{"level":3,"title":"保存控制信息的头部","slug":"保存控制信息的头部","link":"#保存控制信息的头部","children":[]},{"level":3,"title":"连接操作的实际过程","slug":"连接操作的实际过程","link":"#连接操作的实际过程","children":[]}]},{"level":2,"title":"收发数据","slug":"收发数据","link":"#收发数据","children":[{"level":3,"title":"将HTTP 请求消息交给协议栈","slug":"将http-请求消息交给协议栈","link":"#将http-请求消息交给协议栈","children":[]},{"level":3,"title":"对较大的数据进行拆分","slug":"对较大的数据进行拆分","link":"#对较大的数据进行拆分","children":[]},{"level":3,"title":"使用ACK号确认网络包已收到","slug":"使用ack号确认网络包已收到","link":"#使用ack号确认网络包已收到","children":[]},{"level":3,"title":"根据网络包平均往返时间调整ACK 号等待时间","slug":"根据网络包平均往返时间调整ack-号等待时间","link":"#根据网络包平均往返时间调整ack-号等待时间","children":[]},{"level":3,"title":"使用窗口有效管理ACK号","slug":"使用窗口有效管理ack号","link":"#使用窗口有效管理ack号","children":[]},{"level":3,"title":"ACK与窗口的合并","slug":"ack与窗口的合并","link":"#ack与窗口的合并","children":[]},{"level":3,"title":"接受HTTP响应消息","slug":"接受http响应消息","link":"#接受http响应消息","children":[]}]},{"level":2,"title":"从服务器断开并删除嵌套字","slug":"从服务器断开并删除嵌套字","link":"#从服务器断开并删除嵌套字","children":[{"level":3,"title":"数据发送完毕后断开连接","slug":"数据发送完毕后断开连接","link":"#数据发送完毕后断开连接","children":[]},{"level":3,"title":"删除套接字","slug":"删除套接字","link":"#删除套接字","children":[]},{"level":3,"title":"数据收发操作小结","slug":"数据收发操作小结","link":"#数据收发操作小结","children":[]}]},{"level":2,"title":"ip与以太网的包收发操","slug":"ip与以太网的包收发操","link":"#ip与以太网的包收发操","children":[{"level":3,"title":"包的基本知识","slug":"包的基本知识","link":"#包的基本知识","children":[]},{"level":3,"title":"包收发操作概览","slug":"包收发操作概览","link":"#包收发操作概览","children":[]},{"level":3,"title":"生成包含接收方IP地址的IP头部","slug":"生成包含接收方ip地址的ip头部","link":"#生成包含接收方ip地址的ip头部","children":[]},{"level":3,"title":"生成以太网用的MAC头部","slug":"生成以太网用的mac头部","link":"#生成以太网用的mac头部","children":[]},{"level":3,"title":"通过ARP查询目标路由器的MAC地址","slug":"通过arp查询目标路由器的mac地址","link":"#通过arp查询目标路由器的mac地址","children":[]},{"level":3,"title":"以太网的基本知识","slug":"以太网的基本知识","link":"#以太网的基本知识","children":[]},{"level":3,"title":"将IP包转换为电或光信号发送出去","slug":"将ip包转换为电或光信号发送出去","link":"#将ip包转换为电或光信号发送出去","children":[]},{"level":3,"title":"给网络包加3个控制数据","slug":"给网络包加3个控制数据","link":"#给网络包加3个控制数据","children":[]}]},{"level":2,"title":"向集线器发送网络包","slug":"向集线器发送网络包","link":"#向集线器发送网络包","children":[]}],"git":{"createdTime":1673184773000,"updatedTime":1673184773000,"contributors":[{"name":"luxiag","email":"luxiag@qq.com","commits":1}]},"readingTime":{"minutes":6.3,"words":1889},"filePathRelative":"network/how-networks-work-part2.md","localizedDate":"2021年11月15日"}')}}]);