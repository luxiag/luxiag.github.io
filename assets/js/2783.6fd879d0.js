"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2783],{82783:(t,e,n)=>{n.d(e,{B:()=>i});var r=n(86171);class a extends r.Kj0{constructor(t,e={}){super(t),this.isReflector=!0,this.type="Reflector",this.camera=new r.cPb;const n=this,o=void 0!==e.color?new r.Ilk(e.color):new r.Ilk(8355711),i=e.textureWidth||512,l=e.textureHeight||512,s=e.clipBias||0,u=e.shader||a.ReflectorShader,c=void 0!==e.multisample?e.multisample:4,m=new r.JOQ,d=new r.Pa4,f=new r.Pa4,v=new r.Pa4,p=new r.yGw,x=new r.Pa4(0,0,-1),g=new r.Ltg,h=new r.Pa4,w=new r.Pa4,y=new r.Ltg,M=new r.yGw,b=this.camera,R=new r.dd2(i,l,{samples:c,type:r.cLu}),W=new r.jyz({uniforms:r.rDY.clone(u.uniforms),fragmentShader:u.fragmentShader,vertexShader:u.vertexShader});W.uniforms.tDiffuse.value=R.texture,W.uniforms.color.value=o,W.uniforms.textureMatrix.value=M,this.material=W,this.onBeforeRender=function(t,e,a){if(f.setFromMatrixPosition(n.matrixWorld),v.setFromMatrixPosition(a.matrixWorld),p.extractRotation(n.matrixWorld),d.set(0,0,1),d.applyMatrix4(p),h.subVectors(f,v),h.dot(d)>0)return;h.reflect(d).negate(),h.add(f),p.extractRotation(a.matrixWorld),x.set(0,0,-1),x.applyMatrix4(p),x.add(v),w.subVectors(f,x),w.reflect(d).negate(),w.add(f),b.position.copy(h),b.up.set(0,1,0),b.up.applyMatrix4(p),b.up.reflect(d),b.lookAt(w),b.far=a.far,b.updateMatrixWorld(),b.projectionMatrix.copy(a.projectionMatrix),M.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),M.multiply(b.projectionMatrix),M.multiply(b.matrixWorldInverse),M.multiply(n.matrixWorld),m.setFromNormalAndCoplanarPoint(d,f),m.applyMatrix4(b.matrixWorldInverse),g.set(m.normal.x,m.normal.y,m.normal.z,m.constant);const o=b.projectionMatrix;y.x=(Math.sign(g.x)+o.elements[8])/o.elements[0],y.y=(Math.sign(g.y)+o.elements[9])/o.elements[5],y.z=-1,y.w=(1+o.elements[10])/o.elements[14],g.multiplyScalar(2/g.dot(y)),o.elements[2]=g.x,o.elements[6]=g.y,o.elements[10]=g.z+1-s,o.elements[14]=g.w,n.visible=!1;const i=t.getRenderTarget(),l=t.xr.enabled,u=t.shadowMap.autoUpdate,c=t.outputEncoding,W=t.toneMapping;t.xr.enabled=!1,t.shadowMap.autoUpdate=!1,t.outputEncoding=r.rnI,t.toneMapping=r.uL9,t.setRenderTarget(R),t.state.buffers.depth.setMask(!0),!1===t.autoClear&&t.clear(),t.render(e,b),t.xr.enabled=l,t.shadowMap.autoUpdate=u,t.outputEncoding=c,t.toneMapping=W,t.setRenderTarget(i);const _=a.viewport;void 0!==_&&t.state.viewport(_),n.visible=!0},this.getRenderTarget=function(){return R},this.dispose=function(){R.dispose(),n.material.dispose()}}}a.ReflectorShader={uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:"\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}",fragmentShader:"\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\n\t\t}"};class o extends r.Kj0{constructor(t,e={}){super(t),this.isRefractor=!0,this.type="Refractor",this.camera=new r.cPb;const n=this,a=void 0!==e.color?new r.Ilk(e.color):new r.Ilk(8355711),i=e.textureWidth||512,l=e.textureHeight||512,s=e.clipBias||0,u=e.shader||o.RefractorShader,c=void 0!==e.multisample?e.multisample:4,m=this.camera;m.matrixAutoUpdate=!1,m.userData.refractor=!0;const d=new r.JOQ,f=new r.yGw,v=new r.dd2(i,l,{samples:c,type:r.cLu});this.material=new r.jyz({uniforms:r.rDY.clone(u.uniforms),vertexShader:u.vertexShader,fragmentShader:u.fragmentShader,transparent:!0}),this.material.uniforms.color.value=a,this.material.uniforms.tDiffuse.value=v.texture,this.material.uniforms.textureMatrix.value=f;const p=function(){const t=new r.Pa4,e=new r.Pa4,a=new r.yGw,o=new r.Pa4,i=new r.Pa4;return function(r){return t.setFromMatrixPosition(n.matrixWorld),e.setFromMatrixPosition(r.matrixWorld),o.subVectors(t,e),a.extractRotation(n.matrixWorld),i.set(0,0,1),i.applyMatrix4(a),o.dot(i)<0}}(),x=function(){const t=new r.Pa4,e=new r.Pa4,a=new r._fP,o=new r.Pa4;return function(){n.matrixWorld.decompose(e,a,o),t.set(0,0,1).applyQuaternion(a).normalize(),t.negate(),d.setFromNormalAndCoplanarPoint(t,e)}}(),g=function(){const t=new r.JOQ,e=new r.Ltg,n=new r.Ltg;return function(r){m.matrixWorld.copy(r.matrixWorld),m.matrixWorldInverse.copy(m.matrixWorld).invert(),m.projectionMatrix.copy(r.projectionMatrix),m.far=r.far,t.copy(d),t.applyMatrix4(m.matrixWorldInverse),e.set(t.normal.x,t.normal.y,t.normal.z,t.constant);const a=m.projectionMatrix;n.x=(Math.sign(e.x)+a.elements[8])/a.elements[0],n.y=(Math.sign(e.y)+a.elements[9])/a.elements[5],n.z=-1,n.w=(1+a.elements[10])/a.elements[14],e.multiplyScalar(2/e.dot(n)),a.elements[2]=e.x,a.elements[6]=e.y,a.elements[10]=e.z+1-s,a.elements[14]=e.w}}();this.onBeforeRender=function(t,e,a){!0!==a.userData.refractor&&1!=!p(a)&&(x(),function(t){f.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),f.multiply(t.projectionMatrix),f.multiply(t.matrixWorldInverse),f.multiply(n.matrixWorld)}(a),g(a),function(t,e,a){n.visible=!1;const o=t.getRenderTarget(),i=t.xr.enabled,l=t.shadowMap.autoUpdate,s=t.outputEncoding,u=t.toneMapping;t.xr.enabled=!1,t.shadowMap.autoUpdate=!1,t.outputEncoding=r.rnI,t.toneMapping=r.uL9,t.setRenderTarget(v),!1===t.autoClear&&t.clear(),t.render(e,m),t.xr.enabled=i,t.shadowMap.autoUpdate=l,t.outputEncoding=s,t.toneMapping=u,t.setRenderTarget(o);const c=a.viewport;void 0!==c&&t.state.viewport(c),n.visible=!0}(t,e,a))},this.getRenderTarget=function(){return v},this.dispose=function(){v.dispose(),n.material.dispose()}}}o.RefractorShader={uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:"\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\n\t\t}"};class i extends r.Kj0{constructor(t,e={}){super(t),this.isWater=!0,this.type="Water";const n=this,l=void 0!==e.color?new r.Ilk(e.color):new r.Ilk(16777215),s=e.textureWidth||512,u=e.textureHeight||512,c=e.clipBias||0,m=e.flowDirection||new r.FM8(1,0),d=e.flowSpeed||.03,f=e.reflectivity||.02,v=e.scale||1,p=e.shader||i.WaterShader,x=new r.dpR,g=e.flowMap||void 0,h=e.normalMap0||x.load("textures/water/Water_1_M_Normal.jpg"),w=e.normalMap1||x.load("textures/water/Water_2_M_Normal.jpg"),y=.15,M=.075,b=new r.yGw,R=new r.SUY;if(void 0===a)return void console.error("THREE.Water: Required component Reflector not found.");if(void 0===o)return void console.error("THREE.Water: Required component Refractor not found.");const W=new a(t,{textureWidth:s,textureHeight:u,clipBias:c}),_=new o(t,{textureWidth:s,textureHeight:u,clipBias:c});W.matrixAutoUpdate=!1,_.matrixAutoUpdate=!1,this.material=new r.jyz({uniforms:r.rDY.merge([r.rBU.fog,p.uniforms]),vertexShader:p.vertexShader,fragmentShader:p.fragmentShader,transparent:!0,fog:!0}),void 0!==g?(this.material.defines.USE_FLOWMAP="",this.material.uniforms.tFlowMap={type:"t",value:g}):this.material.uniforms.flowDirection={type:"v2",value:m},h.wrapS=h.wrapT=r.rpg,w.wrapS=w.wrapT=r.rpg,this.material.uniforms.tReflectionMap.value=W.getRenderTarget().texture,this.material.uniforms.tRefractionMap.value=_.getRenderTarget().texture,this.material.uniforms.tNormalMap0.value=h,this.material.uniforms.tNormalMap1.value=w,this.material.uniforms.color.value=l,this.material.uniforms.reflectivity.value=f,this.material.uniforms.textureMatrix.value=b,this.material.uniforms.config.value.x=0,this.material.uniforms.config.value.y=M,this.material.uniforms.config.value.z=M,this.material.uniforms.config.value.w=v,this.onBeforeRender=function(t,e,r){!function(t){b.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),b.multiply(t.projectionMatrix),b.multiply(t.matrixWorldInverse),b.multiply(n.matrixWorld)}(r),function(){const t=R.getDelta(),e=n.material.uniforms.config;e.value.x+=d*t,e.value.y=e.value.x+M,e.value.x>=y?(e.value.x=0,e.value.y=M):e.value.y>=y&&(e.value.y=e.value.y-y)}(),n.visible=!1,W.matrixWorld.copy(n.matrixWorld),_.matrixWorld.copy(n.matrixWorld),W.onBeforeRender(t,e,r),_.onBeforeRender(t,e,r),n.visible=!0}}}i.WaterShader={uniforms:{color:{type:"c",value:null},reflectivity:{type:"f",value:0},tReflectionMap:{type:"t",value:null},tRefractionMap:{type:"t",value:null},tNormalMap0:{type:"t",value:null},tNormalMap1:{type:"t",value:null},textureMatrix:{type:"m4",value:null},config:{type:"v4",value:new r.Ltg}},vertexShader:"\n\n\t\t#include <common>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tvCoord = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\tvToEye = cameraPosition - worldPosition.xyz;\n\n\t\t\tvec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\n\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}",fragmentShader:"\n\n\t\t#include <common>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tuniform sampler2D tReflectionMap;\n\t\tuniform sampler2D tRefractionMap;\n\t\tuniform sampler2D tNormalMap0;\n\t\tuniform sampler2D tNormalMap1;\n\n\t\t#ifdef USE_FLOWMAP\n\t\t\tuniform sampler2D tFlowMap;\n\t\t#else\n\t\t\tuniform vec2 flowDirection;\n\t\t#endif\n\n\t\tuniform vec3 color;\n\t\tuniform float reflectivity;\n\t\tuniform vec4 config;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tfloat flowMapOffset0 = config.x;\n\t\t\tfloat flowMapOffset1 = config.y;\n\t\t\tfloat halfCycle = config.z;\n\t\t\tfloat scale = config.w;\n\n\t\t\tvec3 toEye = normalize( vToEye );\n\n\t\t\t// determine flow direction\n\t\t\tvec2 flow;\n\t\t\t#ifdef USE_FLOWMAP\n\t\t\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\n\t\t\t#else\n\t\t\t\tflow = flowDirection;\n\t\t\t#endif\n\t\t\tflow.x *= - 1.0;\n\n\t\t\t// sample normal maps (distort uvs with flowdata)\n\t\t\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\n\t\t\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\n\n\t\t\t// linear interpolate to get the final normal color\n\t\t\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\n\t\t\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\n\n\t\t\t// calculate normal vector\n\t\t\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n\n\t\t\t// calculate the fresnel term to blend reflection and refraction maps\n\t\t\tfloat theta = max( dot( toEye, normal ), 0.0 );\n\t\t\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\n\n\t\t\t// calculate final uv coords\n\t\t\tvec3 coord = vCoord.xyz / vCoord.w;\n\t\t\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;\n\n\t\t\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\n\t\t\tvec4 refractColor = texture2D( tRefractionMap, uv );\n\n\t\t\t// multiply water color with the mix of both textures\n\t\t\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\n\t\t}"}}}]);