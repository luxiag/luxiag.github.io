"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[1601],{61935:(t,e)=>{e.Z=(t,e)=>{const n=t.__vccOpts||t;for(const[t,o]of e)n[t]=o;return n}},7132:(t,e,n)=>{n.d(e,{x:()=>r});var o=n(86171);class r extends o.yxD{constructor(t){super(t),this.type=o.cLu}parse(t){const e=function(t,e){switch(t){case 1:console.error("THREE.RGBELoader Read Error: "+(e||""));break;case 2:console.error("THREE.RGBELoader Write Error: "+(e||""));break;case 3:console.error("THREE.RGBELoader Bad File Format: "+(e||""));break;default:console.error("THREE.RGBELoader: Error: "+(e||""))}return-1},n=function(t,e,n){e=e||1024;let o=t.pos,r=-1,a=0,i="",l=String.fromCharCode.apply(null,new Uint16Array(t.subarray(o,o+128)));for(;0>(r=l.indexOf("\n"))&&a<e&&o<t.byteLength;)i+=l,a+=l.length,o+=128,l+=String.fromCharCode.apply(null,new Uint16Array(t.subarray(o,o+128)));return-1<r&&(!1!==n&&(t.pos+=a+r+1),i+l.slice(0,r))},r=function(t,e,n,o){const r=t[e+3],a=Math.pow(2,r-128)/255;n[o+0]=t[e+0]*a,n[o+1]=t[e+1]*a,n[o+2]=t[e+2]*a,n[o+3]=1},a=function(t,e,n,r){const a=t[e+3],i=Math.pow(2,a-128)/255;n[r+0]=o.A5E.toHalfFloat(Math.min(t[e+0]*i,65504)),n[r+1]=o.A5E.toHalfFloat(Math.min(t[e+1]*i,65504)),n[r+2]=o.A5E.toHalfFloat(Math.min(t[e+2]*i,65504)),n[r+3]=o.A5E.toHalfFloat(1)},i=new Uint8Array(t);i.pos=0;const l=function(t){const o=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,r=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,a=/^\s*FORMAT=(\S+)\s*$/,i=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,l={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let s,c;if(t.pos>=t.byteLength||!(s=n(t)))return e(1,"no header found");if(!(c=s.match(/^#\?(\S+)/)))return e(3,"bad initial token");for(l.valid|=1,l.programtype=c[1],l.string+=s+"\n";s=n(t),!1!==s;)if(l.string+=s+"\n","#"!==s.charAt(0)){if((c=s.match(o))&&(l.gamma=parseFloat(c[1])),(c=s.match(r))&&(l.exposure=parseFloat(c[1])),(c=s.match(a))&&(l.valid|=2,l.format=c[1]),(c=s.match(i))&&(l.valid|=4,l.height=parseInt(c[1],10),l.width=parseInt(c[2],10)),2&l.valid&&4&l.valid)break}else l.comments+=s+"\n";return 2&l.valid?4&l.valid?l:e(3,"missing image size specifier"):e(3,"missing format specifier")}(i);if(-1!==l){const t=l.width,n=l.height,s=function(t,n,o){const r=n;if(r<8||r>32767||2!==t[0]||2!==t[1]||128&t[2])return new Uint8Array(t);if(r!==(t[2]<<8|t[3]))return e(3,"wrong scanline width");const a=new Uint8Array(4*n*o);if(!a.length)return e(4,"unable to allocate buffer space");let i=0,l=0;const s=4*r,c=new Uint8Array(4),u=new Uint8Array(s);let f=o;for(;f>0&&l<t.byteLength;){if(l+4>t.byteLength)return e(1);if(c[0]=t[l++],c[1]=t[l++],c[2]=t[l++],c[3]=t[l++],2!=c[0]||2!=c[1]||(c[2]<<8|c[3])!=r)return e(3,"bad rgbe scanline format");let n,o=0;for(;o<s&&l<t.byteLength;){n=t[l++];const r=n>128;if(r&&(n-=128),0===n||o+n>s)return e(3,"bad scanline data");if(r){const e=t[l++];for(let t=0;t<n;t++)u[o++]=e}else u.set(t.subarray(l,l+n),o),o+=n,l+=n}const m=r;for(let t=0;t<m;t++){let e=0;a[i]=u[t+e],e+=r,a[i+1]=u[t+e],e+=r,a[i+2]=u[t+e],e+=r,a[i+3]=u[t+e],i+=4}f--}return a}(i.subarray(i.pos),t,n);if(-1!==s){let e,i,c;switch(this.type){case o.VzW:c=s.length/4;const t=new Float32Array(4*c);for(let e=0;e<c;e++)r(s,4*e,t,4*e);e=t,i=o.VzW;break;case o.cLu:c=s.length/4;const n=new Uint16Array(4*c);for(let t=0;t<c;t++)a(s,4*t,n,4*t);e=n,i=o.cLu;break;default:console.error("THREE.RGBELoader: unsupported type: ",this.type)}return{width:t,height:n,data:e,header:l.string,gamma:l.gamma,exposure:l.exposure,type:i}}}return null}setDataType(t){return this.type=t,this}load(t,e,n,r){return super.load(t,(function(t,n){switch(t.type){case o.VzW:case o.cLu:t.encoding=o.rnI,t.minFilter=o.wem,t.magFilter=o.wem,t.generateMipmaps=!1,t.flipY=!0}e&&e(t,n)}),n,r)}}},54636:(t,e,n)=>{n.d(e,{q:()=>r});var o=n(86171);class r extends o.Kj0{constructor(){const t=r.SkyShader,e=new o.jyz({name:"SkyShader",fragmentShader:t.fragmentShader,vertexShader:t.vertexShader,uniforms:o.rDY.clone(t.uniforms),side:o._Li,depthWrite:!1});super(new o.DvJ(1,1,1),e),this.isSky=!0}}r.SkyShader={uniforms:{turbidity:{value:2},rayleigh:{value:1},mieCoefficient:{value:.005},mieDirectionalG:{value:.8},sunPosition:{value:new o.Pa4},up:{value:new o.Pa4(0,1,0)}},vertexShader:"\n\t\tuniform vec3 sunPosition;\n\t\tuniform float rayleigh;\n\t\tuniform float turbidity;\n\t\tuniform float mieCoefficient;\n\t\tuniform vec3 up;\n\n\t\tvarying vec3 vWorldPosition;\n\t\tvarying vec3 vSunDirection;\n\t\tvarying float vSunfade;\n\t\tvarying vec3 vBetaR;\n\t\tvarying vec3 vBetaM;\n\t\tvarying float vSunE;\n\n\t\t// constants for atmospheric scattering\n\t\tconst float e = 2.71828182845904523536028747135266249775724709369995957;\n\t\tconst float pi = 3.141592653589793238462643383279502884197169;\n\n\t\t// wavelength of used primaries, according to preetham\n\t\tconst vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );\n\t\t// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:\n\t\t// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\n\t\tconst vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );\n\n\t\t// mie stuff\n\t\t// K coefficient for the primaries\n\t\tconst float v = 4.0;\n\t\tconst vec3 K = vec3( 0.686, 0.678, 0.666 );\n\t\t// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\n\t\tconst vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );\n\n\t\t// earth shadow hack\n\t\t// cutoffAngle = pi / 1.95;\n\t\tconst float cutoffAngle = 1.6110731556870734;\n\t\tconst float steepness = 1.5;\n\t\tconst float EE = 1000.0;\n\n\t\tfloat sunIntensity( float zenithAngleCos ) {\n\t\t\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );\n\t\t\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );\n\t\t}\n\n\t\tvec3 totalMie( float T ) {\n\t\t\tfloat c = ( 0.2 * T ) * 10E-18;\n\t\t\treturn 0.434 * c * MieConst;\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\tvWorldPosition = worldPosition.xyz;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position.z = gl_Position.w; // set z to camera.far\n\n\t\t\tvSunDirection = normalize( sunPosition );\n\n\t\t\tvSunE = sunIntensity( dot( vSunDirection, up ) );\n\n\t\t\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );\n\n\t\t\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );\n\n\t\t\t// extinction (absorbtion + out scattering)\n\t\t\t// rayleigh coefficients\n\t\t\tvBetaR = totalRayleigh * rayleighCoefficient;\n\n\t\t\t// mie coefficients\n\t\t\tvBetaM = totalMie( turbidity ) * mieCoefficient;\n\n\t\t}",fragmentShader:"\n\t\tvarying vec3 vWorldPosition;\n\t\tvarying vec3 vSunDirection;\n\t\tvarying float vSunfade;\n\t\tvarying vec3 vBetaR;\n\t\tvarying vec3 vBetaM;\n\t\tvarying float vSunE;\n\n\t\tuniform float mieDirectionalG;\n\t\tuniform vec3 up;\n\n\t\tconst vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );\n\n\t\t// constants for atmospheric scattering\n\t\tconst float pi = 3.141592653589793238462643383279502884197169;\n\n\t\tconst float n = 1.0003; // refractive index of air\n\t\tconst float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)\n\n\t\t// optical length at zenith for molecules\n\t\tconst float rayleighZenithLength = 8.4E3;\n\t\tconst float mieZenithLength = 1.25E3;\n\t\t// 66 arc seconds -> degrees, and the cosine of that\n\t\tconst float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\n\n\t\t// 3.0 / ( 16.0 * pi )\n\t\tconst float THREE_OVER_SIXTEENPI = 0.05968310365946075;\n\t\t// 1.0 / ( 4.0 * pi )\n\t\tconst float ONE_OVER_FOURPI = 0.07957747154594767;\n\n\t\tfloat rayleighPhase( float cosTheta ) {\n\t\t\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );\n\t\t}\n\n\t\tfloat hgPhase( float cosTheta, float g ) {\n\t\t\tfloat g2 = pow( g, 2.0 );\n\t\t\tfloat inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );\n\t\t\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec3 direction = normalize( vWorldPosition - cameraPos );\n\n\t\t\t// optical length\n\t\t\t// cutoff angle at 90 to avoid singularity in next formula.\n\t\t\tfloat zenithAngle = acos( max( 0.0, dot( up, direction ) ) );\n\t\t\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );\n\t\t\tfloat sR = rayleighZenithLength * inverse;\n\t\t\tfloat sM = mieZenithLength * inverse;\n\n\t\t\t// combined extinction factor\n\t\t\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );\n\n\t\t\t// in scattering\n\t\t\tfloat cosTheta = dot( direction, vSunDirection );\n\n\t\t\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );\n\t\t\tvec3 betaRTheta = vBetaR * rPhase;\n\n\t\t\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );\n\t\t\tvec3 betaMTheta = vBetaM * mPhase;\n\n\t\t\tvec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );\n\t\t\tLin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );\n\n\t\t\t// nightsky\n\t\t\tfloat theta = acos( direction.y ); // elevation --\x3e y-axis, [-pi/2, pi/2]\n\t\t\tfloat phi = atan( direction.z, direction.x ); // azimuth --\x3e x-axis [-pi/2, pi/2]\n\t\t\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );\n\t\t\tvec3 L0 = vec3( 0.1 ) * Fex;\n\n\t\t\t// composition + solar disc\n\t\t\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );\n\t\t\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;\n\n\t\t\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );\n\n\t\t\tvec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );\n\n\t\t\tgl_FragColor = vec4( retColor, 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\n\t\t}"}},99759:(t,e,n)=>{n.d(e,{B:()=>r});var o=n(86171);class r extends o.Kj0{constructor(t,e={}){super(t),this.isWater=!0;const n=this,r=void 0!==e.textureWidth?e.textureWidth:512,a=void 0!==e.textureHeight?e.textureHeight:512,i=void 0!==e.clipBias?e.clipBias:0,l=void 0!==e.alpha?e.alpha:1,s=void 0!==e.time?e.time:0,c=void 0!==e.waterNormals?e.waterNormals:null,u=void 0!==e.sunDirection?e.sunDirection:new o.Pa4(.70707,.70707,0),f=new o.Ilk(void 0!==e.sunColor?e.sunColor:16777215),m=new o.Ilk(void 0!==e.waterColor?e.waterColor:8355711),v=void 0!==e.eye?e.eye:new o.Pa4(0,0,0),d=void 0!==e.distortionScale?e.distortionScale:20,p=void 0!==e.side?e.side:o.Wl3,h=void 0!==e.fog&&e.fog,g=new o.JOQ,y=new o.Pa4,x=new o.Pa4,w=new o.Pa4,E=new o.yGw,S=new o.Pa4(0,0,-1),b=new o.Ltg,C=new o.Pa4,M=new o.Pa4,P=new o.Ltg,R=new o.yGw,_=new o.cPb,D=new o.dd2(r,a),L={uniforms:o.rDY.merge([o.rBU.fog,o.rBU.lights,{normalSampler:{value:null},mirrorSampler:{value:null},alpha:{value:1},time:{value:0},size:{value:1},distortionScale:{value:20},textureMatrix:{value:new o.yGw},sunColor:{value:new o.Ilk(8355711)},sunDirection:{value:new o.Pa4(.70707,.70707,0)},eye:{value:new o.Pa4},waterColor:{value:new o.Ilk(5592405)}}]),vertexShader:"\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tuniform float time;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\tworldPosition = mirrorCoord.xyzw;\n\t\t\t\t\tmirrorCoord = textureMatrix * mirrorCoord;\n\t\t\t\t\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t#include <beginnormal_vertex>\n\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t#include <fog_vertex>\n\t\t\t\t#include <shadowmap_vertex>\n\t\t\t}",fragmentShader:"\n\t\t\t\tuniform sampler2D mirrorSampler;\n\t\t\t\tuniform float alpha;\n\t\t\t\tuniform float time;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float distortionScale;\n\t\t\t\tuniform sampler2D normalSampler;\n\t\t\t\tuniform vec3 sunColor;\n\t\t\t\tuniform vec3 sunDirection;\n\t\t\t\tuniform vec3 eye;\n\t\t\t\tuniform vec3 waterColor;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\tvec4 getNoise( vec2 uv ) {\n\t\t\t\t\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n\t\t\t\t\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n\t\t\t\t\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n\t\t\t\t\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n\t\t\t\t\tvec4 noise = texture2D( normalSampler, uv0 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv1 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv2 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv3 );\n\t\t\t\t\treturn noise * 0.5 - 1.0;\n\t\t\t\t}\n\n\t\t\t\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n\t\t\t\t\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n\t\t\t\t\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\n\t\t\t\t\tspecularColor += pow( direction, shiny ) * sunColor * spec;\n\t\t\t\t\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n\t\t\t\t}\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <packing>\n\t\t\t\t#include <bsdfs>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <lights_pars_begin>\n\t\t\t\t#include <shadowmap_pars_fragment>\n\t\t\t\t#include <shadowmask_pars_fragment>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t\tvec4 noise = getNoise( worldPosition.xz * size );\n\t\t\t\t\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n\n\t\t\t\t\tvec3 diffuseLight = vec3(0.0);\n\t\t\t\t\tvec3 specularLight = vec3(0.0);\n\n\t\t\t\t\tvec3 worldToEye = eye-worldPosition.xyz;\n\t\t\t\t\tvec3 eyeDirection = normalize( worldToEye );\n\t\t\t\t\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n\t\t\t\t\tfloat distance = length(worldToEye);\n\n\t\t\t\t\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n\t\t\t\t\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n\t\t\t\t\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n\t\t\t\t\tfloat rf0 = 0.3;\n\t\t\t\t\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n\t\t\t\t\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n\t\t\t\t\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\n\t\t\t\t\tvec3 outgoingLight = albedo;\n\t\t\t\t\tgl_FragColor = vec4( outgoingLight, alpha );\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <fog_fragment>\n\t\t\t\t}"},z=new o.jyz({fragmentShader:L.fragmentShader,vertexShader:L.vertexShader,uniforms:o.rDY.clone(L.uniforms),lights:!0,side:p,fog:h});z.uniforms.mirrorSampler.value=D.texture,z.uniforms.textureMatrix.value=R,z.uniforms.alpha.value=l,z.uniforms.time.value=s,z.uniforms.normalSampler.value=c,z.uniforms.sunColor.value=f,z.uniforms.waterColor.value=m,z.uniforms.sunDirection.value=u,z.uniforms.distortionScale.value=d,z.uniforms.eye.value=v,n.material=z,n.onBeforeRender=function(t,e,o){if(x.setFromMatrixPosition(n.matrixWorld),w.setFromMatrixPosition(o.matrixWorld),E.extractRotation(n.matrixWorld),y.set(0,0,1),y.applyMatrix4(E),C.subVectors(x,w),C.dot(y)>0)return;C.reflect(y).negate(),C.add(x),E.extractRotation(o.matrixWorld),S.set(0,0,-1),S.applyMatrix4(E),S.add(w),M.subVectors(x,S),M.reflect(y).negate(),M.add(x),_.position.copy(C),_.up.set(0,1,0),_.up.applyMatrix4(E),_.up.reflect(y),_.lookAt(M),_.far=o.far,_.updateMatrixWorld(),_.projectionMatrix.copy(o.projectionMatrix),R.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),R.multiply(_.projectionMatrix),R.multiply(_.matrixWorldInverse),g.setFromNormalAndCoplanarPoint(y,x),g.applyMatrix4(_.matrixWorldInverse),b.set(g.normal.x,g.normal.y,g.normal.z,g.constant);const r=_.projectionMatrix;P.x=(Math.sign(b.x)+r.elements[8])/r.elements[0],P.y=(Math.sign(b.y)+r.elements[9])/r.elements[5],P.z=-1,P.w=(1+r.elements[10])/r.elements[14],b.multiplyScalar(2/b.dot(P)),r.elements[2]=b.x,r.elements[6]=b.y,r.elements[10]=b.z+1-i,r.elements[14]=b.w,v.setFromMatrixPosition(o.matrixWorld);const a=t.getRenderTarget(),l=t.xr.enabled,s=t.shadowMap.autoUpdate;n.visible=!1,t.xr.enabled=!1,t.shadowMap.autoUpdate=!1,t.setRenderTarget(D),t.state.buffers.depth.setMask(!0),!1===t.autoClear&&t.clear(),t.render(e,_),n.visible=!0,t.xr.enabled=l,t.shadowMap.autoUpdate=s,t.setRenderTarget(a);const c=o.viewport;void 0!==c&&t.state.viewport(c)}}}}}]);