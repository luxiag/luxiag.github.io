import{UniformsUtils,UniformsLib,ShaderMaterial,Color,MultiplyOperation}from"three";const GouraudShader={uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0)}}]),vertexShader:"\n\n\t\t#define GOURAUD\n\n\t\tvarying vec3 vLightFront;\n\t\tvarying vec3 vIndirectFront;\n\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvarying vec3 vLightBack;\n\t\t\tvarying vec3 vIndirectBack;\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <uv_pars_vertex>\n\t\t#include <envmap_pars_vertex>\n\t\t#include <bsdfs>\n\t\t#include <lights_pars_begin>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <morphtarget_pars_vertex>\n\t\t#include <skinning_pars_vertex>\n\t\t#include <shadowmap_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\t#include <uv_vertex>\n\t\t\t#include <color_vertex>\n\t\t\t#include <morphcolor_vertex>\n\n\t\t\t#include <beginnormal_vertex>\n\t\t\t#include <morphnormal_vertex>\n\t\t\t#include <skinbase_vertex>\n\t\t\t#include <skinnormal_vertex>\n\t\t\t#include <defaultnormal_vertex>\n\n\t\t\t#include <begin_vertex>\n\t\t\t#include <morphtarget_vertex>\n\t\t\t#include <skinning_vertex>\n\t\t\t#include <project_vertex>\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\n\t\t\t#include <worldpos_vertex>\n\t\t\t#include <envmap_vertex>\n\n\t\t\t// inlining legacy <lights_lambert_vertex>\n\n\t\t\tvec3 diffuse = vec3( 1.0 );\n\n\t\t\tGeometricContext geometry;\n\t\t\tgeometry.position = mvPosition.xyz;\n\t\t\tgeometry.normal = normalize( transformedNormal );\n\t\t\tgeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\n\n\t\t\tGeometricContext backGeometry;\n\t\t\tbackGeometry.position = geometry.position;\n\t\t\tbackGeometry.normal = -geometry.normal;\n\t\t\tbackGeometry.viewDir = geometry.viewDir;\n\n\t\t\tvLightFront = vec3( 0.0 );\n\t\t\tvIndirectFront = vec3( 0.0 );\n\t\t\t#ifdef DOUBLE_SIDED\n\t\t\t\tvLightBack = vec3( 0.0 );\n\t\t\t\tvIndirectBack = vec3( 0.0 );\n\t\t\t#endif\n\n\t\t\tIncidentLight directLight;\n\t\t\tfloat dotNL;\n\t\t\tvec3 directLightColor_Diffuse;\n\n\t\t\tvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\n\n\t\t\tvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\n\t\t\t\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n\n\t\t\t#endif\n\n\t\t\t#if NUM_POINT_LIGHTS > 0\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\t\t\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\n\t\t\t\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\t\t\t\tdirectLightColor_Diffuse = directLight.color;\n\n\t\t\t\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t#endif\n\n\t\t\t#if NUM_SPOT_LIGHTS > 0\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\t\t\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\n\t\t\t\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\t\t\t\tdirectLightColor_Diffuse = directLight.color;\n\n\t\t\t\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\n\t\t\t\t\t#endif\n\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t#endif\n\n\t\t\t#if NUM_DIR_LIGHTS > 0\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\t\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\n\t\t\t\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\t\t\t\tdirectLightColor_Diffuse = directLight.color;\n\n\t\t\t\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t#endif\n\n\t\t\t#if NUM_HEMI_LIGHTS > 0\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\t\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\n\t\t\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\n\t\t\t\t\t#endif\n\n\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t#endif\n\n\t\t\t#include <shadowmap_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}",fragmentShader:"\n\n\t\t#define GOURAUD\n\n\t\tuniform vec3 diffuse;\n\t\tuniform vec3 emissive;\n\t\tuniform float opacity;\n\n\t\tvarying vec3 vLightFront;\n\t\tvarying vec3 vIndirectFront;\n\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvarying vec3 vLightBack;\n\t\t\tvarying vec3 vIndirectBack;\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <packing>\n\t\t#include <dithering_pars_fragment>\n\t\t#include <color_pars_fragment>\n\t\t#include <uv_pars_fragment>\n\t\t#include <map_pars_fragment>\n\t\t#include <alphamap_pars_fragment>\n\t\t#include <alphatest_pars_fragment>\n\t\t#include <aomap_pars_fragment>\n\t\t#include <lightmap_pars_fragment>\n\t\t#include <emissivemap_pars_fragment>\n\t\t#include <envmap_common_pars_fragment>\n\t\t#include <envmap_pars_fragment>\n\t\t#include <bsdfs>\n\t\t#include <lights_pars_begin>\n\t\t#include <fog_pars_fragment>\n\t\t#include <shadowmap_pars_fragment>\n\t\t#include <shadowmask_pars_fragment>\n\t\t#include <specularmap_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t\t\tvec3 totalEmissiveRadiance = emissive;\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <map_fragment>\n\t\t\t#include <color_fragment>\n\t\t\t#include <alphamap_fragment>\n\t\t\t#include <alphatest_fragment>\n\t\t\t#include <specularmap_fragment>\n\t\t\t#include <emissivemap_fragment>\n\n\t\t\t// accumulation\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\n\t\t\t#else\n\n\t\t\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\n\t\t\t#endif\n\n\t\t\t#include <lightmap_fragment>\n\n\t\t\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\n\t\t\t#else\n\n\t\t\t\treflectedLight.directDiffuse = vLightFront;\n\n\t\t\t#endif\n\n\t\t\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\n\t\t\t// modulation\n\n\t\t\t#include <aomap_fragment>\n\n\t\t\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\n\t\t\t#include <envmap_fragment>\n\n\t\t\t#include <output_fragment>\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t#include <dithering_fragment>\n\n\t\t}"};class MeshGouraudMaterial extends ShaderMaterial{constructor(t){super(),this.isMeshGouraudMaterial=!0,this.type="MeshGouraudMaterial",this.combine=MultiplyOperation,this.fog=!1,this.lights=!0,this.clipping=!1;const n=GouraudShader;this.defines=Object.assign({},n.defines),this.uniforms=UniformsUtils.clone(n.uniforms),this.vertexShader=n.vertexShader,this.fragmentShader=n.fragmentShader;const e=["map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","specularMap","alphaMap","envMap","reflectivity","refractionRatio","opacity","diffuse"];for(const t of e)Object.defineProperty(this,t,{get:function(){return this.uniforms[t].value},set:function(n){this.uniforms[t].value=n}});Object.defineProperty(this,"color",Object.getOwnPropertyDescriptor(this,"diffuse")),this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}export{MeshGouraudMaterial};