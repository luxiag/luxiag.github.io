import{Frustum,Vector3,Matrix4,Quaternion}from"three";const _frustum=new Frustum,_center=new Vector3,_tmpPoint=new Vector3,_vecNear=new Vector3,_vecTopLeft=new Vector3,_vecTopRight=new Vector3,_vecDownRight=new Vector3,_vecDownLeft=new Vector3,_vecFarTopLeft=new Vector3,_vecFarTopRight=new Vector3,_vecFarDownRight=new Vector3,_vecFarDownLeft=new Vector3,_vectemp1=new Vector3,_vectemp2=new Vector3,_vectemp3=new Vector3,_matrix=new Matrix4,_quaternion=new Quaternion,_scale=new Vector3;class SelectionBox{constructor(e,t,o=Number.MAX_VALUE){this.camera=e,this.scene=t,this.startPoint=new Vector3,this.endPoint=new Vector3,this.collection=[],this.instances={},this.deep=o}select(e,t){return this.startPoint=e||this.startPoint,this.endPoint=t||this.endPoint,this.collection=[],this.updateFrustum(this.startPoint,this.endPoint),this.searchChildInFrustum(_frustum,this.scene),this.collection}updateFrustum(e,t){if(e=e||this.startPoint,t=t||this.endPoint,e.x===t.x&&(t.x+=Number.EPSILON),e.y===t.y&&(t.y+=Number.EPSILON),this.camera.updateProjectionMatrix(),this.camera.updateMatrixWorld(),this.camera.isPerspectiveCamera){_tmpPoint.copy(e),_tmpPoint.x=Math.min(e.x,t.x),_tmpPoint.y=Math.max(e.y,t.y),t.x=Math.max(e.x,t.x),t.y=Math.min(e.y,t.y),_vecNear.setFromMatrixPosition(this.camera.matrixWorld),_vecTopLeft.copy(_tmpPoint),_vecTopRight.set(t.x,_tmpPoint.y,0),_vecDownRight.copy(t),_vecDownLeft.set(_tmpPoint.x,t.y,0),_vecTopLeft.unproject(this.camera),_vecTopRight.unproject(this.camera),_vecDownRight.unproject(this.camera),_vecDownLeft.unproject(this.camera),_vectemp1.copy(_vecTopLeft).sub(_vecNear),_vectemp2.copy(_vecTopRight).sub(_vecNear),_vectemp3.copy(_vecDownRight).sub(_vecNear),_vectemp1.normalize(),_vectemp2.normalize(),_vectemp3.normalize(),_vectemp1.multiplyScalar(this.deep),_vectemp2.multiplyScalar(this.deep),_vectemp3.multiplyScalar(this.deep),_vectemp1.add(_vecNear),_vectemp2.add(_vecNear),_vectemp3.add(_vecNear);const o=_frustum.planes;o[0].setFromCoplanarPoints(_vecNear,_vecTopLeft,_vecTopRight),o[1].setFromCoplanarPoints(_vecNear,_vecTopRight,_vecDownRight),o[2].setFromCoplanarPoints(_vecDownRight,_vecDownLeft,_vecNear),o[3].setFromCoplanarPoints(_vecDownLeft,_vecTopLeft,_vecNear),o[4].setFromCoplanarPoints(_vecTopRight,_vecDownRight,_vecDownLeft),o[5].setFromCoplanarPoints(_vectemp3,_vectemp2,_vectemp1),o[5].normal.multiplyScalar(-1)}else if(this.camera.isOrthographicCamera){const o=Math.min(e.x,t.x),c=Math.max(e.y,t.y),r=Math.max(e.x,t.x),n=Math.min(e.y,t.y);_vecTopLeft.set(o,c,-1),_vecTopRight.set(r,c,-1),_vecDownRight.set(r,n,-1),_vecDownLeft.set(o,n,-1),_vecFarTopLeft.set(o,c,1),_vecFarTopRight.set(r,c,1),_vecFarDownRight.set(r,n,1),_vecFarDownLeft.set(o,n,1),_vecTopLeft.unproject(this.camera),_vecTopRight.unproject(this.camera),_vecDownRight.unproject(this.camera),_vecDownLeft.unproject(this.camera),_vecFarTopLeft.unproject(this.camera),_vecFarTopRight.unproject(this.camera),_vecFarDownRight.unproject(this.camera),_vecFarDownLeft.unproject(this.camera);const i=_frustum.planes;i[0].setFromCoplanarPoints(_vecTopLeft,_vecFarTopLeft,_vecFarTopRight),i[1].setFromCoplanarPoints(_vecTopRight,_vecFarTopRight,_vecFarDownRight),i[2].setFromCoplanarPoints(_vecFarDownRight,_vecFarDownLeft,_vecDownLeft),i[3].setFromCoplanarPoints(_vecFarDownLeft,_vecFarTopLeft,_vecTopLeft),i[4].setFromCoplanarPoints(_vecTopRight,_vecDownRight,_vecDownLeft),i[5].setFromCoplanarPoints(_vecFarDownRight,_vecFarTopRight,_vecFarTopLeft),i[5].normal.multiplyScalar(-1)}else console.error("THREE.SelectionBox: Unsupported camera type.")}searchChildInFrustum(e,t){if(t.isMesh||t.isLine||t.isPoints)if(t.isInstancedMesh){this.instances[t.uuid]=[];for(let o=0;o<t.count;o++)t.getMatrixAt(o,_matrix),_matrix.decompose(_center,_quaternion,_scale),_center.applyMatrix4(t.matrixWorld),e.containsPoint(_center)&&this.instances[t.uuid].push(o)}else null===t.geometry.boundingSphere&&t.geometry.computeBoundingSphere(),_center.copy(t.geometry.boundingSphere.center),_center.applyMatrix4(t.matrixWorld),e.containsPoint(_center)&&this.collection.push(t);if(t.children.length>0)for(let o=0;o<t.children.length;o++)this.searchChildInFrustum(e,t.children[o])}}export{SelectionBox};