import{DoubleSide}from"three";import*as fflate from"../libs/fflate.module.js";class USDZExporter{async parse(t,e={}){e=Object.assign({ar:{anchoring:{type:"plane"},planeAnchoring:{alignment:"horizontal"}}},e);const n={"model.usda":null};let r=buildHeader();r+=buildSceneStart(e);const o={},i={};t.traverseVisible((t=>{if(t.isMesh){const e=t.geometry,i=t.material;if(i.isMeshStandardMaterial){const a="geometries/Geometry_"+e.id+".usd";if(!(a in n)){const t=buildMeshObject(e);n[a]=buildUSDFileAsString(t)}i.uuid in o||(o[i.uuid]=i),r+=buildXform(t,e,i)}else console.warn("THREE.USDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)",t)}else t.isCamera&&(r+=buildCamera(t))})),r+=buildSceneEnd(),r+=buildMaterials(o,i),n["model.usda"]=fflate.strToU8(r),r=null;for(const t in i){const e=i[t],r=t.split("_")[1],o=1023===e.format,a=imageToCanvas(e.image,r,e.flipY),s=await new Promise((t=>a.toBlob(t,o?"image/png":"image/jpeg",1)));n[`textures/Texture_${t}.${o?"png":"jpg"}`]=new Uint8Array(await s.arrayBuffer())}let a=0;for(const t in n){const e=n[t];a+=34+t.length;const r=63&a;if(4!==r){const o=new Uint8Array(64-r);n[t]=[e,{extra:{12345:o}}]}a=e.length}return fflate.zipSync(n,{level:0})}}function imageToCanvas(t,e,n){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&t instanceof OffscreenCanvas||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const r=1024/Math.max(t.width,t.height),o=document.createElement("canvas");o.width=t.width*Math.min(1,r),o.height=t.height*Math.min(1,r);const i=o.getContext("2d");if(!0===n&&(i.translate(0,o.height),i.scale(1,-1)),i.drawImage(t,0,0,o.width,o.height),void 0!==e){const t=parseInt(e,16),n=(t>>16&255)/255,r=(t>>8&255)/255,a=(255&t)/255,s=i.getImageData(0,0,o.width,o.height),u=s.data;for(let t=0;t<u.length;t+=4)u[t+0]=u[t+0]*n,u[t+1]=u[t+1]*r,u[t+2]=u[t+2]*a;i.putImageData(s,0,0)}return o}throw new Error("THREE.USDZExporter: No valid image data found. Unable to process texture.")}const PRECISION=7;function buildHeader(){return'#usda 1.0\n(\n    customLayerData = {\n        string creator = "Three.js USDZExporter"\n    }\n    metersPerUnit = 1\n    upAxis = "Y"\n)\n\n'}function buildSceneStart(t){return`def Xform "Root"\n{\n    def Scope "Scenes" (\n        kind = "sceneLibrary"\n    )\n    {\n        def Xform "Scene" (\n            customData = {\n                bool preliminary_collidesWithEnvironment = 0\n                string sceneName = "Scene"\n            }\n            sceneName = "Scene"\n        )\n        {\n        token preliminary:anchoring:type = "${t.ar.anchoring.type}"\n        token preliminary:planeAnchoring:alignment = "${t.ar.planeAnchoring.alignment}"\n\n`}function buildSceneEnd(){return"\n        }\n    }\n}\n\n"}function buildUSDFileAsString(t){let e=buildHeader();return e+=t,fflate.strToU8(e)}function buildXform(t,e,n){const r="Object_"+t.id,o=buildMatrix(t.matrixWorld);return t.matrixWorld.determinant()<0&&console.warn("THREE.USDZExporter: USDZ does not support negative scales",t),`def Xform "${r}" (\n    prepend references = @./geometries/Geometry_${e.id}.usd@</Geometry>\n)\n{\n    matrix4d xformOp:transform = ${o}\n    uniform token[] xformOpOrder = ["xformOp:transform"]\n\n    rel material:binding = </Materials/Material_${n.id}>\n}\n\n`}function buildMatrix(t){const e=t.elements;return`( ${buildMatrixRow(e,0)}, ${buildMatrixRow(e,4)}, ${buildMatrixRow(e,8)}, ${buildMatrixRow(e,12)} )`}function buildMatrixRow(t,e){return`(${t[e+0]}, ${t[e+1]}, ${t[e+2]}, ${t[e+3]})`}function buildMeshObject(t){return`\ndef "Geometry"\n{\n  ${buildMesh(t)}\n}\n`}function buildMesh(t){const e=t.attributes,n=e.position.count;return`\n    def Mesh "Geometry"\n    {\n        int[] faceVertexCounts = [${buildMeshVertexCount(t)}]\n        int[] faceVertexIndices = [${buildMeshVertexIndices(t)}]\n        normal3f[] normals = [${buildVector3Array(e.normal,n)}] (\n            interpolation = "vertex"\n        )\n        point3f[] points = [${buildVector3Array(e.position,n)}]\n        float2[] primvars:st = [${buildVector2Array(e.uv,n)}] (\n            interpolation = "vertex"\n        )\n        uniform token subdivisionScheme = "none"\n    }\n`}function buildMeshVertexCount(t){const e=null!==t.index?t.index.count:t.attributes.position.count;return Array(e/3).fill(3).join(", ")}function buildMeshVertexIndices(t){const e=t.index,n=[];if(null!==e)for(let t=0;t<e.count;t++)n.push(e.getX(t));else{const e=t.attributes.position.count;for(let t=0;t<e;t++)n.push(t)}return n.join(", ")}function buildVector3Array(t,e){if(void 0===t)return console.warn("USDZExporter: Normals missing."),Array(e).fill("(0, 0, 0)").join(", ");const n=[];for(let e=0;e<t.count;e++){const r=t.getX(e),o=t.getY(e),i=t.getZ(e);n.push(`(${r.toPrecision(7)}, ${o.toPrecision(7)}, ${i.toPrecision(7)})`)}return n.join(", ")}function buildVector2Array(t,e){if(void 0===t)return console.warn("USDZExporter: UVs missing."),Array(e).fill("(0, 0)").join(", ");const n=[];for(let e=0;e<t.count;e++){const r=t.getX(e),o=t.getY(e);n.push(`(${r.toPrecision(7)}, ${1-o.toPrecision(7)})`)}return n.join(", ")}function buildMaterials(t,e){const n=[];for(const r in t){const o=t[r];n.push(buildMaterial(o,e))}return`def "Materials"\n{\n${n.join("")}\n}\n\n`}function buildMaterial(t,e){const n="            ",r=[],o=[];function i(n,r,o){const i=n.id+(o?"_"+o.getHexString():""),a=1023===n.format;return e[i]=n,`\n        def Shader "Transform2d_${r}" (\n            sdrMetadata = {\n                string role = "math"\n            }\n        )\n        {\n            uniform token info:id = "UsdTransform2d"\n            float2 inputs:in.connect = </Materials/Material_${t.id}/uvReader_st.outputs:result>\n            float2 inputs:scale = ${buildVector2(n.repeat)}\n            float2 inputs:translation = ${buildVector2(n.offset)}\n            float2 outputs:result\n        }\n\n        def Shader "Texture_${n.id}_${r}"\n        {\n            uniform token info:id = "UsdUVTexture"\n            asset inputs:file = @textures/Texture_${i}.${a?"png":"jpg"}@\n            float2 inputs:st.connect = </Materials/Material_${t.id}/Transform2d_${r}.outputs:result>\n            token inputs:wrapS = "repeat"\n            token inputs:wrapT = "repeat"\n            float outputs:r\n            float outputs:g\n            float outputs:b\n            float3 outputs:rgb\n            ${t.transparent||t.alphaTest>0?"float outputs:a":""}\n        }`}return t.side===DoubleSide&&console.warn("THREE.USDZExporter: USDZ does not support double sided materials",t),null!==t.map?(r.push(`${n}color3f inputs:diffuseColor.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:rgb>`),t.transparent?r.push(`${n}float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:a>`):t.alphaTest>0&&(r.push(`${n}float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:a>`),r.push(`${n}float inputs:opacityThreshold = ${t.alphaTest}`)),o.push(i(t.map,"diffuse",t.color))):r.push(`${n}color3f inputs:diffuseColor = ${buildColor(t.color)}`),null!==t.emissiveMap?(r.push(`${n}color3f inputs:emissiveColor.connect = </Materials/Material_${t.id}/Texture_${t.emissiveMap.id}_emissive.outputs:rgb>`),o.push(i(t.emissiveMap,"emissive"))):t.emissive.getHex()>0&&r.push(`${n}color3f inputs:emissiveColor = ${buildColor(t.emissive)}`),null!==t.normalMap&&(r.push(`${n}normal3f inputs:normal.connect = </Materials/Material_${t.id}/Texture_${t.normalMap.id}_normal.outputs:rgb>`),o.push(i(t.normalMap,"normal"))),null!==t.aoMap&&(r.push(`${n}float inputs:occlusion.connect = </Materials/Material_${t.id}/Texture_${t.aoMap.id}_occlusion.outputs:r>`),o.push(i(t.aoMap,"occlusion"))),null!==t.roughnessMap&&1===t.roughness?(r.push(`${n}float inputs:roughness.connect = </Materials/Material_${t.id}/Texture_${t.roughnessMap.id}_roughness.outputs:g>`),o.push(i(t.roughnessMap,"roughness"))):r.push(`${n}float inputs:roughness = ${t.roughness}`),null!==t.metalnessMap&&1===t.metalness?(r.push(`${n}float inputs:metallic.connect = </Materials/Material_${t.id}/Texture_${t.metalnessMap.id}_metallic.outputs:b>`),o.push(i(t.metalnessMap,"metallic"))):r.push(`${n}float inputs:metallic = ${t.metalness}`),null!==t.alphaMap?(r.push(`${n}float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.alphaMap.id}_opacity.outputs:r>`),r.push(`${n}float inputs:opacityThreshold = 0.0001`),o.push(i(t.alphaMap,"opacity"))):r.push(`${n}float inputs:opacity = ${t.opacity}`),t.isMeshPhysicalMaterial&&(r.push(`${n}float inputs:clearcoat = ${t.clearcoat}`),r.push(`${n}float inputs:clearcoatRoughness = ${t.clearcoatRoughness}`),r.push(`${n}float inputs:ior = ${t.ior}`)),`\n    def Material "Material_${t.id}"\n    {\n        def Shader "PreviewSurface"\n        {\n            uniform token info:id = "UsdPreviewSurface"\n${r.join("\n")}\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n\n        token outputs:surface.connect = </Materials/Material_${t.id}/PreviewSurface.outputs:surface>\n        token inputs:frame:stPrimvarName = "st"\n\n        def Shader "uvReader_st"\n        {\n            uniform token info:id = "UsdPrimvarReader_float2"\n            token inputs:varname.connect = </Materials/Material_${t.id}.inputs:frame:stPrimvarName>\n            float2 inputs:fallback = (0.0, 0.0)\n            float2 outputs:result\n        }\n\n${o.join("\n")}\n\n    }\n`}function buildColor(t){return`(${t.r}, ${t.g}, ${t.b})`}function buildVector2(t){return`(${t.x}, ${t.y})`}function buildCamera(t){const e=t.name?t.name:"Camera_"+t.id,n=buildMatrix(t.matrixWorld);return t.matrixWorld.determinant()<0&&console.warn("THREE.USDZExporter: USDZ does not support negative scales",t),t.isOrthographicCamera?`def Camera "${e}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${n}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\t\n\t\t\tfloat2 clippingRange = (${t.near.toPrecision(7)}, ${t.far.toPrecision(7)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(t.left)+Math.abs(t.right))).toPrecision(7)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(t.top)+Math.abs(t.bottom))).toPrecision(7)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`:`def Camera "${e}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${n}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\t\n\t\t\tfloat2 clippingRange = (${t.near.toPrecision(7)}, ${t.far.toPrecision(7)})\n\t\t\tfloat focalLength = ${t.getFocalLength().toPrecision(7)}\n\t\t\tfloat focusDistance = ${t.focus.toPrecision(7)}\n\t\t\tfloat horizontalAperture = ${t.getFilmWidth().toPrecision(7)}\n\t\t\ttoken projection = "perspective"\n\t\t\tfloat verticalAperture = ${t.getFilmHeight().toPrecision(7)}\n\t\t}\n\t\n\t`}export{USDZExporter};