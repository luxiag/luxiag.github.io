import{Color,DoubleSide,Matrix4,MeshBasicMaterial}from"three";class ColladaExporter{parse(e,t,r={}){if(null===(r=Object.assign({version:"1.4.1",author:null,textureDirectory:"",upAxis:"Y_UP",unitName:null,unitMeter:null},r)).upAxis.match(/^[XYZ]_UP$/))return console.error("ColladaExporter: Invalid upAxis: valid values are X_UP, Y_UP or Z_UP."),null;if(null!==r.unitName&&null===r.unitMeter)return console.error("ColladaExporter: unitMeter needs to be specified if unitName is specified."),null;if(null!==r.unitMeter&&null===r.unitName)return console.error("ColladaExporter: unitName needs to be specified if unitMeter is specified."),null;""!==r.textureDirectory&&(r.textureDirectory=`${r.textureDirectory}/`.replace(/\\/g,"/").replace(/\/+/g,"/"));const a=r.version;if("1.4.1"!==a&&"1.5.0"!==a)return console.warn(`ColladaExporter : Version ${a} not supported for export. Only 1.4.1 and 1.5.0.`),null;let n,i;function o(e,t){if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&e instanceof OffscreenCanvas||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap)return n=n||document.createElement("canvas"),i=i||n.getContext("2d"),n.width=e.width,n.height=e.height,i.drawImage(e,0,0),function(e){const t=atob(e),r=new Uint8Array(t.length);for(let e=0,a=r.length;e<a;e++)r[e]=t.charCodeAt(e);return r}(n.toDataURL(`image/${t}`,1).replace(/^data:image\/(png|jpg);base64,/,""));throw new Error("THREE.ColladaExporter: No valid image data found. Unable to process texture.")}const s=["getX","getY","getZ","getW"],l=new Color;function u(e,t=!1){if(t){const t=new Float32Array(3*e.count);for(let r=0,a=e.count;r<a;r++)l.fromBufferAttribute(e,r).convertLinearToSRGB(),t[3*r+0]=l.r,t[3*r+1]=l.g,t[3*r+2]=l.b;return t}if(e.isInterleavedBufferAttribute){const t=new e.array.constructor(e.count*e.itemSize),r=e.itemSize;for(let a=0,n=e.count;a<n;a++)for(let n=0;n<r;n++)t[a*r+n]=e[s[n]](a);return t}return e.array}function c(e,t,r,a,n=!1){const i=u(e,n);return`<source id="${t}"><float_array id="${t}-array" count="${i.length}">`+i.join(" ")+"</float_array><technique_common>"+`<accessor source="#${t}-array" count="${Math.floor(i.length/e.itemSize)}" stride="${e.itemSize}">`+r.map((e=>`<param name="${e}" type="${a}" />`)).join("")+"</accessor></technique_common></source>"}let m;function f(e){let t=$.get(e);if(void 0===t){t=`image-${h.length+1}`;const n="png",i=e.name||t;let s=`<image id="${t}" name="${i}">`;s+="1.5.0"===a?`<init_from><ref>${r.textureDirectory}${i}.${n}</ref></init_from>`:`<init_from>${r.textureDirectory}${i}.${n}</init_from>`,s+="</image>",h.push(s),$.set(e,t),g.push({directory:r.textureDirectory,name:i,ext:n,data:o(e.image,n),original:e})}return t}const p=new WeakMap,d=new WeakMap,$=new WeakMap,g=[],h=[],_=[],x=[],y=[],b=function e(t){let r=`<node name="${t.name}">`;if(r+=function(e){return e.updateMatrix(),m=m||new Matrix4,m.copy(e.matrix),m.transpose(),`<matrix>${m.toArray().join(" ")}</matrix>`}(t),!0===t.isMesh&&null!==t.geometry){const e=function(e){let t=p.get(e);if(!t){const i=`Mesh${_.length+1}`,o=e.index?e.index.count*e.index.itemSize:e.attributes.position.count,s=null!=e.groups&&0!==e.groups.length?e.groups:[{start:0,count:o,materialIndex:0}];let l=`<geometry id="${i}"${e.name?` name="${e.name}"`:""}><mesh>`;const m=`${i}-position`,f=`${i}-vertices`;l+=c(e.attributes.position,m,["X","Y","Z"],"float"),l+=`<vertices id="${f}"><input semantic="POSITION" source="#${m}" /></vertices>`;let d=`<input semantic="VERTEX" source="#${f}" offset="0" />`;if("normal"in e.attributes){const t=`${i}-normal`;l+=c(e.attributes.normal,t,["X","Y","Z"],"float"),d+=`<input semantic="NORMAL" source="#${t}" offset="0" />`}if("uv"in e.attributes){const t=`${i}-texcoord`;l+=c(e.attributes.uv,t,["S","T"],"float"),d+=`<input semantic="TEXCOORD" source="#${t}" offset="0" set="0" />`}if("uv2"in e.attributes){const t=`${i}-texcoord2`;l+=c(e.attributes.uv2,t,["S","T"],"float"),d+=`<input semantic="TEXCOORD" source="#${t}" offset="0" set="1" />`}if("color"in e.attributes){const t=`${i}-color`;l+=c(e.attributes.color,t,["R","G","B"],"float",!0),d+=`<input semantic="COLOR" source="#${t}" offset="0" />`}let $=null;if(e.index)$=u(e.index);else{$=new Array(o);for(let e=0,t=$.length;e<t;e++)$[e]=e}for(let e=0,t=s.length;e<t;e++){const t=s[e],i=(r=$,a=t.start,n=t.count,Array.isArray(r)?r.slice(a,a+n):new r.constructor(r.buffer,a*r.BYTES_PER_ELEMENT,n)),o=i.length/3;l+=`<triangles material="MESH_MATERIAL_${t.materialIndex}" count="${o}">`,l+=d,l+=`<p>${i.join(" ")}</p>`,l+="</triangles>"}l+="</mesh></geometry>",_.push(l),t={meshid:i,bufferGeometry:e},p.set(e,t)}var r,a,n;return t}(t.geometry),a=e.meshid,n=e.bufferGeometry;let i,o=null;const s=t.material||new MeshBasicMaterial,l=Array.isArray(s)?s:[s];i=n.groups.length>l.length?new Array(n.groups.length):new Array(l.length),o=i.fill().map(((e,t)=>function(e){let t=d.get(e);if(null==t){t=`Mat${x.length+1}`;let r="phong";!0===e.isMeshLambertMaterial?r="lambert":!0===e.isMeshBasicMaterial&&(r="constant",null!==e.map&&console.warn("ColladaExporter: Texture maps not supported with MeshBasicMaterial."));const a=e.emissive?e.emissive:new Color(0,0,0),n=e.color?e.color:new Color(0,0,0),i=e.specular?e.specular:new Color(1,1,1),o=e.shininess||0,s=e.reflectivity||0;a.convertLinearToSRGB(),i.convertLinearToSRGB(),n.convertLinearToSRGB();let l="";!0===e.transparent&&(l+="<transparent>"+(e.map?'<texture texture="diffuse-sampler"></texture>':"<float>1</float>")+"</transparent>",e.opacity<1&&(l+=`<transparency><float>${e.opacity}</float></transparency>`));const u=`<technique sid="common"><${r}><emission>`+(e.emissiveMap?'<texture texture="emissive-sampler" texcoord="TEXCOORD" />':`<color sid="emission">${a.r} ${a.g} ${a.b} 1</color>`)+"</emission>"+("constant"!==r?"<diffuse>"+(e.map?'<texture texture="diffuse-sampler" texcoord="TEXCOORD" />':`<color sid="diffuse">${n.r} ${n.g} ${n.b} 1</color>`)+"</diffuse>":"")+("constant"!==r?"<bump>"+(e.normalMap?'<texture texture="bump-sampler" texcoord="TEXCOORD" />':"")+"</bump>":"")+("phong"===r?`<specular><color sid="specular">${i.r} ${i.g} ${i.b} 1</color></specular><shininess>`+(e.specularMap?'<texture texture="specular-sampler" texcoord="TEXCOORD" />':`<float sid="shininess">${o}</float>`)+"</shininess>":"")+`<reflective><color>${n.r} ${n.g} ${n.b} 1</color></reflective>`+`<reflectivity><float>${s}</float></reflectivity>`+l+`</${r}></technique>`,c=`<effect id="${t}-effect"><profile_COMMON>`+(e.map?`<newparam sid="diffuse-surface"><surface type="2D"><init_from>${f(e.map)}</init_from></surface></newparam><newparam sid="diffuse-sampler"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>`:"")+(e.specularMap?`<newparam sid="specular-surface"><surface type="2D"><init_from>${f(e.specularMap)}</init_from></surface></newparam><newparam sid="specular-sampler"><sampler2D><source>specular-surface</source></sampler2D></newparam>`:"")+(e.emissiveMap?`<newparam sid="emissive-surface"><surface type="2D"><init_from>${f(e.emissiveMap)}</init_from></surface></newparam><newparam sid="emissive-sampler"><sampler2D><source>emissive-surface</source></sampler2D></newparam>`:"")+(e.normalMap?`<newparam sid="bump-surface"><surface type="2D"><init_from>${f(e.normalMap)}</init_from></surface></newparam><newparam sid="bump-sampler"><sampler2D><source>bump-surface</source></sampler2D></newparam>`:"")+u+(e.side===DoubleSide?'<extra><technique profile="THREEJS"><double_sided sid="double_sided" type="int">1</double_sided></technique></extra>':"")+"</profile_COMMON></effect>",m=`<material id="${t}"${e.name?` name="${e.name}"`:""}><instance_effect url="#${t}-effect" /></material>`;y.push(m),x.push(c),d.set(e,t)}return t}(l[t%l.length]))),r+=`<instance_geometry url="#${a}">`+(o.length>0?"<bind_material><technique_common>"+o.map(((e,t)=>`<instance_material symbol="MESH_MATERIAL_${t}" target="#${e}" ><bind_vertex_input semantic="TEXCOORD" input_semantic="TEXCOORD" input_set="0" /></instance_material>`)).join("")+"</technique_common></bind_material>":"")+"</instance_geometry>"}return t.children.forEach((t=>r+=e(t))),r+="</node>",r}(e);let M=`<?xml version="1.0" encoding="UTF-8" standalone="no" ?><COLLADA xmlns="${"1.4.1"===a?"http://www.collada.org/2005/11/COLLADASchema":"https://www.khronos.org/collada/"}" version="${a}"><asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>`+(null!==r.author?`<author>${r.author}</author>`:"")+"</contributor>"+`<created>${(new Date).toISOString()}</created>`+`<modified>${(new Date).toISOString()}</modified>`+(null!==r.unitName?`<unit name="${r.unitName}" meter="${r.unitMeter}" />`:"")+`<up_axis>${r.upAxis}</up_axis></asset>`;M+=`<library_images>${h.join("")}</library_images>`,M+=`<library_effects>${x.join("")}</library_effects>`,M+=`<library_materials>${y.join("")}</library_materials>`,M+=`<library_geometries>${_.join("")}</library_geometries>`,M+=`<library_visual_scenes><visual_scene id="Scene" name="scene">${b}</visual_scene></library_visual_scenes>`,M+='<scene><instance_visual_scene url="#Scene"/></scene>',M+="</COLLADA>";const w={data:function(e){const t=/^<\//,r=/(\?>$)|(\/>$)/,a=/<[^>]+>[^<]*<\/[^<]+>/,n=(e,t)=>t>0?e+n(e,t-1):"";let i=0;return e.match(/(<[^>]+>[^<]+<\/[^<]+>)|(<[^>]+>)/g).map((e=>{a.test(e)||r.test(e)||!t.test(e)||i--;const o=`${n("  ",i)}${e}`;return a.test(e)||r.test(e)||t.test(e)||i++,o})).join("\n")}(M),textures:g};return"function"==typeof t&&requestAnimationFrame((()=>t(w))),w}}export{ColladaExporter};