import{Matrix3,Vector3,Color}from"three";class PLYExporter{parse(t,e,n={}){function i(e){t.traverse((function(t){if(!0===t.isMesh||t.isPoints){const n=t,i=n.geometry;!0===i.hasAttribute("position")&&e(n,i)}}))}const r=(n=Object.assign({binary:!1,excludeAttributes:[],littleEndian:!1},n)).excludeAttributes;let o=!0,l=!1,a=!1,u=!1,s=0,f=0;t.traverse((function(t){if(!0===t.isMesh){const e=t.geometry,n=e.getAttribute("position"),i=e.getAttribute("normal"),r=e.getAttribute("uv"),o=e.getAttribute("color"),c=e.getIndex();if(void 0===n)return;s+=n.count,f+=c?c.count/3:n.count/3,void 0!==i&&(l=!0),void 0!==r&&(u=!0),void 0!==o&&(a=!0)}else if(t.isPoints){const e=t.geometry,n=e.getAttribute("position"),i=e.getAttribute("normal"),r=e.getAttribute("color");s+=n.count,void 0!==i&&(l=!0),void 0!==r&&(a=!0),o=!1}}));const c=new Color;if(o=o&&-1===r.indexOf("index"),l=l&&-1===r.indexOf("normal"),a=a&&-1===r.indexOf("color"),u=u&&-1===r.indexOf("uv"),o&&f!==Math.floor(f))return console.error("PLYExporter: Failed to generate a valid PLY file with triangle indices because the number of indices is not divisible by 3."),null;let d=`ply\nformat ${n.binary?n.littleEndian?"binary_little_endian":"binary_big_endian":"ascii"} 1.0\nelement vertex ${s}\nproperty float x\nproperty float y\nproperty float z\n`;!0===l&&(d+="property float nx\nproperty float ny\nproperty float nz\n"),!0===u&&(d+="property float s\nproperty float t\n"),!0===a&&(d+="property uchar red\nproperty uchar green\nproperty uchar blue\n"),!0===o&&(d+=`element face ${f}\nproperty list uchar int vertex_index\n`),d+="end_header\n";const p=new Vector3,g=new Matrix3;let b=null;if(!0===n.binary){const t=(new TextEncoder).encode(d),e=s*(12+(l?12:0)+(a?3:0)+(u?8:0)),r=o?13*f:0,x=new DataView(new ArrayBuffer(t.length+e+r));new Uint8Array(x.buffer).set(t,0);let y=t.length,m=t.length+e,A=0;i((function(t,e){const i=e.getAttribute("position"),r=e.getAttribute("normal"),s=e.getAttribute("uv"),f=e.getAttribute("color"),d=e.getIndex();g.getNormalMatrix(t.matrixWorld);for(let e=0,o=i.count;e<o;e++)p.fromBufferAttribute(i,e),p.applyMatrix4(t.matrixWorld),x.setFloat32(y,p.x,n.littleEndian),y+=4,x.setFloat32(y,p.y,n.littleEndian),y+=4,x.setFloat32(y,p.z,n.littleEndian),y+=4,!0===l&&(null!=r?(p.fromBufferAttribute(r,e),p.applyMatrix3(g).normalize(),x.setFloat32(y,p.x,n.littleEndian),y+=4,x.setFloat32(y,p.y,n.littleEndian),y+=4,x.setFloat32(y,p.z,n.littleEndian),y+=4):(x.setFloat32(y,0,n.littleEndian),y+=4,x.setFloat32(y,0,n.littleEndian),y+=4,x.setFloat32(y,0,n.littleEndian),y+=4)),!0===u&&(null!=s?(x.setFloat32(y,s.getX(e),n.littleEndian),y+=4,x.setFloat32(y,s.getY(e),n.littleEndian),y+=4):(x.setFloat32(y,0,n.littleEndian),y+=4,x.setFloat32(y,0,n.littleEndian),y+=4)),!0===a&&(null!=f?(c.fromBufferAttribute(f,e).convertLinearToSRGB(),x.setUint8(y,Math.floor(255*c.r)),y+=1,x.setUint8(y,Math.floor(255*c.g)),y+=1,x.setUint8(y,Math.floor(255*c.b)),y+=1):(x.setUint8(y,255),y+=1,x.setUint8(y,255),y+=1,x.setUint8(y,255),y+=1));if(!0===o)if(null!==d)for(let t=0,e=d.count;t<e;t+=3)x.setUint8(m,3),m+=1,x.setUint32(m,d.getX(t+0)+A,n.littleEndian),m+=4,x.setUint32(m,d.getX(t+1)+A,n.littleEndian),m+=4,x.setUint32(m,d.getX(t+2)+A,n.littleEndian),m+=4;else for(let t=0,e=i.count;t<e;t+=3)x.setUint8(m,3),m+=1,x.setUint32(m,A+t,n.littleEndian),m+=4,x.setUint32(m,A+t+1,n.littleEndian),m+=4,x.setUint32(m,A+t+2,n.littleEndian),m+=4;A+=i.count})),b=x.buffer}else{let t=0,e="",n="";i((function(i,r){const s=r.getAttribute("position"),d=r.getAttribute("normal"),b=r.getAttribute("uv"),x=r.getAttribute("color"),y=r.getIndex();g.getNormalMatrix(i.matrixWorld);for(let t=0,n=s.count;t<n;t++){p.fromBufferAttribute(s,t),p.applyMatrix4(i.matrixWorld);let n=p.x+" "+p.y+" "+p.z;!0===l&&(null!=d?(p.fromBufferAttribute(d,t),p.applyMatrix3(g).normalize(),n+=" "+p.x+" "+p.y+" "+p.z):n+=" 0 0 0"),!0===u&&(n+=null!=b?" "+b.getX(t)+" "+b.getY(t):" 0 0"),!0===a&&(null!=x?(c.fromBufferAttribute(x,t).convertLinearToSRGB(),n+=" "+Math.floor(255*c.r)+" "+Math.floor(255*c.g)+" "+Math.floor(255*c.b)):n+=" 255 255 255"),e+=n+"\n"}if(!0===o){if(null!==y)for(let e=0,i=y.count;e<i;e+=3)n+=`3 ${y.getX(e+0)+t}`,n+=` ${y.getX(e+1)+t}`,n+=` ${y.getX(e+2)+t}\n`;else for(let e=0,i=s.count;e<i;e+=3)n+=`3 ${t+e} ${t+e+1} ${t+e+2}\n`;f+=y?y.count/3:s.count/3}t+=s.count})),b=`${d}${e}${o?`${n}\n`:"\n"}`}return"function"==typeof e&&requestAnimationFrame((()=>e(b))),b}}export{PLYExporter};