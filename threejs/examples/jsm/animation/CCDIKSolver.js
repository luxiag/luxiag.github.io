import{BufferAttribute,BufferGeometry,Color,Line,LineBasicMaterial,Matrix4,Mesh,MeshBasicMaterial,Object3D,Quaternion,SphereGeometry,Vector3}from"three";const _q=new Quaternion,_targetPos=new Vector3,_targetVec=new Vector3,_effectorPos=new Vector3,_effectorVec=new Vector3,_linkPos=new Vector3,_invLinkQ=new Quaternion,_linkScale=new Vector3,_axis=new Vector3,_vector=new Vector3,_matrix=new Matrix4;class CCDIKSolver{constructor(e,t=[]){this.mesh=e,this.iks=t,this._valid()}update(){const e=this.iks;for(let t=0,i=e.length;t<i;t++)this.updateOne(e[t]);return this}updateOne(e){const t=this.mesh.skeleton.bones,i=Math,r=t[e.effector],o=t[e.target];_targetPos.setFromMatrixPosition(o.matrixWorld);const n=e.links,s=void 0!==e.iteration?e.iteration:1;for(let o=0;o<s;o++){let o=!1;for(let s=0,a=n.length;s<a;s++){const a=t[n[s].index];if(!1===n[s].enabled)break;const l=n[s].limitation,c=n[s].rotationMin,h=n[s].rotationMax;a.matrixWorld.decompose(_linkPos,_invLinkQ,_linkScale),_invLinkQ.invert(),_effectorPos.setFromMatrixPosition(r.matrixWorld),_effectorVec.subVectors(_effectorPos,_linkPos),_effectorVec.applyQuaternion(_invLinkQ),_effectorVec.normalize(),_targetVec.subVectors(_targetPos,_linkPos),_targetVec.applyQuaternion(_invLinkQ),_targetVec.normalize();let p=_targetVec.dot(_effectorVec);if(p>1?p=1:p<-1&&(p=-1),p=i.acos(p),!(p<1e-5)){if(void 0!==e.minAngle&&p<e.minAngle&&(p=e.minAngle),void 0!==e.maxAngle&&p>e.maxAngle&&(p=e.maxAngle),_axis.crossVectors(_effectorVec,_targetVec),_axis.normalize(),_q.setFromAxisAngle(_axis,p),a.quaternion.multiply(_q),void 0!==l){let e=a.quaternion.w;e>1&&(e=1);const t=i.sqrt(1-e*e);a.quaternion.set(l.x*t,l.y*t,l.z*t,e)}void 0!==c&&a.rotation.setFromVector3(_vector.setFromEuler(a.rotation).max(c)),void 0!==h&&a.rotation.setFromVector3(_vector.setFromEuler(a.rotation).min(h)),a.updateMatrixWorld(!0),o=!0}}if(!o)break}return this}createHelper(){return new CCDIKHelper(this.mesh,this.iks)}_valid(){const e=this.iks,t=this.mesh.skeleton.bones;for(let i=0,r=e.length;i<r;i++){const r=e[i],o=t[r.effector],n=r.links;let s,a;s=o;for(let e=0,i=n.length;e<i;e++)a=t[n[e].index],s.parent!==a&&console.warn("THREE.CCDIKSolver: bone "+s.name+" is not the child of bone "+a.name),s=a}}}function getPosition(e,t){return _vector.setFromMatrixPosition(e.matrixWorld).applyMatrix4(t)}function setPositionOfBoneToAttributeArray(e,t,i,r){const o=getPosition(i,r);e[3*t+0]=o.x,e[3*t+1]=o.y,e[3*t+2]=o.z}class CCDIKHelper extends Object3D{constructor(e,t=[],i=.25){super(),this.root=e,this.iks=t,this.matrix.copy(e.matrixWorld),this.matrixAutoUpdate=!1,this.sphereGeometry=new SphereGeometry(i,16,8),this.targetSphereMaterial=new MeshBasicMaterial({color:new Color(16746632),depthTest:!1,depthWrite:!1,transparent:!0}),this.effectorSphereMaterial=new MeshBasicMaterial({color:new Color(8978312),depthTest:!1,depthWrite:!1,transparent:!0}),this.linkSphereMaterial=new MeshBasicMaterial({color:new Color(8947967),depthTest:!1,depthWrite:!1,transparent:!0}),this.lineMaterial=new LineBasicMaterial({color:new Color(16711680),depthTest:!1,depthWrite:!1,transparent:!0}),this._init()}updateMatrixWorld(e){const t=this.root;if(this.visible){let e=0;const i=this.iks,r=t.skeleton.bones;_matrix.copy(t.matrixWorld).invert();for(let t=0,o=i.length;t<o;t++){const o=i[t],n=r[o.target],s=r[o.effector],a=this.children[e++],l=this.children[e++];a.position.copy(getPosition(n,_matrix)),l.position.copy(getPosition(s,_matrix));for(let t=0,i=o.links.length;t<i;t++){const i=r[o.links[t].index];this.children[e++].position.copy(getPosition(i,_matrix))}const c=this.children[e++],h=c.geometry.attributes.position.array;setPositionOfBoneToAttributeArray(h,0,n,_matrix),setPositionOfBoneToAttributeArray(h,1,s,_matrix);for(let e=0,t=o.links.length;e<t;e++)setPositionOfBoneToAttributeArray(h,e+2,r[o.links[e].index],_matrix);c.geometry.attributes.position.needsUpdate=!0}}this.matrix.copy(t.matrixWorld),super.updateMatrixWorld(e)}dispose(){this.sphereGeometry.dispose(),this.targetSphereMaterial.dispose(),this.effectorSphereMaterial.dispose(),this.linkSphereMaterial.dispose(),this.lineMaterial.dispose();const e=this.children;for(let t=0;t<e.length;t++){const i=e[t];i.isLine&&i.geometry.dispose()}}_init(){const e=this,t=this.iks;function i(t){return new Line(function(e){const t=new BufferGeometry,i=new Float32Array(3*(2+e.links.length));return t.setAttribute("position",new BufferAttribute(i,3)),t}(t),e.lineMaterial)}for(let r=0,o=t.length;r<o;r++){const o=t[r];this.add(new Mesh(e.sphereGeometry,e.targetSphereMaterial)),this.add(new Mesh(e.sphereGeometry,e.effectorSphereMaterial));for(let t=0,i=o.links.length;t<i;t++)this.add(new Mesh(e.sphereGeometry,e.linkSphereMaterial));this.add(i(o))}}}export{CCDIKSolver,CCDIKHelper};