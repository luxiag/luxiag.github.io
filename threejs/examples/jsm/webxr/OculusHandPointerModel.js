import*as THREE from"three";const PINCH_MAX=.05,PINCH_THRESHOLD=.02,PINCH_MIN=.01,POINTER_ADVANCE_MAX=.02,POINTER_OPACITY_MAX=1,POINTER_OPACITY_MIN=.4,POINTER_FRONT_RADIUS=.002,POINTER_REAR_RADIUS=.01,POINTER_REAR_RADIUS_MIN=.003,POINTER_LENGTH=.035,POINTER_SEGMENTS=16,POINTER_RINGS=12,POINTER_HEMISPHERE_ANGLE=110,YAXIS=new THREE.Vector3(0,1,0),ZAXIS=new THREE.Vector3(0,0,1),CURSOR_RADIUS=.02,CURSOR_MAX_DISTANCE=1.5;class OculusHandPointerModel extends THREE.Object3D{constructor(t,e){super(),this.hand=t,this.controller=e,this.motionController=null,this.envMap=null,this.mesh=null,this.pointerGeometry=null,this.pointerMesh=null,this.pointerObject=null,this.pinched=!1,this.attached=!1,this.cursorObject=null,this.raycaster=null,t.addEventListener("connected",(t=>{const e=t.data;e.hand&&(this.visible=!0,this.xrInputSource=e,null===this.pointerObject&&this.createPointer())}))}_drawVerticesRing(t,e,i){const s=e.clone();for(let e=0;e<16;e++){s.applyAxisAngle(ZAXIS,2*Math.PI/16);const r=16*i+e;t[3*r]=s.x,t[3*r+1]=s.y,t[3*r+2]=s.z}}_updatePointerVertices(t){const e=this.pointerGeometry.attributes.position.array,i=new THREE.Vector3(.002,0,-1*(.035-t));this._drawVerticesRing(e,i,0);const s=new THREE.Vector3(Math.sin(110*Math.PI/180)*t,Math.cos(110*Math.PI/180)*t,0);for(let t=0;t<12;t++)this._drawVerticesRing(e,s,t+1),s.applyAxisAngle(YAXIS,110*Math.PI/180/-24);const r=new THREE.Vector3(0,0,-1*(.035-t));e[624]=r.x,e[625]=r.y,e[626]=r.z;const o=new THREE.Vector3(0,0,t);e[627]=o.x,e[628]=o.y,e[629]=o.z,this.pointerGeometry.setAttribute("position",new THREE.Float32BufferAttribute(e,3))}createPointer(){let t,e;const i=new Array(630).fill(0),s=[];for(this.pointerGeometry=new THREE.BufferGeometry,this.pointerGeometry.setAttribute("position",new THREE.Float32BufferAttribute(i,3)),this._updatePointerVertices(.01),t=0;t<12;t++){for(e=0;e<15;e++)s.push(16*t+e,16*t+e+1,16*(t+1)+e),s.push(16*t+e+1,16*(t+1)+e+1,16*(t+1)+e);s.push(16*(t+1)-1,16*t,16*(t+2)-1),s.push(16*t,16*(t+1),16*(t+2)-1)}for(t=0;t<15;t++)s.push(208,t+1,t),s.push(209,t+192,t+192+1);s.push(208,0,15),s.push(209,207,192);const r=new THREE.MeshBasicMaterial;r.transparent=!0,r.opacity=.4,this.pointerGeometry.setIndex(s),this.pointerMesh=new THREE.Mesh(this.pointerGeometry,r),this.pointerMesh.position.set(0,0,-.01),this.pointerObject=new THREE.Object3D,this.pointerObject.add(this.pointerMesh),this.raycaster=new THREE.Raycaster;const o=new THREE.SphereGeometry(.02,10,10),n=new THREE.MeshBasicMaterial;n.transparent=!0,n.opacity=.4,this.cursorObject=new THREE.Mesh(o,n),this.pointerObject.add(this.cursorObject),this.add(this.pointerObject)}_updateRaycaster(){if(this.raycaster){const t=this.pointerObject.matrixWorld,e=new THREE.Matrix4;e.identity().extractRotation(t),this.raycaster.ray.origin.setFromMatrixPosition(t),this.raycaster.ray.direction.set(0,0,-1).applyMatrix4(e)}}_updatePointer(){this.pointerObject.visible=this.controller.visible;const t=this.hand.joints["index-finger-tip"],e=this.hand.joints["thumb-tip"],i=t.position.distanceTo(e.position),s=t.position.clone().add(e.position).multiplyScalar(.5);this.pointerObject.position.copy(s),this.pointerObject.quaternion.copy(this.controller.quaternion),this.pinched=i<=.02;const r=(i-.01)/.04,o=(i-.01)/.01;if(r>1)this._updatePointerVertices(.01),this.pointerMesh.position.set(0,0,-.01),this.pointerMesh.material.opacity=.4;else if(r>0){const t=.007*r+.003;this._updatePointerVertices(t),o<1?(this.pointerMesh.position.set(0,0,-1*t-.02*(1-o)),this.pointerMesh.material.opacity=.4+.6*(1-o)):(this.pointerMesh.position.set(0,0,-1*t),this.pointerMesh.material.opacity=.4)}else this._updatePointerVertices(.003),this.pointerMesh.position.set(0,0,-.023),this.pointerMesh.material.opacity=1;this.cursorObject.material.opacity=this.pointerMesh.material.opacity}updateMatrixWorld(t){super.updateMatrixWorld(t),this.pointerGeometry&&(this._updatePointer(),this._updateRaycaster())}isPinched(){return this.pinched}setAttached(t){this.attached=t}isAttached(){return this.attached}intersectObject(t,e=!0){if(this.raycaster)return this.raycaster.intersectObject(t,e)}intersectObjects(t,e=!0){if(this.raycaster)return this.raycaster.intersectObjects(t,e)}checkIntersections(t,e=!1){if(this.raycaster&&!this.attached){const i=this.raycaster.intersectObjects(t,e),s=new THREE.Vector3(0,0,-1);if(i.length>0){const t=i[0].distance;this.cursorObject.position.copy(s.multiplyScalar(t))}else this.cursorObject.position.copy(s.multiplyScalar(1.5))}}setCursor(t){const e=new THREE.Vector3(0,0,-1);this.raycaster&&!this.attached&&this.cursorObject.position.copy(e.multiplyScalar(t))}}export{OculusHandPointerModel};