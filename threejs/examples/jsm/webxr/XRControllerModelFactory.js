import{Mesh,MeshBasicMaterial,Object3D,SphereGeometry}from"three";import{GLTFLoader}from"../loaders/GLTFLoader.js";import{Constants as MotionControllerConstants,fetchProfile,MotionController}from"../libs/motion-controllers.module.js";const DEFAULT_PROFILES_PATH="https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles",DEFAULT_PROFILE="generic-trigger";class XRControllerModel extends Object3D{constructor(){super(),this.motionController=null,this.envMap=null}setEnvironmentMap(e){return this.envMap==e||(this.envMap=e,this.traverse((e=>{e.isMesh&&(e.material.envMap=this.envMap,e.material.needsUpdate=!0)}))),this}updateMatrixWorld(e){super.updateMatrixWorld(e),this.motionController&&(this.motionController.updateFromGamepad(),Object.values(this.motionController.components).forEach((e=>{Object.values(e.visualResponses).forEach((e=>{const{valueNode:o,minNode:t,maxNode:n,value:r,valueNodeProperty:s}=e;o&&(s===MotionControllerConstants.VisualResponseProperty.VISIBILITY?o.visible=r:s===MotionControllerConstants.VisualResponseProperty.TRANSFORM&&(o.quaternion.slerpQuaternions(t.quaternion,n.quaternion,r),o.position.lerpVectors(t.position,n.position,r)))}))})))}}function findNodes(e,o){Object.values(e.components).forEach((e=>{const{type:t,touchPointNodeName:n,visualResponses:r}=e;if(t===MotionControllerConstants.ComponentType.TOUCHPAD)if(e.touchPointNode=o.getObjectByName(n),e.touchPointNode){const o=new SphereGeometry(.001),t=new MeshBasicMaterial({color:255}),n=new Mesh(o,t);e.touchPointNode.add(n)}else console.warn(`Could not find touch dot, ${e.touchPointNodeName}, in touchpad component ${e.id}`);Object.values(r).forEach((e=>{const{valueNodeName:t,minNodeName:n,maxNodeName:r,valueNodeProperty:s}=e;if(s===MotionControllerConstants.VisualResponseProperty.TRANSFORM){if(e.minNode=o.getObjectByName(n),e.maxNode=o.getObjectByName(r),!e.minNode)return void console.warn(`Could not find ${n} in the model`);if(!e.maxNode)return void console.warn(`Could not find ${r} in the model`)}e.valueNode=o.getObjectByName(t),e.valueNode||console.warn(`Could not find ${t} in the model`)}))}))}function addAssetSceneToControllerModel(e,o){findNodes(e.motionController,o),e.envMap&&o.traverse((o=>{o.isMesh&&(o.material.envMap=e.envMap,o.material.needsUpdate=!0)})),e.add(o)}class XRControllerModelFactory{constructor(e=null){this.gltfLoader=e,this.path=DEFAULT_PROFILES_PATH,this._assetCache={},this.gltfLoader||(this.gltfLoader=new GLTFLoader)}createControllerModel(e){const o=new XRControllerModel;let t=null;return e.addEventListener("connected",(e=>{const n=e.data;"tracked-pointer"===n.targetRayMode&&n.gamepad&&fetchProfile(n,this.path,DEFAULT_PROFILE).then((({profile:e,assetPath:r})=>{o.motionController=new MotionController(n,e,r);const s=this._assetCache[o.motionController.assetUrl];if(s)t=s.scene.clone(),addAssetSceneToControllerModel(o,t);else{if(!this.gltfLoader)throw new Error("GLTFLoader not set.");this.gltfLoader.setPath(""),this.gltfLoader.load(o.motionController.assetUrl,(e=>{this._assetCache[o.motionController.assetUrl]=e,t=e.scene.clone(),addAssetSceneToControllerModel(o,t)}),null,(()=>{throw new Error(`Asset ${o.motionController.assetUrl} missing or malformed.`)}))}})).catch((e=>{console.warn(e)}))})),e.addEventListener("disconnected",(()=>{o.motionController=null,o.remove(t),t=null})),o}}export{XRControllerModelFactory};