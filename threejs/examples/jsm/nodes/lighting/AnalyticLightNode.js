import LightingNode from"./LightingNode.js";import{NodeUpdateType}from"../core/constants.js";import{uniform}from"../core/UniformNode.js";import{addNodeClass}from"../core/Node.js";import{vec3}from"../shadernode/ShaderNode.js";import{reference}from"../accessors/ReferenceNode.js";import{texture}from"../accessors/TextureNode.js";import{positionWorld}from"../accessors/PositionNode.js";import{cond}from"../math/CondNode.js";import MeshBasicNodeMaterial from"../materials/MeshBasicNodeMaterial.js";import{Color,DepthTexture,NearestFilter}from"three";let depthMaterial=null;class AnalyticLightNode extends LightingNode{constructor(e=null){super(),this.updateType=NodeUpdateType.FRAME,this.light=e,this.rtt=null,this.shadowNode=null,this.color=new Color,this.colorNode=uniform(this.color)}getHash(){return this.light.uuid}constructShadow(e){let t=this.shadowNode;if(null===t){null===depthMaterial&&(depthMaterial=new MeshBasicNodeMaterial);const o=this.light.shadow,r=e.getRenderTarget(o.mapSize.width,o.mapSize.height),i=new DepthTexture;i.minFilter=NearestFilter,i.magFilter=NearestFilter,r.depthTexture=i,o.camera.updateProjectionMatrix();const s=reference("bias","float",o);let a=uniform(o.matrix).mul(positionWorld);a=a.xyz.div(a.w),a=vec3(a.x,a.y.oneMinus(),a.z);let d=texture(i,a.xy);d=d.mul(.5).add(.5).add(s),t=cond(a.z.lessThan(d).or(a.y.lessThan(1e-6)),1,0),this.rtt=r,this.colorNode=this.colorNode.mul(t),this.shadowNode=t,this.updateBeforeType=NodeUpdateType.RENDER}}construct(e){this.light.castShadow&&this.constructShadow(e)}updateShadow(e){const{rtt:t,light:o}=this,{renderer:r,scene:i}=e;i.overrideMaterial=depthMaterial,t.setSize(o.shadow.mapSize.width,o.shadow.mapSize.height),o.shadow.updateMatrices(o),r.setRenderTarget(t),r.render(i,o.shadow.camera),r.setRenderTarget(null),i.overrideMaterial=null}updateBefore(e){const{light:t}=this;t.castShadow&&this.updateShadow(e)}update(e){const{light:t}=this;this.color.copy(t.color).multiplyScalar(t.intensity)}}export default AnalyticLightNode;addNodeClass(AnalyticLightNode);