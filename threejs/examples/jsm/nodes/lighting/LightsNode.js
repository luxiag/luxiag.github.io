import Node from"../core/Node.js";import AnalyticLightNode from"./AnalyticLightNode.js";import{nodeObject,nodeProxy}from"../shadernode/ShaderNode.js";const LightNodes=new WeakMap,sortLights=t=>t.sort(((t,o)=>t.id-o.id));class LightsNode extends Node{constructor(t=[]){super("vec3"),this.lightNodes=t,this._hash=null}get hasLight(){return this.lightNodes.length>0}construct(t){const o=this.lightNodes;for(const s of o)s.build(t)}getHash(t){if(null===this._hash){let o="";const s=this.lightNodes;for(const e of s)o+=e.getHash(t)+" ";this._hash=o}return this._hash}getLightNodeByHash(t){const o=this.lightNodes;for(const s of o)if(s.light.uuid===t)return s;return null}fromLights(t=[]){const o=[];t=sortLights(t);for(const s of t){let t=this.getLightNodeByHash(s.uuid);if(null===t){const o=s.constructor,e=LightNodes.has(o)?LightNodes.get(o):AnalyticLightNode;t=nodeObject(new e(s))}o.push(t)}return this.lightNodes=o,this._hash=null,this}}export default LightsNode;export const lights=t=>nodeObject((new LightsNode).fromLights(t));export const lightsWithoutWrap=nodeProxy(LightsNode);export function addLightNode(t,o){if(LightNodes.has(t))throw new Error(`Redefinition of light node ${o.name}`);if("function"!=typeof t||!t.name)throw new Error(`Light ${t.name} is not a class`);if("function"!=typeof o||!o.name)throw new Error(`Light node ${o.name} is not a class`);LightNodes.set(t,o)}