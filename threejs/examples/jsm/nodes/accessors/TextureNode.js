import UniformNode from"../core/UniformNode.js";import{uv}from"./UVNode.js";import{addNodeClass}from"../core/Node.js";import{addNodeElement,nodeProxy}from"../shadernode/ShaderNode.js";let defaultUV;class TextureNode extends UniformNode{constructor(e,t=null,r=null){super(e),this.isTextureNode=!0,this.uvNode=t,this.levelNode=r}getUniformHash(){return this.value.uuid}getNodeType(){return!0===this.value.isDepthTexture?"float":"vec4"}getInputType(){return"texture"}getDefaultUV(){return defaultUV||(defaultUV=uv())}construct(e){const t=e.getNodeProperties(this);let r=this.uvNode;null===r&&e.context.getUVNode&&(r=e.context.getUVNode(this)),r||(r=this.getDefaultUV());let o=this.levelNode;null===o&&e.context.getSamplerLevelNode&&(o=e.context.getSamplerLevelNode(this)),t.uvNode=r,t.levelNode=o?e.context.getMIPLevelAlgorithmNode(this,o):null}generate(e,t){const{uvNode:r,levelNode:o}=e.getNodeProperties(this),d=this.value;if(!d||!0!==d.isTexture)throw new Error("TextureNode: Need a three.js texture.");const s=super.generate(e,"property");if("sampler"===t)return s+"_sampler";if(e.isReference(t))return s;{const l=this.getNodeType(e),u=e.getDataFromNode(this);let i=u.propertyName;if(void 0===i){const t=r.build(e,"vec2"),a=e.getVarFromNode(this,l);i=e.getPropertyName(a);let n=null;if(o&&!0===o.isNode){const r=o.build(e,"float");n=e.getTextureLevel(d,s,t,r)}else n=e.getTexture(d,s,t);e.addLineFlowCode(`${i} = ${n}`),u.snippet=n,u.propertyName=i}return e.format(i,l,t)}}serialize(e){super.serialize(e),e.value=this.value.toJSON(e.meta).uuid}deserialize(e){super.deserialize(e),this.value=e.meta.textures[e.value]}}export default TextureNode;export const texture=nodeProxy(TextureNode);export const sampler=e=>(!0===e.isNode?e:texture(e)).convert("sampler");addNodeElement("texture",texture),addNodeClass(TextureNode);