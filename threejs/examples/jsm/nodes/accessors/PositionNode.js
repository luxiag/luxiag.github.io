import Node,{addNodeClass}from"../core/Node.js";import{attribute}from"../core/AttributeNode.js";import{varying}from"../core/VaryingNode.js";import{normalize}from"../math/MathNode.js";import{modelWorldMatrix,modelViewMatrix}from"./ModelNode.js";import{nodeImmutable}from"../shadernode/ShaderNode.js";class PositionNode extends Node{constructor(o=PositionNode.LOCAL){super("vec3"),this.scope=o}isGlobal(){return!0}getHash(){return`position-${this.scope}`}generate(o){const i=this.scope;let e=null;if(i===PositionNode.GEOMETRY)e=attribute("position","vec3");else if(i===PositionNode.LOCAL)e=varying(positionGeometry);else if(i===PositionNode.WORLD){const o=modelWorldMatrix.mul(positionLocal);e=varying(o)}else if(i===PositionNode.VIEW){const o=modelViewMatrix.mul(positionLocal);e=varying(o)}else if(i===PositionNode.VIEW_DIRECTION){const o=positionView.negate();e=normalize(varying(o))}else if(i===PositionNode.WORLD_DIRECTION){const o=positionLocal.transformDirection(modelWorldMatrix);e=normalize(varying(o))}return e.build(o,this.getNodeType(o))}serialize(o){super.serialize(o),o.scope=this.scope}deserialize(o){super.deserialize(o),this.scope=o.scope}}PositionNode.GEOMETRY="geometry",PositionNode.LOCAL="local",PositionNode.WORLD="world",PositionNode.WORLD_DIRECTION="worldDirection",PositionNode.VIEW="view",PositionNode.VIEW_DIRECTION="viewDirection";export default PositionNode;export const positionGeometry=nodeImmutable(PositionNode,PositionNode.GEOMETRY);export const positionLocal=nodeImmutable(PositionNode,PositionNode.LOCAL);export const positionWorld=nodeImmutable(PositionNode,PositionNode.WORLD);export const positionWorldDirection=nodeImmutable(PositionNode,PositionNode.WORLD_DIRECTION);export const positionView=nodeImmutable(PositionNode,PositionNode.VIEW);export const positionViewDirection=nodeImmutable(PositionNode,PositionNode.VIEW_DIRECTION);addNodeClass(PositionNode);