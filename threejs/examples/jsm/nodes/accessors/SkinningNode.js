import Node,{addNodeClass}from"../core/Node.js";import{NodeUpdateType}from"../core/constants.js";import{ShaderNode,nodeProxy}from"../shadernode/ShaderNode.js";import{attribute}from"../core/AttributeNode.js";import{uniform}from"../core/UniformNode.js";import{add}from"../math/OperatorNode.js";import{buffer}from"./BufferNode.js";import{normalLocal}from"./NormalNode.js";import{positionLocal}from"./PositionNode.js";import{tangentLocal}from"./TangentNode.js";const Skinning=new ShaderNode(((e,{},o)=>{const{index:t,weight:i,bindMatrix:n,bindMatrixInverse:r,boneMatrices:d}=e,s=d.element(t.x),a=d.element(t.y),m=d.element(t.z),l=d.element(t.w),u=n.mul(positionLocal),N=add(s.mul(u).mul(i.x),a.mul(u).mul(i.y),m.mul(u).mul(i.z),l.mul(u).mul(i.w)),c=r.mul(N).xyz;let h=add(i.x.mul(s),i.y.mul(a),i.z.mul(m),i.w.mul(l));h=r.mul(h).mul(n);const b=h.transformDirection(normalLocal).xyz;positionLocal.assign(c).build(o),normalLocal.assign(b).build(o),o.hasGeometryAttribute("tangent")&&tangentLocal.assign(b).build(o)}));class SkinningNode extends Node{constructor(e){super("void"),this.skinnedMesh=e,this.updateType=NodeUpdateType.OBJECT,this.skinIndexNode=attribute("skinIndex","uvec4"),this.skinWeightNode=attribute("skinWeight","vec4"),this.bindMatrixNode=uniform(e.bindMatrix,"mat4"),this.bindMatrixInverseNode=uniform(e.bindMatrixInverse,"mat4"),this.boneMatricesNode=buffer(e.skeleton.boneMatrices,"mat4",e.skeleton.bones.length)}generate(e){Skinning.call({index:this.skinIndexNode,weight:this.skinWeightNode,bindMatrix:this.bindMatrixNode,bindMatrixInverse:this.bindMatrixInverseNode,boneMatrices:this.boneMatricesNode},{},e)}update(){this.skinnedMesh.skeleton.update()}}export default SkinningNode;export const skinning=nodeProxy(SkinningNode);addNodeClass(SkinningNode);