import Node,{addNodeClass}from"../core/Node.js";import ArrayElementNode from"../utils/ArrayElementNode.js";import ConvertNode from"../utils/ConvertNode.js";import JoinNode from"../utils/JoinNode.js";import SplitNode from"../utils/SplitNode.js";import ConstNode from"../core/ConstNode.js";import{getValueFromType,getValueType}from"../core/NodeUtils.js";const NodeElements=new Map;export function addNodeElement(e,t){if(NodeElements.has(e))throw new Error(`Redefinition of node element ${e}`);if("function"!=typeof t)throw new Error(`Node element ${e} is not a function`);NodeElements.set(e,t)}const shaderNodeHandler={construct(e,t){const o=t.shift();return e(nodeObjects(o),...t)},get:function(e,t,o){if("string"==typeof t&&void 0===e[t]){if(NodeElements.has(t)){const e=NodeElements.get(t);return(...t)=>e(o,...t)}if(t.endsWith("Assign")&&NodeElements.has(t.slice(0,t.length-"Assign".length))){const e=NodeElements.get(t.slice(0,t.length-"Assign".length));return(...t)=>o.assign(e(o,...t))}if(!0===/^[xyzwrgbastpq]{1,4}$/.test(t))return t=t.replace(/r|s/g,"x").replace(/g|t/g,"y").replace(/b|p/g,"z").replace(/a|q/g,"w"),nodeObject(new SplitNode(e,t));if("width"===t||"height"===t)return nodeObject(new SplitNode(e,"width"===t?"x":"y"));if(!0===/^\d+$/.test(t))return nodeObject(new ArrayElementNode(e,new ConstNode(Number(t),"uint")))}return e[t]}},nodeObjectsCacheMap=new WeakMap,ShaderNodeObject=function(e){const t=getValueType(e);if("node"===t){let t=nodeObjectsCacheMap.get(e);return void 0===t&&(t=new Proxy(e,shaderNodeHandler),nodeObjectsCacheMap.set(e,t),nodeObjectsCacheMap.set(t,t)),t}return"float"===t||"boolean"===t?nodeObject(getAutoTypedConstNode(e)):t&&"string"!==t?nodeObject(new ConstNode(e)):e},ShaderNodeObjects=function(e){for(const t in e)e[t]=nodeObject(e[t]);return e},ShaderNodeArray=function(e){const t=e.length;for(let o=0;o<t;o++)e[o]=nodeObject(e[o]);return e},ShaderNodeProxy=function(e,t=null,o=null,n=null){const d=e=>nodeObject(null!==n?Object.assign(e,n):e);return null===t?(...t)=>d(new e(...nodeArray(t))):null!==o?(o=nodeObject(o),(...n)=>d(new e(t,...nodeArray(n),o))):(...o)=>d(new e(t,...nodeArray(o)))},ShaderNodeImmutable=function(e,...t){return nodeObject(new e(...nodeArray(t)))};class ShaderNodeInternal extends Node{constructor(e){super(),this._jsFunc=e}call(e,t,o){return e=nodeObjects(e),nodeObject(this._jsFunc(e,t,o))}getNodeType(e){const{outputNode:t}=e.getNodeProperties(this);return t?t.getNodeType(e):super.getNodeType(e)}construct(e){return e.addStack(),e.stack.outputNode=nodeObject(this._jsFunc(e.stack,e)),e.removeStack()}}const bools=[!1,!0],uints=[0,1,2,3],ints=[-1,-2],floats=[.5,1.5,1/3,1e-6,1e6,Math.PI,2*Math.PI,1/Math.PI,2/Math.PI,1/(2*Math.PI),Math.PI/2],boolsCacheMap=new Map;for(const e of bools)boolsCacheMap.set(e,new ConstNode(e));const uintsCacheMap=new Map;for(const t of uints)uintsCacheMap.set(t,new ConstNode(t,"uint"));const intsCacheMap=new Map([...uintsCacheMap].map((e=>new ConstNode(e.value,"int"))));for(const o of ints)intsCacheMap.set(o,new ConstNode(o,"int"));const floatsCacheMap=new Map([...intsCacheMap].map((e=>new ConstNode(e.value))));for(const n of floats)floatsCacheMap.set(n,new ConstNode(n));for(const d of floats)floatsCacheMap.set(-d,new ConstNode(-d));const cacheMaps={bool:boolsCacheMap,uint:uintsCacheMap,ints:intsCacheMap,float:floatsCacheMap},constNodesCacheMap=new Map([...boolsCacheMap,...floatsCacheMap]),getAutoTypedConstNode=e=>constNodesCacheMap.has(e)?constNodesCacheMap.get(e):!0===e.isNode?e:new ConstNode(e),ConvertType=function(e,t=null){return(...o)=>{if(0===o.length)return nodeObject(new ConstNode(getValueFromType(e),e));{if("color"===e&&!0!==o[0].isNode&&(o=[getValueFromType(e,...o)]),1===o.length&&null!==t&&t.has(o[0]))return t.get(o[0]);const n=o.map(getAutoTypedConstNode);return 1===n.length?nodeObject(n[0].nodeType===e||getValueType(n[0].value)===e?n[0]:new ConvertNode(n[0],e)):nodeObject(new JoinNode(n,e))}}};export const getConstNodeType=e=>null!=e?e.nodeType||e.convertTo||("string"==typeof e?e:null):null;export function ShaderNode(e){return new Proxy(new ShaderNodeInternal(e),shaderNodeHandler)}export const nodeObject=e=>ShaderNodeObject(e);export const nodeObjects=e=>new ShaderNodeObjects(e);export const nodeArray=e=>new ShaderNodeArray(e);export const nodeProxy=(...e)=>new ShaderNodeProxy(...e);export const nodeImmutable=(...e)=>new ShaderNodeImmutable(...e);export const shader=(...e)=>new ShaderNode(...e);addNodeClass(ShaderNode);export const color=new ConvertType("color");export const float=new ConvertType("float",cacheMaps.float);export const int=new ConvertType("int",cacheMaps.int);export const uint=new ConvertType("uint",cacheMaps.uint);export const bool=new ConvertType("bool",cacheMaps.bool);export const vec2=new ConvertType("vec2");export const ivec2=new ConvertType("ivec2");export const uvec2=new ConvertType("uvec2");export const bvec2=new ConvertType("bvec2");export const vec3=new ConvertType("vec3");export const ivec3=new ConvertType("ivec3");export const uvec3=new ConvertType("uvec3");export const bvec3=new ConvertType("bvec3");export const vec4=new ConvertType("vec4");export const ivec4=new ConvertType("ivec4");export const uvec4=new ConvertType("uvec4");export const bvec4=new ConvertType("bvec4");export const mat3=new ConvertType("mat3");export const imat3=new ConvertType("imat3");export const umat3=new ConvertType("umat3");export const bmat3=new ConvertType("bmat3");export const mat4=new ConvertType("mat4");export const imat4=new ConvertType("imat4");export const umat4=new ConvertType("umat4");export const bmat4=new ConvertType("bmat4");export const string=(e="")=>nodeObject(new ConstNode(e,"string"));export const arrayBuffer=e=>nodeObject(new ConstNode(e,"ArrayBuffer"));addNodeElement("color",color),addNodeElement("float",float),addNodeElement("int",int),addNodeElement("uint",uint),addNodeElement("bool",bool),addNodeElement("vec2",vec2),addNodeElement("ivec2",ivec2),addNodeElement("uvec2",uvec2),addNodeElement("bvec2",bvec2),addNodeElement("vec3",vec3),addNodeElement("ivec3",ivec3),addNodeElement("uvec3",uvec3),addNodeElement("bvec3",bvec3),addNodeElement("vec4",vec4),addNodeElement("ivec4",ivec4),addNodeElement("uvec4",uvec4),addNodeElement("bvec4",bvec4),addNodeElement("mat3",mat3),addNodeElement("imat3",imat3),addNodeElement("umat3",umat3),addNodeElement("bmat3",bmat3),addNodeElement("mat4",mat4),addNodeElement("imat4",imat4),addNodeElement("umat4",umat4),addNodeElement("bmat4",bmat4),addNodeElement("string",string),addNodeElement("arrayBuffer",arrayBuffer);export const element=nodeProxy(ArrayElementNode);export const convert=(e,t)=>nodeObject(new ConvertNode(nodeObject(e),t));export const split=(e,t)=>nodeObject(new SplitNode(nodeObject(e),t));addNodeElement("element",element),addNodeElement("convert",convert);