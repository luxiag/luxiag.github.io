import TempNode from"../core/TempNode.js";import{mix}from"../math/MathNode.js";import{addNodeClass}from"../core/Node.js";import{addNodeElement,ShaderNode,nodeObject,vec4}from"../shadernode/ShaderNode.js";import{LinearEncoding,LinearSRGBColorSpace,sRGBEncoding,SRGBColorSpace}from"three";export const LinearToLinear=new ShaderNode((o=>o.value));export const LinearTosRGB=new ShaderNode((o=>{const{value:e}=o,{rgb:r}=e,n=r.pow(.41666).mul(1.055).sub(.055),a=r.mul(12.92),d=r.lessThanEqual(.0031308),c=mix(n,a,d);return vec4(c,e.a)}));const EncodingLib={LinearToLinear,LinearTosRGB};class ColorSpaceNode extends TempNode{constructor(o,e){super("vec4"),this.method=o,this.node=e}fromColorSpace(o){let e=null;return o===LinearSRGBColorSpace?e="Linear":o===SRGBColorSpace&&(e="sRGB"),this.method="LinearTo"+e,this}fromEncoding(o){console.warn("THREE.ColorSpaceNode: Method .fromEncoding renamed to .fromColorSpace.");let e=null;return o===LinearEncoding?e="Linear":o===sRGBEncoding&&(e="sRGB"),this.method="LinearTo"+e,this}construct(){const{method:o,node:e}=this;return EncodingLib[o].call({value:e})}}ColorSpaceNode.LINEAR_TO_LINEAR="LinearToLinear",ColorSpaceNode.LINEAR_TO_SRGB="LinearTosRGB";export default ColorSpaceNode;export const colorSpace=(o,e)=>nodeObject(new ColorSpaceNode(null,nodeObject(o)).fromColorSpace(e));addNodeElement("colorSpace",colorSpace),addNodeClass(ColorSpaceNode);