import TempNode from"../core/TempNode.js";import{dot,mix}from"../math/MathNode.js";import{add}from"../math/OperatorNode.js";import{addNodeClass}from"../core/Node.js";import{addNodeElement,ShaderNode,nodeProxy,float,vec3,mat3}from"../shadernode/ShaderNode.js";const saturationNode=new ShaderNode((({color:o,adjustment:e})=>e.mix(luminance(o),o))),vibranceNode=new ShaderNode((({color:o,adjustment:e})=>{const t=add(o.r,o.g,o.b).div(3),d=o.r.max(o.g.max(o.b)),r=d.sub(t).mul(e).mul(-3);return mix(o,d,r)})),hueNode=new ShaderNode((({color:o,adjustment:e})=>{const t=mat3(.299,.587,.114,.595716,-.274453,-.321263,.211456,-.522591,.311135),d=mat3(1,.9563,.621,1,-.2721,-.6474,1,-1.107,1.7046),r=t.mul(o),n=r.z.atan2(r.y).add(e),s=r.yz.length();return d.mul(vec3(r.x,s.mul(n.cos()),s.mul(n.sin())))}));class ColorAdjustmentNode extends TempNode{constructor(o,e,t=float(1)){super("vec3"),this.method=o,this.colorNode=e,this.adjustmentNode=t}construct(){const{method:o,colorNode:e,adjustmentNode:t}=this,d={color:e,adjustment:t};let r=null;return o===ColorAdjustmentNode.SATURATION?r=saturationNode.call(d):o===ColorAdjustmentNode.VIBRANCE?r=vibranceNode.call(d):o===ColorAdjustmentNode.HUE?r=hueNode.call(d):console.error(`${this.type}: Method "${this.method}" not supported!`),r}}ColorAdjustmentNode.SATURATION="saturation",ColorAdjustmentNode.VIBRANCE="vibrance",ColorAdjustmentNode.HUE="hue";export default ColorAdjustmentNode;export const saturation=nodeProxy(ColorAdjustmentNode,ColorAdjustmentNode.SATURATION);export const vibrance=nodeProxy(ColorAdjustmentNode,ColorAdjustmentNode.VIBRANCE);export const hue=nodeProxy(ColorAdjustmentNode,ColorAdjustmentNode.HUE);export const lumaCoeffs=vec3(.2125,.7154,.0721);export const luminance=(o,e=lumaCoeffs)=>dot(o,e);addNodeElement("saturation",saturation),addNodeElement("vibrance",vibrance),addNodeElement("hue",hue),addNodeClass(ColorAdjustmentNode);