import TempNode from"../core/TempNode.js";import{addNodeClass}from"../core/Node.js";import{addNodeElement,nodeProxy}from"../shadernode/ShaderNode.js";class OperatorNode extends TempNode{constructor(e,o,t,...r){if(super(),this.op=e,r.length>0){let o=t;for(let t=0;t<r.length;t++)o=new OperatorNode(e,o,r[t]);t=o}this.aNode=o,this.bNode=t}hasDependencies(e){return"="!==this.op&&super.hasDependencies(e)}getNodeType(e,o){const t=this.op,r=this.aNode,d=this.bNode,a=r.getNodeType(e),n=d.getNodeType(e);if("void"===a||"void"===n)return"void";if("="===t||"%"===t)return a;if("&"===t||"|"===t||"^"===t||">>"===t||"<<"===t)return e.getIntegerType(a);if("=="===t||"&&"===t||"||"===t||"^^"===t)return"bool";if("<"===t||">"===t||"<="===t||">="===t){const t=o?e.getTypeLength(o):Math.max(e.getTypeLength(a),e.getTypeLength(n));return t>1?`bvec${t}`:"bool"}return"float"===a&&e.isMatrix(n)?n:e.isMatrix(a)&&e.isVector(n)?e.getVectorFromMatrix(a):e.isVector(a)&&e.isMatrix(n)?e.getVectorFromMatrix(n):e.getTypeLength(n)>e.getTypeLength(a)?n:a}generate(e,o){const t=this.op,r=this.aNode,d=this.bNode,a=this.getNodeType(e,o);let n=null,s=null;"void"!==a?(n=r.getNodeType(e),s=d.getNodeType(e),"="===t?s=n:"<"===t||">"===t||"<="===t||">="===t?e.isVector(n)?s=n:n=s="float":">>"===t||"<<"===t?(n=a,s=e.changeComponentType(s,"uint")):e.isMatrix(n)&&e.isVector(s)?s=e.getVectorFromMatrix(n):n=e.isVector(n)&&e.isMatrix(s)?e.getVectorFromMatrix(s):s=a):n=s=a;const i=r.build(e,n),p=d.build(e,s),l=e.getTypeLength(o);return"void"!==o?"="===t?(e.addLineFlowCode(`${i} ${this.op} ${p}`),i):"<"===t&&l>1?e.format(`${e.getMethod("lessThan")}( ${i}, ${p} )`,a,o):"<="===t&&l>1?e.format(`${e.getMethod("lessThanEqual")}( ${i}, ${p} )`,a,o):">"===t&&l>1?e.format(`${e.getMethod("greaterThan")}( ${i}, ${p} )`,a,o):">="===t&&l>1?e.format(`${e.getMethod("greaterThanEqual")}( ${i}, ${p} )`,a,o):e.format(`( ${i} ${this.op} ${p} )`,a,o):"void"!==n?e.format(`${i} ${this.op} ${p}`,a,o):void 0}serialize(e){super.serialize(e),e.op=this.op}deserialize(e){super.deserialize(e),this.op=e.op}}export default OperatorNode;export const add=nodeProxy(OperatorNode,"+");export const sub=nodeProxy(OperatorNode,"-");export const mul=nodeProxy(OperatorNode,"*");export const div=nodeProxy(OperatorNode,"/");export const remainder=nodeProxy(OperatorNode,"%");export const equal=nodeProxy(OperatorNode,"==");export const assign=nodeProxy(OperatorNode,"=");export const lessThan=nodeProxy(OperatorNode,"<");export const greaterThan=nodeProxy(OperatorNode,">");export const lessThanEqual=nodeProxy(OperatorNode,"<=");export const greaterThanEqual=nodeProxy(OperatorNode,">=");export const and=nodeProxy(OperatorNode,"&&");export const or=nodeProxy(OperatorNode,"||");export const xor=nodeProxy(OperatorNode,"^^");export const bitAnd=nodeProxy(OperatorNode,"&");export const bitOr=nodeProxy(OperatorNode,"|");export const bitXor=nodeProxy(OperatorNode,"^");export const shiftLeft=nodeProxy(OperatorNode,"<<");export const shiftRight=nodeProxy(OperatorNode,">>");addNodeElement("add",add),addNodeElement("sub",sub),addNodeElement("mul",mul),addNodeElement("div",div),addNodeElement("remainder",remainder),addNodeElement("equal",equal),addNodeElement("assign",assign),addNodeElement("lessThan",lessThan),addNodeElement("greaterThan",greaterThan),addNodeElement("lessThanEqual",lessThanEqual),addNodeElement("greaterThanEqual",greaterThanEqual),addNodeElement("and",and),addNodeElement("or",or),addNodeElement("xor",xor),addNodeElement("bitAnd",bitAnd),addNodeElement("bitOr",bitOr),addNodeElement("bitXor",bitXor),addNodeElement("shiftLeft",shiftLeft),addNodeElement("shiftRight",shiftRight),addNodeClass(OperatorNode);