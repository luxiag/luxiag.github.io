import TempNode from"../core/TempNode.js";import{sub,mul,div}from"./OperatorNode.js";import{addNodeClass}from"../core/Node.js";import{addNodeElement,nodeObject,nodeProxy,float,vec3,vec4}from"../shadernode/ShaderNode.js";class MathNode extends TempNode{constructor(e,o,t=null,d=null){super(),this.method=e,this.aNode=o,this.bNode=t,this.cNode=d}getInputType(e){const o=this.aNode.getNodeType(e),t=this.bNode?this.bNode.getNodeType(e):null,d=this.cNode?this.cNode.getNodeType(e):null,a=e.isMatrix(o)?0:e.getTypeLength(o),N=e.isMatrix(t)?0:e.getTypeLength(t),n=e.isMatrix(d)?0:e.getTypeLength(d);return a>N&&a>n?o:N>n?t:n>a?d:o}getNodeType(e){const o=this.method;return o===MathNode.LENGTH||o===MathNode.DISTANCE||o===MathNode.DOT?"float":o===MathNode.CROSS?"vec3":this.getInputType(e)}generate(e,o){const t=this.method,d=this.getNodeType(e),a=this.getInputType(e),N=this.aNode,n=this.bNode,r=this.cNode,h=!0===e.renderer.isWebGLRenderer;if(t===MathNode.TRANSFORM_DIRECTION){let t=N,d=n;e.isMatrix(t.getNodeType(e))?d=vec4(vec3(d),0):t=vec4(vec3(t),0);const a=mul(t,d).xyz;return normalize(a).build(e,o)}if(t===MathNode.NEGATE)return e.format("-"+N.build(e,a),d,o);if(t===MathNode.ONE_MINUS)return sub(1,N).build(e,o);if(t===MathNode.RECIPROCAL)return div(1,N).build(e,o);if(t===MathNode.DIFFERENCE)return abs(sub(N,n)).build(e,o);{const s=[];return t===MathNode.CROSS?s.push(N.build(e,d),n.build(e,d)):t===MathNode.STEP?s.push(N.build(e,1===e.getTypeLength(N.getNodeType(e))?"float":a),n.build(e,a)):h&&(t===MathNode.MIN||t===MathNode.MAX)||t===MathNode.MOD?s.push(N.build(e,a),n.build(e,1===e.getTypeLength(n.getNodeType(e))?"float":a)):t===MathNode.REFRACT?s.push(N.build(e,a),n.build(e,a),r.build(e,"float")):t===MathNode.MIX?s.push(N.build(e,a),n.build(e,a),r.build(e,1===e.getTypeLength(r.getNodeType(e))?"float":a)):(s.push(N.build(e,a)),null!==n&&s.push(n.build(e,a)),null!==r&&s.push(r.build(e,a))),e.format(`${e.getMethod(t)}( ${s.join(", ")} )`,d,o)}}serialize(e){super.serialize(e),e.method=this.method}deserialize(e){super.deserialize(e),this.method=e.method}}MathNode.RADIANS="radians",MathNode.DEGREES="degrees",MathNode.EXP="exp",MathNode.EXP2="exp2",MathNode.LOG="log",MathNode.LOG2="log2",MathNode.SQRT="sqrt",MathNode.INVERSE_SQRT="inversesqrt",MathNode.FLOOR="floor",MathNode.CEIL="ceil",MathNode.NORMALIZE="normalize",MathNode.FRACT="fract",MathNode.SIN="sin",MathNode.COS="cos",MathNode.TAN="tan",MathNode.ASIN="asin",MathNode.ACOS="acos",MathNode.ATAN="atan",MathNode.ABS="abs",MathNode.SIGN="sign",MathNode.LENGTH="length",MathNode.NEGATE="negate",MathNode.ONE_MINUS="oneMinus",MathNode.DFDX="dFdx",MathNode.DFDY="dFdy",MathNode.ROUND="round",MathNode.RECIPROCAL="reciprocal",MathNode.ATAN2="atan2",MathNode.MIN="min",MathNode.MAX="max",MathNode.MOD="mod",MathNode.STEP="step",MathNode.REFLECT="reflect",MathNode.DISTANCE="distance",MathNode.DIFFERENCE="difference",MathNode.DOT="dot",MathNode.CROSS="cross",MathNode.POW="pow",MathNode.TRANSFORM_DIRECTION="transformDirection",MathNode.MIX="mix",MathNode.CLAMP="clamp",MathNode.REFRACT="refract",MathNode.SMOOTHSTEP="smoothstep",MathNode.FACEFORWARD="faceforward";export default MathNode;export const EPSILON=float(1e-6);export const INFINITY=float(1e6);export const radians=nodeProxy(MathNode,MathNode.RADIANS);export const degrees=nodeProxy(MathNode,MathNode.DEGREES);export const exp=nodeProxy(MathNode,MathNode.EXP);export const exp2=nodeProxy(MathNode,MathNode.EXP2);export const log=nodeProxy(MathNode,MathNode.LOG);export const log2=nodeProxy(MathNode,MathNode.LOG2);export const sqrt=nodeProxy(MathNode,MathNode.SQRT);export const inverseSqrt=nodeProxy(MathNode,MathNode.INVERSE_SQRT);export const floor=nodeProxy(MathNode,MathNode.FLOOR);export const ceil=nodeProxy(MathNode,MathNode.CEIL);export const normalize=nodeProxy(MathNode,MathNode.NORMALIZE);export const fract=nodeProxy(MathNode,MathNode.FRACT);export const sin=nodeProxy(MathNode,MathNode.SIN);export const cos=nodeProxy(MathNode,MathNode.COS);export const tan=nodeProxy(MathNode,MathNode.TAN);export const asin=nodeProxy(MathNode,MathNode.ASIN);export const acos=nodeProxy(MathNode,MathNode.ACOS);export const atan=nodeProxy(MathNode,MathNode.ATAN);export const abs=nodeProxy(MathNode,MathNode.ABS);export const sign=nodeProxy(MathNode,MathNode.SIGN);export const length=nodeProxy(MathNode,MathNode.LENGTH);export const negate=nodeProxy(MathNode,MathNode.NEGATE);export const oneMinus=nodeProxy(MathNode,MathNode.ONE_MINUS);export const dFdx=nodeProxy(MathNode,MathNode.DFDX);export const dFdy=nodeProxy(MathNode,MathNode.DFDY);export const round=nodeProxy(MathNode,MathNode.ROUND);export const reciprocal=nodeProxy(MathNode,MathNode.RECIPROCAL);export const atan2=nodeProxy(MathNode,MathNode.ATAN2);export const min=nodeProxy(MathNode,MathNode.MIN);export const max=nodeProxy(MathNode,MathNode.MAX);export const mod=nodeProxy(MathNode,MathNode.MOD);export const step=nodeProxy(MathNode,MathNode.STEP);export const reflect=nodeProxy(MathNode,MathNode.REFLECT);export const distance=nodeProxy(MathNode,MathNode.DISTANCE);export const difference=nodeProxy(MathNode,MathNode.DIFFERENCE);export const dot=nodeProxy(MathNode,MathNode.DOT);export const cross=nodeProxy(MathNode,MathNode.CROSS);export const pow=nodeProxy(MathNode,MathNode.POW);export const pow2=nodeProxy(MathNode,MathNode.POW,2);export const pow3=nodeProxy(MathNode,MathNode.POW,3);export const pow4=nodeProxy(MathNode,MathNode.POW,4);export const transformDirection=nodeProxy(MathNode,MathNode.TRANSFORM_DIRECTION);export const mix=nodeProxy(MathNode,MathNode.MIX);export const clamp=(e,o=0,t=1)=>nodeObject(new MathNode(MathNode.CLAMP,nodeObject(e),nodeObject(o),nodeObject(t)));export const saturate=e=>clamp(e);export const refract=nodeProxy(MathNode,MathNode.REFRACT);export const smoothstep=nodeProxy(MathNode,MathNode.SMOOTHSTEP);export const faceForward=nodeProxy(MathNode,MathNode.FACEFORWARD);export const mixElement=(e,o,t)=>mix(o,t,e);export const smoothstepElement=(e,o,t)=>smoothstep(o,t,e);addNodeElement("radians",radians),addNodeElement("degrees",degrees),addNodeElement("exp",exp),addNodeElement("exp2",exp2),addNodeElement("log",log),addNodeElement("log2",log2),addNodeElement("sqrt",sqrt),addNodeElement("inverseSqrt",inverseSqrt),addNodeElement("floor",floor),addNodeElement("ceil",ceil),addNodeElement("normalize",normalize),addNodeElement("fract",fract),addNodeElement("sin",sin),addNodeElement("cos",cos),addNodeElement("tan",tan),addNodeElement("asin",asin),addNodeElement("acos",acos),addNodeElement("atan",atan),addNodeElement("abs",abs),addNodeElement("sign",sign),addNodeElement("length",length),addNodeElement("negate",negate),addNodeElement("oneMinus",oneMinus),addNodeElement("dFdx",dFdx),addNodeElement("dFdy",dFdy),addNodeElement("round",round),addNodeElement("reciprocal",reciprocal),addNodeElement("atan2",atan2),addNodeElement("min",min),addNodeElement("max",max),addNodeElement("mod",mod),addNodeElement("step",step),addNodeElement("reflect",reflect),addNodeElement("distance",distance),addNodeElement("dot",dot),addNodeElement("cross",cross),addNodeElement("pow",pow),addNodeElement("pow2",pow2),addNodeElement("pow3",pow3),addNodeElement("pow4",pow4),addNodeElement("transformDirection",transformDirection),addNodeElement("mix",mixElement),addNodeElement("clamp",clamp),addNodeElement("refract",refract),addNodeElement("smoothstep",smoothstepElement),addNodeElement("faceForward",faceForward),addNodeElement("difference",difference),addNodeElement("saturate",saturate),addNodeClass(MathNode);