import NodeFunction from"../core/NodeFunction.js";import NodeFunctionInput from"../core/NodeFunctionInput.js";const declarationRegexp=/^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+)?/i,propertiesRegexp=/[a-z_0-9]+/gi,wgslTypeLib={f32:"float"},parse=t=>{const e=(t=t.trim()).match(declarationRegexp);if(null!==e&&4===e.length){const o=e[2],n=[];let s=null;for(;null!==(s=propertiesRegexp.exec(o));)n.push(s);const i=[];let c=0;for(;c<n.length;){const t=n[c++][0];let e=n[c++][0];e=wgslTypeLib[e]||e,c<n.length&&!0===/^[fui]\d{2}$/.test(n[c][0])&&c++,i.push(new NodeFunctionInput(e,t))}const p=t.substring(e[0].length),r=void 0!==e[1]?e[1]:"";return{type:e[3]||"void",inputs:i,name:r,inputsCode:o,blockCode:p}}throw new Error("FunctionNode: Function is not a WGSL code.")};class WGSLNodeFunction extends NodeFunction{constructor(t){const{type:e,inputs:o,name:n,inputsCode:s,blockCode:i}=parse(t);super(e,o,n),this.inputsCode=s,this.blockCode=i}getCode(t=this.name){const e="void"!==this.type?"-> "+this.type:"";return`fn ${t} ( ${this.inputsCode.trim()} ) ${e}`+this.blockCode}}export default WGSLNodeFunction;