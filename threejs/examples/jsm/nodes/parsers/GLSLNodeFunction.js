import NodeFunction from"../core/NodeFunction.js";import NodeFunctionInput from"../core/NodeFunctionInput.js";const declarationRegexp=/^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i,propertiesRegexp=/[a-z_0-9]+/gi,pragmaMain="#pragma main",parse=e=>{const o=(e=e.trim()).indexOf(pragmaMain),n=-1!==o?e.slice(o+pragmaMain.length):e,t=n.match(declarationRegexp);if(null!==t&&5===t.length){const i=t[4],s=[];let r=null;for(;null!==(r=propertiesRegexp.exec(i));)s.push(r);const c=[];let p=0;for(;p<s.length;){const e="const"===s[p][0];!0===e&&p++;let o=s[p][0];"in"===o||"out"===o||"inout"===o?p++:o="";const n=s[p++][0];let t=Number.parseInt(s[p][0]);!1===Number.isNaN(t)?p++:t=null;const i=s[p++][0];c.push(new NodeFunctionInput(n,i,t,o,e))}const u=n.substring(t[0].length),d=void 0!==t[3]?t[3]:"";return{type:t[2],inputs:c,name:d,presicion:void 0!==t[1]?t[1]:"",inputsCode:i,blockCode:u,headerCode:-1!==o?e.slice(0,o):""}}throw new Error("FunctionNode: Function is not a GLSL code.")};class GLSLNodeFunction extends NodeFunction{constructor(e){const{type:o,inputs:n,name:t,presicion:i,inputsCode:s,blockCode:r,headerCode:c}=parse(e);super(o,n,t,i),this.inputsCode=s,this.blockCode=r,this.headerCode=c}getCode(e=this.name){let o;const n=this.blockCode;if(""!==n){const{type:t,inputsCode:i,headerCode:s,presicion:r}=this;let c=`${t} ${e} ( ${i.trim()} )`;""!==r&&(c=`${r} ${c}`),o=s+c+n}else o="";return o}}export default GLSLNodeFunction;