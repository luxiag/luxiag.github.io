import NodeUniform from"./NodeUniform.js";import NodeAttribute from"./NodeAttribute.js";import NodeVarying from"./NodeVarying.js";import NodeVar from"./NodeVar.js";import NodeCode from"./NodeCode.js";import NodeKeywords from"./NodeKeywords.js";import NodeCache from"./NodeCache.js";import{NodeUpdateType,defaultBuildStages,shaderStages}from"./constants.js";import{REVISION,NoColorSpace,LinearEncoding,sRGBEncoding,SRGBColorSpace,Color,Vector2,Vector3,Vector4}from"three";import{stack}from"./StackNode.js";import{maxMipLevel}from"../utils/MaxMipLevelNode.js";const typeFromLength=new Map;typeFromLength.set(2,"vec2"),typeFromLength.set(3,"vec3"),typeFromLength.set(4,"vec4"),typeFromLength.set(9,"mat3"),typeFromLength.set(16,"mat4");const toFloat=t=>(t=Number(t))+(t%1?"":".0");class NodeBuilder{constructor(t,e,o){this.object=t,this.material=t&&(t.material||null),this.geometry=t&&(t.geometry||null),this.renderer=e,this.parser=o,this.nodes=[],this.updateNodes=[],this.hashNodes={},this.lightsNode=null,this.environmentNode=null,this.fogNode=null,this.toneMappingNode=null,this.vertexShader=null,this.fragmentShader=null,this.computeShader=null,this.flowNodes={vertex:[],fragment:[],compute:[]},this.flowCode={vertex:"",fragment:"",compute:[]},this.uniforms={vertex:[],fragment:[],compute:[],index:0},this.codes={vertex:[],fragment:[],compute:[]},this.attributes=[],this.varyings=[],this.vars={vertex:[],fragment:[],compute:[]},this.flow={code:""},this.chaining=[],this.stack=stack(),this.tab="\t",this.context={keywords:new NodeKeywords,material:this.material,getMIPLevelAlgorithmNode:(t,e)=>e.mul(maxMipLevel(t))},this.cache=new NodeCache,this.globalCache=this.cache,this.flowsData=new WeakMap,this.shaderStage=null,this.buildStage=null}setHashNode(t,e){this.hashNodes[e]=t}addNode(t){-1===this.nodes.indexOf(t)&&(t.getUpdateType()!==NodeUpdateType.NONE&&this.updateNodes.push(t),this.nodes.push(t),this.setHashNode(t,t.getHash(this)))}get currentNode(){return this.chaining[this.chaining.length-1]}addChain(t){this.chaining.push(t)}removeChain(t){if(this.chaining.pop()!==t)throw new Error("NodeBuilder: Invalid node chaining!")}getMethod(t){return t}getNodeFromHash(t){return this.hashNodes[t]}addFlow(t,e){return this.flowNodes[t].push(e),e}setContext(t){this.context=t}getContext(){return this.context}setCache(t){this.cache=t}getCache(){return this.cache}isAvailable(){return!1}getInstanceIndex(){console.warn("Abstract function.")}getFrontFacing(){console.warn("Abstract function.")}getFragCoord(){console.warn("Abstract function.")}isFlipY(){return!1}getTexture(){console.warn("Abstract function.")}getTextureLevel(){console.warn("Abstract function.")}getConst(t,e=null){if(null===e&&("float"===t||"int"===t||"uint"===t?e=0:"bool"===t?e=!1:"color"===t?e=new Color:"vec2"===t?e=new Vector2:"vec3"===t?e=new Vector3:"vec4"===t&&(e=new Vector4)),"float"===t)return toFloat(e);if("int"===t)return`${Math.round(e)}`;if("uint"===t)return e>=0?`${Math.round(e)}u`:"0u";if("bool"===t)return e?"true":"false";if("color"===t)return`${this.getType("vec3")}( ${toFloat(e.r)}, ${toFloat(e.g)}, ${toFloat(e.b)} )`;const o=this.getTypeLength(t),r=this.getComponentType(t),s=t=>this.getConst(r,t);if(2===o)return`${this.getType(t)}( ${s(e.x)}, ${s(e.y)} )`;if(3===o)return`${this.getType(t)}( ${s(e.x)}, ${s(e.y)}, ${s(e.z)} )`;if(4===o)return`${this.getType(t)}( ${s(e.x)}, ${s(e.y)}, ${s(e.z)}, ${s(e.w)} )`;if(o>4)return`${this.getType(t)}()`;throw new Error(`NodeBuilder: Type '${t}' not found in generate constant attempt.`)}getType(t){return t}generateMethod(t){return t}hasGeometryAttribute(t){return this.geometry&&void 0!==this.geometry.getAttribute(t)}getAttribute(t,e){const o=this.attributes;for(const e of o)if(e.name===t)return e;const r=new NodeAttribute(t,e);return o.push(r),r}getPropertyName(t){return t.name}isVector(t){return/vec\d/.test(t)}isMatrix(t){return/mat\d/.test(t)}isReference(t){return"void"===t||"property"===t||"sampler"===t||"texture"===t||"cubeTexture"===t}isShaderStage(t){return this.shaderStage===t}getTextureEncodingFromMap(t){return console.warn("THREE.NodeBuilder: Method .getTextureEncodingFromMap replaced by .getTextureColorSpaceFromMap in r152+."),this.getTextureColorSpaceFromMap(t)===SRGBColorSpace?sRGBEncoding:LinearEncoding}getTextureColorSpaceFromMap(t){let e;return e=t&&t.isTexture?t.colorSpace:t&&t.isWebGLRenderTarget?t.texture.colorSpace:NoColorSpace,e}getComponentType(t){if("float"===(t=this.getVectorType(t))||"bool"===t||"int"===t||"uint"===t)return t;const e=/(b|i|u|)(vec|mat)([2-4])/.exec(t);return null===e?null:"b"===e[1]?"bool":"i"===e[1]?"int":"u"===e[1]?"uint":"float"}getVectorType(t){return"color"===t?"vec3":"texture"===t?"vec4":t}getTypeFromLength(t,e="float"){if(1===t)return e;const o=typeFromLength.get(t);return("float"===e?"":e[0])+o}getTypeLength(t){const e=this.getVectorType(t),o=/vec([2-4])/.exec(e);return null!==o?Number(o[1]):"float"===e||"bool"===e||"int"===e||"uint"===e?1:!0===/mat3/.test(t)?9:!0===/mat4/.test(t)?16:0}getVectorFromMatrix(t){return t.replace("mat","vec")}changeComponentType(t,e){return this.getTypeFromLength(this.getTypeLength(t),e)}getIntegerType(t){const e=this.getComponentType(t);return"int"===e||"uint"===e?t:this.changeComponentType(t,"int")}addStack(){return this.stack=stack(this.stack),this.stack}removeStack(){const t=this.stack;return this.stack=t.parent,t}getDataFromNode(t,e=this.shaderStage){const o=t.isGlobal(this)?this.globalCache:this.cache;let r=o.getNodeData(t);return void 0===r&&(r={vertex:{},fragment:{},compute:{}},o.setNodeData(t,r)),null!==e?r[e]:r}getNodeProperties(t,e=this.shaderStage){const o=this.getDataFromNode(t,e);return o.properties||(o.properties={outputNode:null})}getUniformFromNode(t,e,o){const r=this.getDataFromNode(t,e);let s=r.uniform;if(void 0===s){const n=this.uniforms.index++;s=new NodeUniform("nodeUniform"+n,o,t),this.uniforms[e].push(s),r.uniform=s}return s}getVarFromNode(t,e,o=this.shaderStage){const r=this.getDataFromNode(t,o);let s=r.variable;if(void 0===s){const t=this.vars[o],n=t.length;s=new NodeVar("nodeVar"+n,e),t.push(s),r.variable=s}return s}getVaryingFromNode(t,e){const o=this.getDataFromNode(t,null);let r=o.varying;if(void 0===r){const t=this.varyings,s=t.length;r=new NodeVarying("nodeVarying"+s,e),t.push(r),o.varying=r}return r}getCodeFromNode(t,e,o=this.shaderStage){const r=this.getDataFromNode(t);let s=r.code;if(void 0===s){const t=this.codes[o],n=t.length;s=new NodeCode("nodeCode"+n,e),t.push(s),r.code=s}return s}addLineFlowCode(t){return""===t||(t=this.tab+t,/;\s*$/.test(t)||(t+=";\n"),this.flow.code+=t),this}addFlowCode(t){return this.flow.code+=t,this}addFlowTab(){return this.tab+="\t",this}removeFlowTab(){return this.tab=this.tab.slice(0,-1),this}getFlowData(t){return this.flowsData.get(t)}flowNode(t){const e=t.getNodeType(this),o=this.flowChildNode(t,e);return this.flowsData.set(t,o),o}flowChildNode(t,e=null){const o=this.flow,r={code:""};return this.flow=r,r.result=t.build(this,e),this.flow=o,r}flowNodeFromShaderStage(t,e,o=null,r=null){const s=this.shaderStage;this.setShaderStage(t);const n=this.flowChildNode(e,o);return null!==r&&(n.code+=`${r} = ${n.result};\n`+this.tab),this.flowCode[t]=this.flowCode[t]+n.code,this.setShaderStage(s),n}getAttributes(){console.warn("Abstract function.")}getVaryings(){console.warn("Abstract function.")}getVars(t){let e="";const o=this.vars[t];for(const t of o)e+=`${t.type} ${t.name}; `;return e}getUniforms(){console.warn("Abstract function.")}getCodes(t){const e=this.codes[t];let o="";for(const t of e)o+=t.code+"\n";return o}getHash(){return this.vertexShader+this.fragmentShader+this.computeShader}setShaderStage(t){this.shaderStage=t}getShaderStage(){return this.shaderStage}setBuildStage(t){this.buildStage=t}getBuildStage(){return this.buildStage}buildCode(){console.warn("Abstract function.")}build(){for(const t of defaultBuildStages){this.setBuildStage(t),this.context.vertex&&this.context.vertex.isNode&&this.flowNodeFromShaderStage("vertex",this.context.vertex);for(const e of shaderStages){this.setShaderStage(e);const o=this.flowNodes[e];for(const e of o)"generate"===t?this.flowNode(e):e.build(this)}}return this.setBuildStage(null),this.setShaderStage(null),this.buildCode(),this}format(t,e,o){if((e=this.getVectorType(e))===(o=this.getVectorType(o))||null===o||this.isReference(o))return t;const r=this.getTypeLength(e),s=this.getTypeLength(o);return r>4||s>4||0===s?t:r===s?`${this.getType(o)}( ${t} )`:r>s?this.format(`${t}.${"xyz".slice(0,s)}`,this.getTypeFromLength(s),o):4===s?`${this.getType(o)}( ${this.format(t,e,"vec3")}, 1.0 )`:2===r?`${this.getType(o)}( ${this.format(t,e,"vec2")}, 0.0 )`:`${this.getType(o)}( ${t} )`}getSignature(){return`// Three.js r${REVISION} - NodeMaterial System\n`}}export default NodeBuilder;