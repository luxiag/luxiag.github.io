import{NodeUpdateType}from"./constants.js";import{getNodeChildren,getCacheKey}from"./NodeUtils.js";import{MathUtils}from"three";const NodeClasses=new Map;let _nodeId=0;class Node{constructor(e=null){this.isNode=!0,this.nodeType=e,this.updateType=NodeUpdateType.NONE,this.updateBeforeType=NodeUpdateType.NONE,this.uuid=MathUtils.generateUUID(),Object.defineProperty(this,"id",{value:_nodeId++})}get type(){return this.constructor.name}isGlobal(){return!1}*getChildren(){const e=this;for(const{property:t,index:o,childNode:s}of getNodeChildren(this))void 0!==o?yield{childNode:s,replaceNode(s){e[t][o]=s}}:yield{childNode:s,replaceNode(o){e[t]=o}}}traverse(e,t=null){e(this,t);for(const{childNode:t,replaceNode:o}of this.getChildren())t.traverse(e,o)}getCacheKey(){return getCacheKey(this)}getHash(){return this.uuid}getUpdateType(){return this.updateType}getUpdateBeforeType(){return this.updateBeforeType}getNodeType(){return this.nodeType}getReference(e){const t=this.getHash(e);return e.getNodeFromHash(t)||this}construct(e){const t=e.getNodeProperties(this);for(const{childNode:e}of this.getChildren())t["_node"+e.id]=e;return null}analyze(e){const t=e.getDataFromNode(this);if(t.dependenciesCount=void 0===t.dependenciesCount?1:t.dependenciesCount+1,1===t.dependenciesCount){const t=e.getNodeProperties(this);for(const o of Object.values(t))o&&!0===o.isNode&&o.build(e)}}generate(e,t){const{outputNode:o}=e.getNodeProperties(this);if(o&&!0===o.isNode)return o.build(e,t)}updateBefore(){console.warn("Abstract function.")}update(){console.warn("Abstract function.")}build(e,t=null){const o=this.getReference(e);if(this!==o)return o.build(e,t);e.addNode(this),e.addChain(this);let s=null;const i=e.getBuildStage();if("construct"===i){const t=e.getNodeProperties(this);if(!0!==t.initialized||!1===e.context.tempRead){t.initialized=!0,t.outputNode=this.construct(e);for(const o of Object.values(t))o&&!0===o.isNode&&o.build(e)}}else if("analyze"===i)this.analyze(e);else if("generate"===i)if(1===this.generate.length){const o=this.getNodeType(e),i=e.getDataFromNode(this);s=i.snippet,void 0===s&&(s=this.generate(e)||"",i.snippet=s),s=e.format(s,o,t)}else s=this.generate(e,t)||"";return e.removeChain(this),s}getSerializeChildren(){return getNodeChildren(this)}serialize(e){const t=this.getSerializeChildren(),o={};for(const{property:s,index:i,childNode:n}of t)void 0!==i?(void 0===o[s]&&(o[s]=Number.isInteger(i)?[]:{}),o[s][i]=n.toJSON(e.meta).uuid):o[s]=n.toJSON(e.meta).uuid;Object.keys(o).length>0&&(e.inputNodes=o)}deserialize(e){if(void 0!==e.inputNodes){const t=e.meta.nodes;for(const o in e.inputNodes)if(Array.isArray(e.inputNodes[o])){const s=[];for(const i of e.inputNodes[o])s.push(t[i]);this[o]=s}else if("object"==typeof e.inputNodes[o]){const s={};for(const i in e.inputNodes[o]){const n=e.inputNodes[o][i];s[i]=t[n]}this[o]=s}else{const s=e.inputNodes[o];this[o]=t[s]}}}toJSON(e){const{uuid:t,type:o}=this,s=void 0===e||"string"==typeof e;s&&(e={textures:{},images:{},nodes:{}});let i=e.nodes[t];function n(e){const t=[];for(const o in e){const s=e[o];delete s.metadata,t.push(s)}return t}if(void 0===i&&(i={uuid:t,type:o,meta:e,metadata:{version:4.5,type:"Node",generator:"Node.toJSON"}},!0!==s&&(e.nodes[i.uuid]=i),this.serialize(i),delete i.meta),s){const t=n(e.textures),o=n(e.images),s=n(e.nodes);t.length>0&&(i.textures=t),o.length>0&&(i.images=o),s.length>0&&(i.nodes=s)}return i}}export default Node;export function addNodeClass(e){if("function"!=typeof e||!e.name)throw new Error(`Node class ${e.name} is not a class`);if(NodeClasses.has(e.name))throw new Error(`Redefinition of node class ${e.name}`);NodeClasses.set(e.name,e)}export function createNodeFromType(e){const t=NodeClasses.get(e);if(void 0!==t)return new t}