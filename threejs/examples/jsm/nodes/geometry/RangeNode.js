import Node,{addNodeClass}from"../core/Node.js";import{getValueType}from"../core/NodeUtils.js";import{attribute}from"../core/AttributeNode.js";import{nodeProxy,float}from"../shadernode/ShaderNode.js";import{MathUtils,InstancedBufferAttribute}from"three";class RangeNode extends Node{constructor(e=float(),t=float()){super(),this.minNode=e,this.maxNode=t}getVectorLength(e){const t=e.getTypeLength(getValueType(this.minNode.value)),o=e.getTypeLength(getValueType(this.maxNode.value));return t>o?t:o}getNodeType(e){return!0===e.object.isInstancedMesh?e.getTypeFromLength(this.getVectorLength(e)):"float"}construct(e){const t=e.object;let o=null;if(!0===t.isInstancedMesh){const r=e.geometry;let a=this.minNode.value,n=this.maxNode.value;const s=e.getTypeLength(getValueType(a)),l=e.getTypeLength(getValueType(n));s>l&&l>1?n=(new a.constructor).fromArray(a.toArray()):s>l&&1===l?n=(new a.constructor).setScalar(n):l>s&&s>1?a=(new n.constructor).fromArray(a.toArray()):l>s&&1===s&&(a=(new n.constructor).setScalar(a));const d=this.getVectorLength(e),i="node"+this.id,g=d*t.count,c=new Float32Array(g),h=r.getAttribute(i);if(void 0===h||h.array.length<g){if(1===d)for(let e=0;e<g;e++)c[e]=MathUtils.lerp(a,n,Math.random());else if(a.isColor)for(let e=0;e<g;e+=3)c[e]=MathUtils.lerp(a.r,n.r,Math.random()),c[e+1]=MathUtils.lerp(a.g,n.g,Math.random()),c[e+2]=MathUtils.lerp(a.b,n.b,Math.random());else for(let e=0;e<g;e++){const t=e%d,o=a.getComponent(t),r=n.getComponent(t);c[e]=MathUtils.lerp(o,r,Math.random())}r.setAttribute(i,new InstancedBufferAttribute(c,d)),r.dispose()}o=attribute(i,e.getTypeFromLength(d))}else o=float(0);return o}}export default RangeNode;export const range=nodeProxy(RangeNode);addNodeClass(RangeNode);