import{Box3,MathUtils,Matrix4,Matrix3,Ray,Vector3}from"three";const a={c:null,u:[new Vector3,new Vector3,new Vector3],e:[]},b={c:null,u:[new Vector3,new Vector3,new Vector3],e:[]},R=[[],[],[]],AbsR=[[],[],[]],t=[],xAxis=new Vector3,yAxis=new Vector3,zAxis=new Vector3,v1=new Vector3,size=new Vector3,closestPoint=new Vector3,rotationMatrix=new Matrix3,aabb=new Box3,matrix=new Matrix4,inverse=new Matrix4,localRay=new Ray;class OBB{constructor(t=new Vector3,e=new Vector3,s=new Matrix3){this.center=t,this.halfSize=e,this.rotation=s}set(t,e,s){return this.center=t,this.halfSize=e,this.rotation=s,this}copy(t){return this.center.copy(t.center),this.halfSize.copy(t.halfSize),this.rotation.copy(t.rotation),this}clone(){return(new this.constructor).copy(this)}getSize(t){return t.copy(this.halfSize).multiplyScalar(2)}clampPoint(t,e){const s=this.halfSize;v1.subVectors(t,this.center),this.rotation.extractBasis(xAxis,yAxis,zAxis),e.copy(this.center);const a=MathUtils.clamp(v1.dot(xAxis),-s.x,s.x);e.add(xAxis.multiplyScalar(a));const i=MathUtils.clamp(v1.dot(yAxis),-s.y,s.y);e.add(yAxis.multiplyScalar(i));const r=MathUtils.clamp(v1.dot(zAxis),-s.z,s.z);return e.add(zAxis.multiplyScalar(r)),e}containsPoint(t){return v1.subVectors(t,this.center),this.rotation.extractBasis(xAxis,yAxis,zAxis),Math.abs(v1.dot(xAxis))<=this.halfSize.x&&Math.abs(v1.dot(yAxis))<=this.halfSize.y&&Math.abs(v1.dot(zAxis))<=this.halfSize.z}intersectsBox3(t){return this.intersectsOBB(obb.fromBox3(t))}intersectsSphere(t){return this.clampPoint(t.center,closestPoint),closestPoint.distanceToSquared(t.center)<=t.radius*t.radius}intersectsOBB(e,s=Number.EPSILON){a.c=this.center,a.e[0]=this.halfSize.x,a.e[1]=this.halfSize.y,a.e[2]=this.halfSize.z,this.rotation.extractBasis(a.u[0],a.u[1],a.u[2]),b.c=e.center,b.e[0]=e.halfSize.x,b.e[1]=e.halfSize.y,b.e[2]=e.halfSize.z,e.rotation.extractBasis(b.u[0],b.u[1],b.u[2]);for(let t=0;t<3;t++)for(let e=0;e<3;e++)R[t][e]=a.u[t].dot(b.u[e]);v1.subVectors(b.c,a.c),t[0]=v1.dot(a.u[0]),t[1]=v1.dot(a.u[1]),t[2]=v1.dot(a.u[2]);for(let t=0;t<3;t++)for(let e=0;e<3;e++)AbsR[t][e]=Math.abs(R[t][e])+s;let i,r;for(let e=0;e<3;e++)if(i=a.e[e],r=b.e[0]*AbsR[e][0]+b.e[1]*AbsR[e][1]+b.e[2]*AbsR[e][2],Math.abs(t[e])>i+r)return!1;for(let e=0;e<3;e++)if(i=a.e[0]*AbsR[0][e]+a.e[1]*AbsR[1][e]+a.e[2]*AbsR[2][e],r=b.e[e],Math.abs(t[0]*R[0][e]+t[1]*R[1][e]+t[2]*R[2][e])>i+r)return!1;return i=a.e[1]*AbsR[2][0]+a.e[2]*AbsR[1][0],r=b.e[1]*AbsR[0][2]+b.e[2]*AbsR[0][1],!(Math.abs(t[2]*R[1][0]-t[1]*R[2][0])>i+r||(i=a.e[1]*AbsR[2][1]+a.e[2]*AbsR[1][1],r=b.e[0]*AbsR[0][2]+b.e[2]*AbsR[0][0],Math.abs(t[2]*R[1][1]-t[1]*R[2][1])>i+r||(i=a.e[1]*AbsR[2][2]+a.e[2]*AbsR[1][2],r=b.e[0]*AbsR[0][1]+b.e[1]*AbsR[0][0],Math.abs(t[2]*R[1][2]-t[1]*R[2][2])>i+r||(i=a.e[0]*AbsR[2][0]+a.e[2]*AbsR[0][0],r=b.e[1]*AbsR[1][2]+b.e[2]*AbsR[1][1],Math.abs(t[0]*R[2][0]-t[2]*R[0][0])>i+r||(i=a.e[0]*AbsR[2][1]+a.e[2]*AbsR[0][1],r=b.e[0]*AbsR[1][2]+b.e[2]*AbsR[1][0],Math.abs(t[0]*R[2][1]-t[2]*R[0][1])>i+r||(i=a.e[0]*AbsR[2][2]+a.e[2]*AbsR[0][2],r=b.e[0]*AbsR[1][1]+b.e[1]*AbsR[1][0],Math.abs(t[0]*R[2][2]-t[2]*R[0][2])>i+r||(i=a.e[0]*AbsR[1][0]+a.e[1]*AbsR[0][0],r=b.e[1]*AbsR[2][2]+b.e[2]*AbsR[2][1],Math.abs(t[1]*R[0][0]-t[0]*R[1][0])>i+r||(i=a.e[0]*AbsR[1][1]+a.e[1]*AbsR[0][1],r=b.e[0]*AbsR[2][2]+b.e[2]*AbsR[2][0],Math.abs(t[1]*R[0][1]-t[0]*R[1][1])>i+r||(i=a.e[0]*AbsR[1][2]+a.e[1]*AbsR[0][2],r=b.e[0]*AbsR[2][1]+b.e[1]*AbsR[2][0],Math.abs(t[1]*R[0][2]-t[0]*R[1][2])>i+r)))))))))}intersectsPlane(t){this.rotation.extractBasis(xAxis,yAxis,zAxis);const e=this.halfSize.x*Math.abs(t.normal.dot(xAxis))+this.halfSize.y*Math.abs(t.normal.dot(yAxis))+this.halfSize.z*Math.abs(t.normal.dot(zAxis)),s=t.normal.dot(this.center)-t.constant;return Math.abs(s)<=e}intersectRay(t,e){return this.getSize(size),aabb.setFromCenterAndSize(v1.set(0,0,0),size),matrix.setFromMatrix3(this.rotation),matrix.setPosition(this.center),inverse.copy(matrix).invert(),localRay.copy(t).applyMatrix4(inverse),localRay.intersectBox(aabb,e)?e.applyMatrix4(matrix):null}intersectsRay(t){return null!==this.intersectRay(t,v1)}fromBox3(t){return t.getCenter(this.center),t.getSize(this.halfSize).multiplyScalar(.5),this.rotation.identity(),this}equals(t){return t.center.equals(this.center)&&t.halfSize.equals(this.halfSize)&&t.rotation.equals(this.rotation)}applyMatrix4(t){const e=t.elements;let s=v1.set(e[0],e[1],e[2]).length();const a=v1.set(e[4],e[5],e[6]).length(),i=v1.set(e[8],e[9],e[10]).length();t.determinant()<0&&(s=-s),rotationMatrix.setFromMatrix4(t);const r=1/s,o=1/a,n=1/i;return rotationMatrix.elements[0]*=r,rotationMatrix.elements[1]*=r,rotationMatrix.elements[2]*=r,rotationMatrix.elements[3]*=o,rotationMatrix.elements[4]*=o,rotationMatrix.elements[5]*=o,rotationMatrix.elements[6]*=n,rotationMatrix.elements[7]*=n,rotationMatrix.elements[8]*=n,this.rotation.multiply(rotationMatrix),this.halfSize.x*=s,this.halfSize.y*=a,this.halfSize.z*=i,v1.setFromMatrixPosition(t),this.center.add(v1),this}}const obb=new OBB;export{OBB};