import{Box3,Line3,Plane,Sphere,Triangle,Vector3}from"three";import{Capsule}from"../math/Capsule.js";const _v1=new Vector3,_v2=new Vector3,_plane=new Plane,_line1=new Line3,_line2=new Line3,_sphere=new Sphere,_capsule=new Capsule;class Octree{constructor(e){this.triangles=[],this.box=e,this.subTrees=[]}addTriangle(e){return this.bounds||(this.bounds=new Box3),this.bounds.min.x=Math.min(this.bounds.min.x,e.a.x,e.b.x,e.c.x),this.bounds.min.y=Math.min(this.bounds.min.y,e.a.y,e.b.y,e.c.y),this.bounds.min.z=Math.min(this.bounds.min.z,e.a.z,e.b.z,e.c.z),this.bounds.max.x=Math.max(this.bounds.max.x,e.a.x,e.b.x,e.c.x),this.bounds.max.y=Math.max(this.bounds.max.y,e.a.y,e.b.y,e.c.y),this.bounds.max.z=Math.max(this.bounds.max.z,e.a.z,e.b.z,e.c.z),this.triangles.push(e),this}calcBox(){return this.box=this.bounds.clone(),this.box.min.x-=.01,this.box.min.y-=.01,this.box.min.z-=.01,this}split(e){if(!this.box)return;const t=[],n=_v2.copy(this.box.max).sub(this.box.min).multiplyScalar(.5);for(let e=0;e<2;e++)for(let s=0;s<2;s++)for(let r=0;r<2;r++){const i=new Box3,a=_v1.set(e,s,r);i.min.copy(this.box.min).add(a.multiply(n)),i.max.copy(i.min).add(n),t.push(new Octree(i))}let s;for(;s=this.triangles.pop();)for(let e=0;e<t.length;e++)t[e].box.intersectsTriangle(s)&&t[e].triangles.push(s);for(let n=0;n<t.length;n++){const s=t[n].triangles.length;s>8&&e<16&&t[n].split(e+1),0!==s&&this.subTrees.push(t[n])}return this}build(){return this.calcBox(),this.split(0),this}getRayTriangles(e,t){for(let n=0;n<this.subTrees.length;n++){const s=this.subTrees[n];if(e.intersectsBox(s.box))if(s.triangles.length>0)for(let e=0;e<s.triangles.length;e++)-1===t.indexOf(s.triangles[e])&&t.push(s.triangles[e]);else s.getRayTriangles(e,t)}return t}triangleCapsuleIntersect(e,t){t.getPlane(_plane);const n=_plane.distanceToPoint(e.start)-e.radius,s=_plane.distanceToPoint(e.end)-e.radius;if(n>0&&s>0||n<-e.radius&&s<-e.radius)return!1;const r=Math.abs(n/(Math.abs(n)+Math.abs(s))),i=_v1.copy(e.start).lerp(e.end,r);if(t.containsPoint(i))return{normal:_plane.normal.clone(),point:i.clone(),depth:Math.abs(Math.min(n,s))};const a=e.radius*e.radius,l=_line1.set(e.start,e.end),o=[[t.a,t.b],[t.b,t.c],[t.c,t.a]];for(let t=0;t<o.length;t++){const n=_line2.set(o[t][0],o[t][1]),[s,r]=e.lineLineMinimumPoints(l,n);if(s.distanceToSquared(r)<a)return{normal:s.clone().sub(r).normalize(),point:r.clone(),depth:e.radius-s.distanceTo(r)}}return!1}triangleSphereIntersect(e,t){if(t.getPlane(_plane),!e.intersectsPlane(_plane))return!1;const n=Math.abs(_plane.distanceToSphere(e)),s=e.radius*e.radius-n*n,r=_plane.projectPoint(e.center,_v1);if(t.containsPoint(e.center))return{normal:_plane.normal.clone(),point:r.clone(),depth:Math.abs(_plane.distanceToSphere(e))};const i=[[t.a,t.b],[t.b,t.c],[t.c,t.a]];for(let t=0;t<i.length;t++){_line1.set(i[t][0],i[t][1]),_line1.closestPointToPoint(r,!0,_v2);const n=_v2.distanceToSquared(e.center);if(n<s)return{normal:e.center.clone().sub(_v2).normalize(),point:_v2.clone(),depth:e.radius-Math.sqrt(n)}}return!1}getSphereTriangles(e,t){for(let n=0;n<this.subTrees.length;n++){const s=this.subTrees[n];if(e.intersectsBox(s.box))if(s.triangles.length>0)for(let e=0;e<s.triangles.length;e++)-1===t.indexOf(s.triangles[e])&&t.push(s.triangles[e]);else s.getSphereTriangles(e,t)}}getCapsuleTriangles(e,t){for(let n=0;n<this.subTrees.length;n++){const s=this.subTrees[n];if(e.intersectsBox(s.box))if(s.triangles.length>0)for(let e=0;e<s.triangles.length;e++)-1===t.indexOf(s.triangles[e])&&t.push(s.triangles[e]);else s.getCapsuleTriangles(e,t)}}sphereIntersect(e){_sphere.copy(e);const t=[];let n,s=!1;this.getSphereTriangles(e,t);for(let e=0;e<t.length;e++)(n=this.triangleSphereIntersect(_sphere,t[e]))&&(s=!0,_sphere.center.add(n.normal.multiplyScalar(n.depth)));if(s){const t=_sphere.center.clone().sub(e.center),n=t.length();return{normal:t.normalize(),depth:n}}return!1}capsuleIntersect(e){_capsule.copy(e);const t=[];let n,s=!1;this.getCapsuleTriangles(_capsule,t);for(let e=0;e<t.length;e++)(n=this.triangleCapsuleIntersect(_capsule,t[e]))&&(s=!0,_capsule.translate(n.normal.multiplyScalar(n.depth)));if(s){const t=_capsule.getCenter(new Vector3).sub(e.getCenter(_v1)),n=t.length();return{normal:t.normalize(),depth:n}}return!1}rayIntersect(e){if(0===e.direction.length())return;const t=[];let n,s,r=1e100;this.getRayTriangles(e,t);for(let i=0;i<t.length;i++){const a=e.intersectTriangle(t[i].a,t[i].b,t[i].c,!0,_v1);if(a){const l=a.sub(e.origin).length();r>l&&(s=a.clone().add(e.origin),r=l,n=t[i])}}return r<1e100&&{distance:r,triangle:n,position:s}}fromGraphNode(e){return e.updateWorldMatrix(!0,!0),e.traverse((e=>{if(!0===e.isMesh){let t,n=!1;null!==e.geometry.index?(n=!0,t=e.geometry.toNonIndexed()):t=e.geometry;const s=t.getAttribute("position");for(let t=0;t<s.count;t+=3){const n=(new Vector3).fromBufferAttribute(s,t),r=(new Vector3).fromBufferAttribute(s,t+1),i=(new Vector3).fromBufferAttribute(s,t+2);n.applyMatrix4(e.matrixWorld),r.applyMatrix4(e.matrixWorld),i.applyMatrix4(e.matrixWorld),this.addTriangle(new Triangle(n,r,i))}n&&t.dispose()}})),this.build(),this}}export{Octree};