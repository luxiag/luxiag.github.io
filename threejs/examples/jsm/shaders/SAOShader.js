import{Matrix4,Vector2}from"three";const SAOShader={defines:{NUM_SAMPLES:7,NUM_RINGS:4,NORMAL_TEXTURE:0,DIFFUSE_TEXTURE:0,DEPTH_PACKING:1,PERSPECTIVE_CAMERA:1},uniforms:{tDepth:{value:null},tDiffuse:{value:null},tNormal:{value:null},size:{value:new Vector2(512,512)},cameraNear:{value:1},cameraFar:{value:100},cameraProjectionMatrix:{value:new Matrix4},cameraInverseProjectionMatrix:{value:new Matrix4},scale:{value:1},intensity:{value:.1},bias:{value:.5},minResolution:{value:0},kernelRadius:{value:100},randomSeed:{value:0}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}",fragmentShader:"\n\n\t\t#include <common>\n\n\t\tvarying vec2 vUv;\n\n\t\t#if DIFFUSE_TEXTURE == 1\n\t\tuniform sampler2D tDiffuse;\n\t\t#endif\n\n\t\tuniform sampler2D tDepth;\n\n\t\t#if NORMAL_TEXTURE == 1\n\t\tuniform sampler2D tNormal;\n\t\t#endif\n\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\t\tuniform mat4 cameraProjectionMatrix;\n\t\tuniform mat4 cameraInverseProjectionMatrix;\n\n\t\tuniform float scale;\n\t\tuniform float intensity;\n\t\tuniform float bias;\n\t\tuniform float kernelRadius;\n\t\tuniform float minResolution;\n\t\tuniform vec2 size;\n\t\tuniform float randomSeed;\n\n\t\t// RGBA depth\n\n\t\t#include <packing>\n\n\t\tvec4 getDefaultColor( const in vec2 screenPosition ) {\n\t\t\t#if DIFFUSE_TEXTURE == 1\n\t\t\treturn texture2D( tDiffuse, vUv );\n\t\t\t#else\n\t\t\treturn vec4( 1.0 );\n\t\t\t#endif\n\t\t}\n\n\t\tfloat getDepth( const in vec2 screenPosition ) {\n\t\t\t#if DEPTH_PACKING == 1\n\t\t\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\n\t\t\t#else\n\t\t\treturn texture2D( tDepth, screenPosition ).x;\n\t\t\t#endif\n\t\t}\n\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\t\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\t\t\t#else\n\t\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\t\t\t#endif\n\t\t}\n\n\t\tvec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\n\t\t\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\n\t\t\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\n\t\t\tclipPosition *= clipW; // unprojection.\n\n\t\t\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\n\t\t}\n\n\t\tvec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {\n\t\t\t#if NORMAL_TEXTURE == 1\n\t\t\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\n\t\t\t#else\n\t\t\treturn normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );\n\t\t\t#endif\n\t\t}\n\n\t\tfloat scaleDividedByCameraFar;\n\t\tfloat minResolutionMultipliedByCameraFar;\n\n\t\tfloat getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {\n\t\t\tvec3 viewDelta = sampleViewPosition - centerViewPosition;\n\t\t\tfloat viewDistance = length( viewDelta );\n\t\t\tfloat scaledScreenDistance = scaleDividedByCameraFar * viewDistance;\n\n\t\t\treturn max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );\n\t\t}\n\n\t\t// moving costly divides into consts\n\t\tconst float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\n\t\tconst float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );\n\n\t\tfloat getAmbientOcclusion( const in vec3 centerViewPosition ) {\n\t\t\t// precompute some variables require in getOcclusion.\n\t\t\tscaleDividedByCameraFar = scale / cameraFar;\n\t\t\tminResolutionMultipliedByCameraFar = minResolution * cameraFar;\n\t\t\tvec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );\n\n\t\t\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\n\t\t\tfloat angle = rand( vUv + randomSeed ) * PI2;\n\t\t\tvec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;\n\t\t\tvec2 radiusStep = radius;\n\n\t\t\tfloat occlusionSum = 0.0;\n\t\t\tfloat weightSum = 0.0;\n\n\t\t\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {\n\t\t\t\tvec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;\n\t\t\t\tradius += radiusStep;\n\t\t\t\tangle += ANGLE_STEP;\n\n\t\t\t\tfloat sampleDepth = getDepth( sampleUv );\n\t\t\t\tif( sampleDepth >= ( 1.0 - EPSILON ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfloat sampleViewZ = getViewZ( sampleDepth );\n\t\t\t\tvec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );\n\t\t\t\tocclusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );\n\t\t\t\tweightSum += 1.0;\n\t\t\t}\n\n\t\t\tif( weightSum == 0.0 ) discard;\n\n\t\t\treturn occlusionSum * ( intensity / weightSum );\n\t\t}\n\n\t\tvoid main() {\n\t\t\tfloat centerDepth = getDepth( vUv );\n\t\t\tif( centerDepth >= ( 1.0 - EPSILON ) ) {\n\t\t\t\tdiscard;\n\t\t\t}\n\n\t\t\tfloat centerViewZ = getViewZ( centerDepth );\n\t\t\tvec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );\n\n\t\t\tfloat ambientOcclusion = getAmbientOcclusion( viewPosition );\n\n\t\t\tgl_FragColor = getDefaultColor( vUv );\n\t\t\tgl_FragColor.xyz *=  1.0 - ambientOcclusion;\n\t\t}"};export{SAOShader};