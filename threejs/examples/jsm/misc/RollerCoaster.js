import{BufferAttribute,BufferGeometry,Color,Quaternion,Raycaster,SRGBColorSpace,Vector3}from"three";class RollerCoasterGeometry extends BufferGeometry{constructor(t,e){super();const o=[],n=[],r=[],s=[1,1,1],a=[1,1,0],p=new Vector3(0,1,0),c=new Vector3,u=new Vector3,y=new Quaternion,i=new Quaternion;i.setFromAxisAngle(p,Math.PI/2);const h=new Vector3,l=new Vector3;l.copy(t.getPointAt(0));const w=[new Vector3(-.225,0,0),new Vector3(0,-.05,0),new Vector3(0,-.175,0),new Vector3(0,-.05,0),new Vector3(.225,0,0),new Vector3(0,-.175,0)],d=2*Math.PI;let V=5;const f=[];for(let t=0;t<V;t++){const e=t/V*d;f.push(new Vector3(.06*Math.sin(e),.06*Math.cos(e),0))}V=6;const x=[];for(let t=0;t<V;t++){const e=t/V*d;x.push(new Vector3(.025*Math.sin(e),.025*Math.cos(e),0))}const z=new Vector3,m=new Vector3;function A(t,e){m.set(0,0,-1).applyQuaternion(y);for(let s=0;s<t.length;s++)z.copy(t[s]),z.applyQuaternion(y),z.add(h),o.push(z.x,z.y,z.z),n.push(m.x,m.y,m.z),r.push(e[0],e[1],e[2]);m.set(0,0,1).applyQuaternion(y);for(let s=t.length-1;s>=0;s--)z.copy(t[s]),z.applyQuaternion(y),z.add(h),o.push(z.x,z.y,z.z),n.push(m.x,m.y,m.z),r.push(e[0],e[1],e[2])}const Q=new Vector3,M=new Vector3,b=new Vector3,g=new Vector3,B=new Vector3,G=new Vector3,F=new Vector3,P=new Vector3;function R(t,e,s){for(let a=0,p=t.length;a<p;a++){const c=t[a],u=t[(a+1)%p];Q.copy(c).add(e),Q.applyQuaternion(y),Q.add(h),M.copy(u).add(e),M.applyQuaternion(y),M.add(h),b.copy(u).add(e),b.applyQuaternion(i),b.add(l),g.copy(c).add(e),g.applyQuaternion(i),g.add(l),o.push(Q.x,Q.y,Q.z),o.push(M.x,M.y,M.z),o.push(g.x,g.y,g.z),o.push(M.x,M.y,M.z),o.push(b.x,b.y,b.z),o.push(g.x,g.y,g.z),B.copy(c),B.applyQuaternion(y),B.normalize(),G.copy(u),G.applyQuaternion(y),G.normalize(),F.copy(u),F.applyQuaternion(i),F.normalize(),P.copy(c),P.applyQuaternion(i),P.normalize(),n.push(B.x,B.y,B.z),n.push(G.x,G.y,G.z),n.push(P.x,P.y,P.z),n.push(G.x,G.y,G.z),n.push(F.x,F.y,F.z),n.push(P.x,P.y,P.z),r.push(s[0],s[1],s[2]),r.push(s[0],s[1],s[2]),r.push(s[0],s[1],s[2]),r.push(s[0],s[1],s[2]),r.push(s[0],s[1],s[2]),r.push(s[0],s[1],s[2])}}const C=new Vector3;for(let o=1;o<=e;o++){h.copy(t.getPointAt(o/e)),p.set(0,1,0),c.subVectors(h,l).normalize(),u.crossVectors(p,c).normalize(),p.crossVectors(c,u);const n=Math.atan2(c.x,c.z);y.setFromAxisAngle(p,n),o%2==0&&A(w,a),R(f,C.set(0,-.125,0),a),R(x,C.set(.2,0,0),s),R(x,C.set(-.2,0,0),s),l.copy(h),i.copy(y)}this.setAttribute("position",new BufferAttribute(new Float32Array(o),3)),this.setAttribute("normal",new BufferAttribute(new Float32Array(n),3)),this.setAttribute("color",new BufferAttribute(new Float32Array(r),3))}}class RollerCoasterLiftersGeometry extends BufferGeometry{constructor(t,e){super();const o=[],n=[],r=new Quaternion,s=new Vector3(0,1,0),a=new Vector3,p=new Vector3,c=[new Vector3(0,.05,-.05),new Vector3(0,.05,.05),new Vector3(0,-.05,0)],u=[new Vector3(-.05,0,.05),new Vector3(-.05,0,-.05),new Vector3(.05,0,0)],y=[new Vector3(.05,0,-.05),new Vector3(.05,0,.05),new Vector3(-.05,0,0)],i=new Vector3,h=new Vector3,l=new Vector3,w=new Vector3,d=new Vector3,V=new Vector3,f=new Vector3,x=new Vector3;function z(t,e,s){for(let a=0,p=t.length;a<p;a++){const c=t[a],u=t[(a+1)%p];i.copy(c),i.applyQuaternion(r),i.add(e),h.copy(u),h.applyQuaternion(r),h.add(e),l.copy(u),l.applyQuaternion(r),l.add(s),w.copy(c),w.applyQuaternion(r),w.add(s),o.push(i.x,i.y,i.z),o.push(h.x,h.y,h.z),o.push(w.x,w.y,w.z),o.push(h.x,h.y,h.z),o.push(l.x,l.y,l.z),o.push(w.x,w.y,w.z),d.copy(c),d.applyQuaternion(r),d.normalize(),V.copy(u),V.applyQuaternion(r),V.normalize(),f.copy(u),f.applyQuaternion(r),f.normalize(),x.copy(c),x.applyQuaternion(r),x.normalize(),n.push(d.x,d.y,d.z),n.push(V.x,V.y,V.z),n.push(x.x,x.y,x.z),n.push(V.x,V.y,V.z),n.push(f.x,f.y,f.z),n.push(x.x,x.y,x.z)}}const m=new Vector3,A=new Vector3;for(let o=1;o<=e;o++){a.copy(t.getPointAt(o/e)),p.copy(t.getTangentAt(o/e));const n=Math.atan2(p.x,p.z);r.setFromAxisAngle(s,n),a.y>10?(m.set(-.75,-.35,0),m.applyQuaternion(r),m.add(a),A.set(.75,-.35,0),A.applyQuaternion(r),A.add(a),z(c,m,A),m.set(-.7,-.3,0),m.applyQuaternion(r),m.add(a),A.set(-.7,-a.y,0),A.applyQuaternion(r),A.add(a),z(u,m,A),m.set(.7,-.3,0),m.applyQuaternion(r),m.add(a),A.set(.7,-a.y,0),A.applyQuaternion(r),A.add(a),z(y,m,A)):(m.set(0,-.2,0),m.applyQuaternion(r),m.add(a),A.set(0,-a.y,0),A.applyQuaternion(r),A.add(a),z(y,m,A))}this.setAttribute("position",new BufferAttribute(new Float32Array(o),3)),this.setAttribute("normal",new BufferAttribute(new Float32Array(n),3))}}class RollerCoasterShadowGeometry extends BufferGeometry{constructor(t,e){super();const o=[],n=new Vector3(0,1,0),r=new Vector3,s=new Quaternion,a=new Quaternion;a.setFromAxisAngle(n,Math.PI/2);const p=new Vector3,c=new Vector3;c.copy(t.getPointAt(0)),c.y=0;const u=new Vector3,y=new Vector3,i=new Vector3,h=new Vector3;for(let l=1;l<=e;l++){p.copy(t.getPointAt(l/e)),p.y=0,r.subVectors(p,c);const w=Math.atan2(r.x,r.z);s.setFromAxisAngle(n,w),u.set(-.3,0,0),u.applyQuaternion(s),u.add(p),y.set(.3,0,0),y.applyQuaternion(s),y.add(p),i.set(.3,0,0),i.applyQuaternion(a),i.add(c),h.set(-.3,0,0),h.applyQuaternion(a),h.add(c),o.push(u.x,u.y,u.z),o.push(y.x,y.y,y.z),o.push(h.x,h.y,h.z),o.push(y.x,y.y,y.z),o.push(i.x,i.y,i.z),o.push(h.x,h.y,h.z),c.copy(p),a.copy(s)}this.setAttribute("position",new BufferAttribute(new Float32Array(o),3))}}class SkyGeometry extends BufferGeometry{constructor(){super();const t=[];for(let e=0;e<100;e++){const e=800*Math.random()-400,o=50*Math.random()+50,n=800*Math.random()-400,r=40*Math.random()+20;t.push(e-r,o,n-r),t.push(e+r,o,n-r),t.push(e-r,o,n+r),t.push(e+r,o,n-r),t.push(e+r,o,n+r),t.push(e-r,o,n+r)}this.setAttribute("position",new BufferAttribute(new Float32Array(t),3))}}class TreesGeometry extends BufferGeometry{constructor(t){super();const e=[],o=[],n=new Raycaster;n.ray.direction.set(0,-1,0);const r=new Color;for(let s=0;s<2e3;s++){const s=500*Math.random()-250,a=500*Math.random()-250;n.ray.origin.set(s,50,a);const p=n.intersectObject(t);if(0===p.length)continue;const c=p[0].point.y,u=5*Math.random()+.5;let y=Math.random()*Math.PI*2;e.push(s+Math.sin(y),c,a+Math.cos(y)),e.push(s,c+u,a),e.push(s+Math.sin(y+Math.PI),c,a+Math.cos(y+Math.PI)),y+=Math.PI/2,e.push(s+Math.sin(y),c,a+Math.cos(y)),e.push(s,c+u,a),e.push(s+Math.sin(y+Math.PI),c,a+Math.cos(y+Math.PI));const i=.1*Math.random();for(let t=0;t<6;t++)r.setRGB(.2+i,.4+i,0,SRGBColorSpace),o.push(r.r,r.g,r.b)}this.setAttribute("position",new BufferAttribute(new Float32Array(e),3)),this.setAttribute("color",new BufferAttribute(new Float32Array(o),3))}}export{RollerCoasterGeometry,RollerCoasterLiftersGeometry,RollerCoasterShadowGeometry,SkyGeometry,TreesGeometry};