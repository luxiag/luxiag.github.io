import{MathUtils,Mesh}from"three";class MorphBlendMesh extends Mesh{constructor(t,i){super(t,i),this.animationsMap={},this.animationsList=[];const n=Object.keys(this.morphTargetDictionary).length,a="__default",e=n-1,s=n/1;this.createAnimation(a,0,e,s),this.setAnimationWeight(a,1)}createAnimation(t,i,n,a){const e={start:i,end:n,length:n-i+1,fps:a,duration:(n-i)/a,lastFrame:0,currentFrame:0,active:!1,time:0,direction:1,weight:1,directionBackwards:!1,mirroredLoop:!1};this.animationsMap[t]=e,this.animationsList.push(e)}autoCreateAnimations(t){const i=/([a-z]+)_?(\d+)/i;let n;const a={};let e=0;for(const t in this.morphTargetDictionary){const s=t.match(i);if(s&&s.length>1){const t=s[1];a[t]||(a[t]={start:1/0,end:-1/0});const i=a[t];e<i.start&&(i.start=e),e>i.end&&(i.end=e),n||(n=t)}e++}for(const i in a){const n=a[i];this.createAnimation(i,n.start,n.end,t)}this.firstAnimation=n}setAnimationDirectionForward(t){const i=this.animationsMap[t];i&&(i.direction=1,i.directionBackwards=!1)}setAnimationDirectionBackward(t){const i=this.animationsMap[t];i&&(i.direction=-1,i.directionBackwards=!0)}setAnimationFPS(t,i){const n=this.animationsMap[t];n&&(n.fps=i,n.duration=(n.end-n.start)/n.fps)}setAnimationDuration(t,i){const n=this.animationsMap[t];n&&(n.duration=i,n.fps=(n.end-n.start)/n.duration)}setAnimationWeight(t,i){const n=this.animationsMap[t];n&&(n.weight=i)}setAnimationTime(t,i){const n=this.animationsMap[t];n&&(n.time=i)}getAnimationTime(t){let i=0;const n=this.animationsMap[t];return n&&(i=n.time),i}getAnimationDuration(t){let i=-1;const n=this.animationsMap[t];return n&&(i=n.duration),i}playAnimation(t){const i=this.animationsMap[t];i?(i.time=0,i.active=!0):console.warn("THREE.MorphBlendMesh: animation["+t+"] undefined in .playAnimation()")}stopAnimation(t){const i=this.animationsMap[t];i&&(i.active=!1)}update(t){for(let i=0,n=this.animationsList.length;i<n;i++){const n=this.animationsList[i];if(!n.active)continue;const a=n.duration/n.length;n.time+=n.direction*t,n.mirroredLoop?(n.time>n.duration||n.time<0)&&(n.direction*=-1,n.time>n.duration&&(n.time=n.duration,n.directionBackwards=!0),n.time<0&&(n.time=0,n.directionBackwards=!1)):(n.time=n.time%n.duration,n.time<0&&(n.time+=n.duration));const e=n.start+MathUtils.clamp(Math.floor(n.time/a),0,n.length-1),s=n.weight;e!==n.currentFrame&&(this.morphTargetInfluences[n.lastFrame]=0,this.morphTargetInfluences[n.currentFrame]=1*s,this.morphTargetInfluences[e]=0,n.lastFrame=n.currentFrame,n.currentFrame=e);let r=n.time%a/a;n.directionBackwards&&(r=1-r),n.currentFrame!==n.lastFrame?(this.morphTargetInfluences[n.currentFrame]=r*s,this.morphTargetInfluences[n.lastFrame]=(1-r)*s):this.morphTargetInfluences[n.currentFrame]=s}}}export{MorphBlendMesh};