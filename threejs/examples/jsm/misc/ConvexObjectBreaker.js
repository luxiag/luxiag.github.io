import{Line3,Mesh,Plane,Vector3}from"three";import{ConvexGeometry}from"../geometries/ConvexGeometry.js";const _v1=new Vector3;class ConvexObjectBreaker{constructor(e=1.4,t=1e-4){this.minSizeForBreak=e,this.smallDelta=t,this.tempLine1=new Line3,this.tempPlane1=new Plane,this.tempPlane2=new Plane,this.tempPlane_Cut=new Plane,this.tempCM1=new Vector3,this.tempCM2=new Vector3,this.tempVector3=new Vector3,this.tempVector3_2=new Vector3,this.tempVector3_3=new Vector3,this.tempVector3_P0=new Vector3,this.tempVector3_P1=new Vector3,this.tempVector3_P2=new Vector3,this.tempVector3_N0=new Vector3,this.tempVector3_N1=new Vector3,this.tempVector3_AB=new Vector3,this.tempVector3_CB=new Vector3,this.tempResultObjects={object1:null,object2:null},this.segments=[];for(let e=0;e<900;e++)this.segments[e]=!1}prepareBreakableObject(e,t,o,s,n){const r=e.userData;r.mass=t,r.velocity=o.clone(),r.angularVelocity=s.clone(),r.breakable=n}subdivideByImpact(e,t,o,s,n){const r=[],i=this.tempPlane1,a=this.tempPlane2;this.tempVector3.addVectors(t,o),i.setFromCoplanarPoints(t,e.position,this.tempVector3);const c=n+s,l=this;return function n(m,p,h,u){if(Math.random()<.05*u||u>c)return void r.push(m);let V=Math.PI;0===u?(a.normal.copy(i.normal),a.constant=i.constant):u<=s?(V=(h-p)*(.2+.6*Math.random())+p,l.tempVector3_2.copy(e.position).sub(t).applyAxisAngle(o,V).add(t),a.setFromCoplanarPoints(t,l.tempVector3,l.tempVector3_2)):(V=(.5*(1&u)+.2*(2-Math.random()))*Math.PI,l.tempVector3_2.copy(t).sub(m.position).applyAxisAngle(o,V).add(m.position),l.tempVector3_3.copy(o).add(m.position),a.setFromCoplanarPoints(m.position,l.tempVector3_3,l.tempVector3_2)),l.cutByPlane(m,a,l.tempResultObjects);const d=l.tempResultObjects.object1,y=l.tempResultObjects.object2;d&&n(d,p,V,u+1),y&&n(y,V,h,u+1)}(e,0,2*Math.PI,0),r}cutByPlane(e,t,o){const s=e.geometry,n=s.attributes.position.array,r=s.attributes.normal.array,i=n.length/3;let a=i/3,c=s.getIndex();function l(e,t){const o=3*e+t;return c?c[o]:o}c&&(c=c.array,a=c.length/3);const m=[],p=[],h=this.smallDelta,u=i*i;for(let e=0;e<u;e++)this.segments[e]=!1;const V=this.tempVector3_P0,d=this.tempVector3_P1,y=this.tempVector3_N0,b=this.tempVector3_N1;for(let e=0;e<a-1;e++){const t=l(e,0),o=l(e,1),s=l(e,2);y.set(r[t],r[t]+1,r[t]+2);for(let n=e+1;n<a;n++){const e=l(n,0),a=l(n,1),c=l(n,2);b.set(r[e],r[e]+1,r[e]+2),1-y.dot(b)<h&&(t===e||t===a||t===c?o===e||o===a||o===c?(this.segments[t*i+o]=!0,this.segments[o*i+t]=!0):(this.segments[s*i+t]=!0,this.segments[t*i+s]=!0):o!==e&&o!==a&&o!==c||(this.segments[s*i+o]=!0,this.segments[o*i+s]=!0))}}const C=this.tempPlane_Cut;e.updateMatrix(),ConvexObjectBreaker.transformPlaneToLocalSpace(t,e.matrix,C);for(let e=0;e<a;e++){const t=l(e,0),s=l(e,1),r=l(e,2);for(let e=0;e<3;e++){const a=0===e?t:1===e?s:r,c=0===e?s:1===e?r:t;if(this.segments[a*i+c])continue;this.segments[a*i+c]=!0,this.segments[c*i+a]=!0,V.set(n[3*a],n[3*a+1],n[3*a+2]),d.set(n[3*c],n[3*c+1],n[3*c+2]);let l=0,u=C.distanceToPoint(V);u>h?(l=2,p.push(V.clone())):u<-h?(l=1,m.push(V.clone())):(l=3,m.push(V.clone()),p.push(V.clone()));let y=0;if(u=C.distanceToPoint(d),u>h?(y=2,p.push(d.clone())):u<-h?(y=1,m.push(d.clone())):(y=3,m.push(d.clone()),p.push(d.clone())),1===l&&2===y||2===l&&1===y){this.tempLine1.start.copy(V),this.tempLine1.end.copy(d);let e=new Vector3;if(e=C.intersectLine(this.tempLine1,e),null===e)return console.error("Internal error: segment does not intersect plane."),o.segmentedObject1=null,o.segmentedObject2=null,0;m.push(e),p.push(e.clone())}}}const P=.5*e.userData.mass;this.tempCM1.set(0,0,0);let f=0;const g=m.length;if(g>0){for(let e=0;e<g;e++)this.tempCM1.add(m[e]);this.tempCM1.divideScalar(g);for(let e=0;e<g;e++){const t=m[e];t.sub(this.tempCM1),f=Math.max(f,t.x,t.y,t.z)}this.tempCM1.add(e.position)}this.tempCM2.set(0,0,0);let M=0;const x=p.length;if(x>0){for(let e=0;e<x;e++)this.tempCM2.add(p[e]);this.tempCM2.divideScalar(x);for(let e=0;e<x;e++){const t=p[e];t.sub(this.tempCM2),M=Math.max(M,t.x,t.y,t.z)}this.tempCM2.add(e.position)}let _=null,v=null,w=0;return g>4&&(_=new Mesh(new ConvexGeometry(m),e.material),_.position.copy(this.tempCM1),_.quaternion.copy(e.quaternion),this.prepareBreakableObject(_,P,e.userData.velocity,e.userData.angularVelocity,2*f>this.minSizeForBreak),w++),x>4&&(v=new Mesh(new ConvexGeometry(p),e.material),v.position.copy(this.tempCM2),v.quaternion.copy(e.quaternion),this.prepareBreakableObject(v,P,e.userData.velocity,e.userData.angularVelocity,2*M>this.minSizeForBreak),w++),o.object1=_,o.object2=v,w}static transformFreeVector(e,t){const o=e.x,s=e.y,n=e.z,r=t.elements;return e.x=r[0]*o+r[4]*s+r[8]*n,e.y=r[1]*o+r[5]*s+r[9]*n,e.z=r[2]*o+r[6]*s+r[10]*n,e}static transformFreeVectorInverse(e,t){const o=e.x,s=e.y,n=e.z,r=t.elements;return e.x=r[0]*o+r[1]*s+r[2]*n,e.y=r[4]*o+r[5]*s+r[6]*n,e.z=r[8]*o+r[9]*s+r[10]*n,e}static transformTiedVectorInverse(e,t){const o=e.x,s=e.y,n=e.z,r=t.elements;return e.x=r[0]*o+r[1]*s+r[2]*n-r[12],e.y=r[4]*o+r[5]*s+r[6]*n-r[13],e.z=r[8]*o+r[9]*s+r[10]*n-r[14],e}static transformPlaneToLocalSpace(e,t,o){o.normal.copy(e.normal),o.constant=e.constant;const s=ConvexObjectBreaker.transformTiedVectorInverse(e.coplanarPoint(_v1),t);ConvexObjectBreaker.transformFreeVectorInverse(o.normal,t),o.constant=-s.dot(o.normal)}}export{ConvexObjectBreaker};