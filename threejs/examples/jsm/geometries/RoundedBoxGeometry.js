import{BoxGeometry,Vector3}from"three";const _tempNormal=new Vector3;function getUv(t,e,r,a,o,s){const n=2*Math.PI*o/4,i=Math.max(s-2*o,0),c=Math.PI/4;_tempNormal.copy(e),_tempNormal[a]=0,_tempNormal.normalize();const m=.5*n/(n+i),h=1-_tempNormal.angleTo(t)/c;return 1===Math.sign(_tempNormal[r])?h*m:i/(n+i)+m+m*(1-h)}class RoundedBoxGeometry extends BoxGeometry{constructor(t=1,e=1,r=1,a=2,o=.1){if(a=2*a+1,o=Math.min(t/2,e/2,r/2,o),super(1,1,1,a,a,a),1===a)return;const s=this.toNonIndexed();this.index=null,this.attributes.position=s.attributes.position,this.attributes.normal=s.attributes.normal,this.attributes.uv=s.attributes.uv;const n=new Vector3,i=new Vector3,c=new Vector3(t,e,r).divideScalar(2).subScalar(o),m=this.attributes.position.array,h=this.attributes.normal.array,y=this.attributes.uv.array,g=m.length/6,x=new Vector3,l=.5/a;for(let a=0,s=0;a<m.length;a+=3,s+=2)switch(n.fromArray(m,a),i.copy(n),i.x-=Math.sign(i.x)*l,i.y-=Math.sign(i.y)*l,i.z-=Math.sign(i.z)*l,i.normalize(),m[a+0]=c.x*Math.sign(n.x)+i.x*o,m[a+1]=c.y*Math.sign(n.y)+i.y*o,m[a+2]=c.z*Math.sign(n.z)+i.z*o,h[a+0]=i.x,h[a+1]=i.y,h[a+2]=i.z,Math.floor(a/g)){case 0:x.set(1,0,0),y[s+0]=getUv(x,i,"z","y",o,r),y[s+1]=1-getUv(x,i,"y","z",o,e);break;case 1:x.set(-1,0,0),y[s+0]=1-getUv(x,i,"z","y",o,r),y[s+1]=1-getUv(x,i,"y","z",o,e);break;case 2:x.set(0,1,0),y[s+0]=1-getUv(x,i,"x","z",o,t),y[s+1]=getUv(x,i,"z","x",o,r);break;case 3:x.set(0,-1,0),y[s+0]=1-getUv(x,i,"x","z",o,t),y[s+1]=1-getUv(x,i,"z","x",o,r);break;case 4:x.set(0,0,1),y[s+0]=1-getUv(x,i,"x","y",o,t),y[s+1]=1-getUv(x,i,"y","x",o,e);break;case 5:x.set(0,0,-1),y[s+0]=getUv(x,i,"x","y",o,t),y[s+1]=1-getUv(x,i,"y","x",o,e)}}}export{RoundedBoxGeometry};