import{Color,Matrix4,Mesh,PerspectiveCamera,ShaderMaterial,UniformsUtils,Vector2,Vector3,WebGLRenderTarget,DepthTexture,UnsignedShortType,NearestFilter,Plane,HalfFloatType}from"three";class ReflectorForSSRPass extends Mesh{constructor(t,e={}){super(t),this.isReflectorForSSRPass=!0,this.type="ReflectorForSSRPass";const r=this,a=void 0!==e.color?new Color(e.color):new Color(8355711),n=e.textureWidth||512,o=e.textureHeight||512,i=e.clipBias||0,l=e.shader||ReflectorForSSRPass.ReflectorShader,s=!0===e.useDepthTexture,u=new Vector3(0,1,0),c=new Vector3,d=new Vector3;r.needsUpdate=!1,r.maxDistance=ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value,r.opacity=ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value,r.color=a,r.resolution=e.resolution||new Vector2(window.innerWidth,window.innerHeight),r._distanceAttenuation=ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION,Object.defineProperty(r,"distanceAttenuation",{get:()=>r._distanceAttenuation,set(t){r._distanceAttenuation!==t&&(r._distanceAttenuation=t,r.material.defines.DISTANCE_ATTENUATION=t,r.material.needsUpdate=!0)}}),r._fresnel=ReflectorForSSRPass.ReflectorShader.defines.FRESNEL,Object.defineProperty(r,"fresnel",{get:()=>r._fresnel,set(t){r._fresnel!==t&&(r._fresnel=t,r.material.defines.FRESNEL=t,r.material.needsUpdate=!0)}});const f=new Vector3,v=new Vector3,p=new Vector3,m=new Matrix4,x=new Vector3(0,0,-1),h=new Vector3,w=new Vector3,S=new Matrix4,M=new PerspectiveCamera;let P;s&&(P=new DepthTexture,P.type=UnsignedShortType,P.minFilter=NearestFilter,P.magFilter=NearestFilter);const g=new WebGLRenderTarget(n,o,{depthTexture:s?P:null,type:HalfFloatType}),y=new ShaderMaterial({transparent:s,defines:Object.assign({},ReflectorForSSRPass.ReflectorShader.defines,{useDepthTexture:s}),uniforms:UniformsUtils.clone(l.uniforms),fragmentShader:l.fragmentShader,vertexShader:l.vertexShader});y.uniforms.tDiffuse.value=g.texture,y.uniforms.color.value=r.color,y.uniforms.textureMatrix.value=S,s&&(y.uniforms.tDepth.value=g.depthTexture),this.material=y;const R=[new Plane(new Vector3(0,1,0),i)];this.doRender=function(t,e,a){if(y.uniforms.maxDistance.value=r.maxDistance,y.uniforms.color.value=r.color,y.uniforms.opacity.value=r.opacity,c.copy(a.position).normalize(),d.copy(c).reflect(u),y.uniforms.fresnelCoe.value=(c.dot(d)+1)/2,v.setFromMatrixPosition(r.matrixWorld),p.setFromMatrixPosition(a.matrixWorld),m.extractRotation(r.matrixWorld),f.set(0,0,1),f.applyMatrix4(m),h.subVectors(v,p),h.dot(f)>0)return;h.reflect(f).negate(),h.add(v),m.extractRotation(a.matrixWorld),x.set(0,0,-1),x.applyMatrix4(m),x.add(p),w.subVectors(v,x),w.reflect(f).negate(),w.add(v),M.position.copy(h),M.up.set(0,1,0),M.up.applyMatrix4(m),M.up.reflect(f),M.lookAt(w),M.far=a.far,M.updateMatrixWorld(),M.projectionMatrix.copy(a.projectionMatrix),y.uniforms.virtualCameraNear.value=a.near,y.uniforms.virtualCameraFar.value=a.far,y.uniforms.virtualCameraMatrixWorld.value=M.matrixWorld,y.uniforms.virtualCameraProjectionMatrix.value=a.projectionMatrix,y.uniforms.virtualCameraProjectionMatrixInverse.value=a.projectionMatrixInverse,y.uniforms.resolution.value=r.resolution,S.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),S.multiply(M.projectionMatrix),S.multiply(M.matrixWorldInverse),S.multiply(r.matrixWorld);const n=t.getRenderTarget(),o=t.xr.enabled,i=t.shadowMap.autoUpdate,l=t.clippingPlanes;t.xr.enabled=!1,t.shadowMap.autoUpdate=!1,t.clippingPlanes=R,t.setRenderTarget(g),t.state.buffers.depth.setMask(!0),!1===t.autoClear&&t.clear(),t.render(e,M),t.xr.enabled=o,t.shadowMap.autoUpdate=i,t.clippingPlanes=l,t.setRenderTarget(n);const s=a.viewport;void 0!==s&&t.state.viewport(s)},this.getRenderTarget=function(){return g}}}ReflectorForSSRPass.ReflectorShader={defines:{DISTANCE_ATTENUATION:!0,FRESNEL:!0},uniforms:{color:{value:null},tDiffuse:{value:null},tDepth:{value:null},textureMatrix:{value:new Matrix4},maxDistance:{value:180},opacity:{value:.5},fresnelCoe:{value:null},virtualCameraNear:{value:null},virtualCameraFar:{value:null},virtualCameraProjectionMatrix:{value:new Matrix4},virtualCameraMatrixWorld:{value:new Matrix4},virtualCameraProjectionMatrixInverse:{value:new Matrix4},resolution:{value:new Vector2}},vertexShader:"\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\t\tuniform float maxDistance;\n\t\tuniform float opacity;\n\t\tuniform float fresnelCoe;\n\t\tuniform float virtualCameraNear;\n\t\tuniform float virtualCameraFar;\n\t\tuniform mat4 virtualCameraProjectionMatrix;\n\t\tuniform mat4 virtualCameraProjectionMatrixInverse;\n\t\tuniform mat4 virtualCameraMatrixWorld;\n\t\tuniform vec2 resolution;\n\t\tvarying vec4 vUv;\n\t\t#include <packing>\n\t\tfloat blendOverlay( float base, float blend ) {\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\t\t}\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\t\t}\n\t\tfloat getDepth( const in vec2 uv ) {\n\t\t\treturn texture2D( tDepth, uv ).x;\n\t\t}\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\treturn perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );\n\t\t}\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n\t\t\tclipPosition *= clipW; //clip\n\t\t\treturn ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view\n\t\t}\n\t\tvoid main() {\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\t#ifdef useDepthTexture\n\t\t\t\tvec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;\n\t\t\t\tuv.x=1.-uv.x;\n\t\t\t\tfloat depth = texture2DProj( tDepth, vUv ).r;\n\t\t\t\tfloat viewZ = getViewZ( depth );\n\t\t\t\tfloat clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];\n\t\t\t\tvec3 viewPosition=getViewPosition( uv, depth, clipW );\n\t\t\t\tvec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;\n\t\t\t\tif(worldPosition.y>maxDistance) discard;\n\t\t\t\tfloat op=opacity;\n\t\t\t\t#ifdef DISTANCE_ATTENUATION\n\t\t\t\t\tfloat ratio=1.-(worldPosition.y/maxDistance);\n\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t#endif\n\t\t\t\t#ifdef FRESNEL\n\t\t\t\t\top*=fresnelCoe;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\n\t\t\t#else\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\t\t\t#endif\n\t\t}\n\t"};export{ReflectorForSSRPass};