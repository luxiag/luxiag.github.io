import{AdditiveBlending,Box2,BufferGeometry,Color,FramebufferTexture,InterleavedBuffer,InterleavedBufferAttribute,Mesh,MeshBasicMaterial,RawShaderMaterial,Vector2,Vector3,Vector4,RGBAFormat}from"three";class Lensflare extends Mesh{constructor(){super(Lensflare.Geometry,new MeshBasicMaterial({opacity:0,transparent:!0})),this.isLensflare=!0,this.type="Lensflare",this.frustumCulled=!1,this.renderOrder=1/0;const t=new Vector3,e=new Vector3,n=new FramebufferTexture(16,16,RGBAFormat),i=new FramebufferTexture(16,16,RGBAFormat),r=Lensflare.Geometry,o=new RawShaderMaterial({uniforms:{scale:{value:null},screenPosition:{value:null}},vertexShader:"\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}",fragmentShader:"\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );\n\n\t\t\t\t}",depthTest:!0,depthWrite:!1,transparent:!1}),s=new RawShaderMaterial({uniforms:{map:{value:n},scale:{value:null},screenPosition:{value:null}},vertexShader:"\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\t\t\t\tattribute vec2 uv;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUV = uv;\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}",fragmentShader:"\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform sampler2D map;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = texture2D( map, vUV );\n\n\t\t\t\t}",depthTest:!1,depthWrite:!1,transparent:!1}),a=new Mesh(r,o),l=[],c=LensflareElement.Shader,u=new RawShaderMaterial({uniforms:{map:{value:null},occlusionMap:{value:i},color:{value:new Color(16777215)},scale:{value:new Vector2},screenPosition:{value:new Vector3}},vertexShader:c.vertexShader,fragmentShader:c.fragmentShader,blending:AdditiveBlending,transparent:!0,depthWrite:!1}),v=new Mesh(r,u);this.addElement=function(t){l.push(t)};const f=new Vector2,p=new Vector2,m=new Box2,d=new Vector4;this.onBeforeRender=function(c,h,x){c.getCurrentViewport(d);const y=d.w/d.z,b=d.z/2,g=d.w/2;let w=16/d.w;if(f.set(w*y,w),m.min.set(d.x,d.y),m.max.set(d.x+(d.z-16),d.y+(d.w-16)),e.setFromMatrixPosition(this.matrixWorld),e.applyMatrix4(x.matrixWorldInverse),!(e.z>0)&&(t.copy(e).applyMatrix4(x.projectionMatrix),p.x=d.x+t.x*b+b-8,p.y=d.y+t.y*g+g-8,m.containsPoint(p))){c.copyFramebufferToTexture(p,n);let e=o.uniforms;e.scale.value=f,e.screenPosition.value=t,c.renderBufferDirect(x,null,r,o,a,null),c.copyFramebufferToTexture(p,i),e=s.uniforms,e.scale.value=f,e.screenPosition.value=t,c.renderBufferDirect(x,null,r,s,a,null);const m=2*-t.x,h=2*-t.y;for(let e=0,n=l.length;e<n;e++){const n=l[e],i=u.uniforms;i.color.value.copy(n.color),i.map.value=n.texture,i.screenPosition.value.x=t.x+m*n.distance,i.screenPosition.value.y=t.y+h*n.distance,w=n.size/d.w;const o=d.w/d.z;i.scale.value.set(w*o,w),u.uniformsNeedUpdate=!0,c.renderBufferDirect(x,null,r,u,v,null)}}},this.dispose=function(){o.dispose(),s.dispose(),u.dispose(),n.dispose(),i.dispose();for(let t=0,e=l.length;t<e;t++)l[t].texture.dispose()}}}class LensflareElement{constructor(t,e=1,n=0,i=new Color(16777215)){this.texture=t,this.size=e,this.distance=n,this.color=i}}LensflareElement.Shader={uniforms:{map:{value:null},occlusionMap:{value:null},color:{value:null},scale:{value:null},screenPosition:{value:null}},vertexShader:"\n\n\t\tprecision highp float;\n\n\t\tuniform vec3 screenPosition;\n\t\tuniform vec2 scale;\n\n\t\tuniform sampler2D occlusionMap;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvUV = uv;\n\n\t\t\tvec2 pos = position.xy;\n\n\t\t\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\n\n\t\t\tvVisibility =        visibility.r / 9.0;\n\t\t\tvVisibility *= 1.0 - visibility.g / 9.0;\n\t\t\tvVisibility *=       visibility.b / 9.0;\n\n\t\t\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tprecision highp float;\n\n\t\tuniform sampler2D map;\n\t\tuniform vec3 color;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texture = texture2D( map, vUV );\n\t\t\ttexture.a *= vVisibility;\n\t\t\tgl_FragColor = texture;\n\t\t\tgl_FragColor.rgb *= color;\n\n\t\t}"},Lensflare.Geometry=function(){const t=new BufferGeometry,e=new Float32Array([-1,-1,0,0,0,1,-1,0,1,0,1,1,0,1,1,-1,1,0,0,1]),n=new InterleavedBuffer(e,5);return t.setIndex([0,1,2,0,2,3]),t.setAttribute("position",new InterleavedBufferAttribute(n,3,0,!1)),t.setAttribute("uv",new InterleavedBufferAttribute(n,2,3,!1)),t}();export{Lensflare,LensflareElement};