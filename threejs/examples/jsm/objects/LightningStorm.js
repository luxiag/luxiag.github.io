import{MathUtils,Mesh,MeshBasicMaterial,Object3D}from"three";import{LightningStrike}from"../geometries/LightningStrike.js";class LightningStorm extends Object3D{constructor(i={}){super(),this.isLightningStorm=!0,this.stormParams=i,i.size=void 0!==i.size?i.size:1e3,i.minHeight=void 0!==i.minHeight?i.minHeight:80,i.maxHeight=void 0!==i.maxHeight?i.maxHeight:100,i.maxSlope=void 0!==i.maxSlope?i.maxSlope:1.1,i.maxLightnings=void 0!==i.maxLightnings?i.maxLightnings:3,i.lightningMinPeriod=void 0!==i.lightningMinPeriod?i.lightningMinPeriod:3,i.lightningMaxPeriod=void 0!==i.lightningMaxPeriod?i.lightningMaxPeriod:7,i.lightningMinDuration=void 0!==i.lightningMinDuration?i.lightningMinDuration:1,i.lightningMaxDuration=void 0!==i.lightningMaxDuration?i.lightningMaxDuration:2.5,this.lightningParameters=LightningStrike.copyParameters(i.lightningParameters,i.lightningParameters),this.lightningParameters.isEternal=!1,this.lightningMaterial=void 0!==i.lightningMaterial?i.lightningMaterial:new MeshBasicMaterial({color:11599871}),void 0!==i.onRayPosition?this.onRayPosition=i.onRayPosition:this.onRayPosition=function(t,n){n.set((Math.random()-.5)*i.size,0,(Math.random()-.5)*i.size);const s=MathUtils.lerp(i.minHeight,i.maxHeight,Math.random());t.set(i.maxSlope*(2*Math.random()-1),1,i.maxSlope*(2*Math.random()-1)).multiplyScalar(s).add(n)},this.onLightningDown=i.onLightningDown,this.inited=!1,this.nextLightningTime=0,this.lightningsMeshes=[],this.deadLightningsMeshes=[];for(let i=0;i<this.stormParams.maxLightnings;i++){const i=new LightningStrike(LightningStrike.copyParameters({},this.lightningParameters)),t=new Mesh(i,this.lightningMaterial);this.deadLightningsMeshes.push(t)}}update(i){if(this.inited||(this.nextLightningTime=this.getNextLightningTime(i)*Math.random(),this.inited=!0),i>=this.nextLightningTime){const t=this.deadLightningsMeshes.pop();if(t){const n=LightningStrike.copyParameters(t.geometry.rayParameters,this.lightningParameters);n.birthTime=i,n.deathTime=i+MathUtils.lerp(this.stormParams.lightningMinDuration,this.stormParams.lightningMaxDuration,Math.random()),this.onRayPosition(n.sourceOffset,n.destOffset),n.noiseSeed=Math.random(),this.add(t),this.lightningsMeshes.push(t)}this.nextLightningTime=this.getNextLightningTime(i)}let t=0,n=this.lightningsMeshes.length;for(;t<n;){const s=this.lightningsMeshes[t],a=s.geometry,h=a.state;a.update(i),h===LightningStrike.RAY_PROPAGATING&&a.state>h&&this.onLightningDown&&this.onLightningDown(a),a.state===LightningStrike.RAY_EXTINGUISHED?(this.lightningsMeshes.splice(this.lightningsMeshes.indexOf(s),1),this.deadLightningsMeshes.push(s),this.remove(s),n--):t++}}getNextLightningTime(i){return i+MathUtils.lerp(this.stormParams.lightningMinPeriod,this.stormParams.lightningMaxPeriod,Math.random())/(this.stormParams.maxLightnings+1)}copy(i,t){return super.copy(i,t),this.stormParams.size=i.stormParams.size,this.stormParams.minHeight=i.stormParams.minHeight,this.stormParams.maxHeight=i.stormParams.maxHeight,this.stormParams.maxSlope=i.stormParams.maxSlope,this.stormParams.maxLightnings=i.stormParams.maxLightnings,this.stormParams.lightningMinPeriod=i.stormParams.lightningMinPeriod,this.stormParams.lightningMaxPeriod=i.stormParams.lightningMaxPeriod,this.stormParams.lightningMinDuration=i.stormParams.lightningMinDuration,this.stormParams.lightningMaxDuration=i.stormParams.lightningMaxDuration,this.lightningParameters=LightningStrike.copyParameters({},i.lightningParameters),this.lightningMaterial=i.stormParams.lightningMaterial,this.onLightningDown=i.onLightningDown,this}clone(){return new this.constructor(this.stormParams).copy(this)}}export{LightningStorm};