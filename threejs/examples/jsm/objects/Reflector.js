import{Color,Matrix4,Mesh,PerspectiveCamera,Plane,ShaderMaterial,UniformsUtils,Vector3,Vector4,WebGLRenderTarget,HalfFloatType,NoToneMapping,LinearSRGBColorSpace}from"three";class Reflector extends Mesh{constructor(e,t={}){super(e),this.isReflector=!0,this.type="Reflector",this.camera=new PerspectiveCamera;const r=this,n=void 0!==t.color?new Color(t.color):new Color(8355711),a=t.textureWidth||512,o=t.textureHeight||512,l=t.clipBias||0,i=t.shader||Reflector.ReflectorShader,s=void 0!==t.multisample?t.multisample:4,d=new Plane,c=new Vector3,p=new Vector3,u=new Vector3,m=new Matrix4,f=new Vector3(0,0,-1),v=new Vector4,x=new Vector3,b=new Vector3,g=new Vector4,h=new Matrix4,M=this.camera,y=new WebGLRenderTarget(a,o,{samples:s,type:HalfFloatType}),w=new ShaderMaterial({uniforms:UniformsUtils.clone(i.uniforms),fragmentShader:i.fragmentShader,vertexShader:i.vertexShader});w.uniforms.tDiffuse.value=y.texture,w.uniforms.color.value=n,w.uniforms.textureMatrix.value=h,this.material=w,this.onBeforeRender=function(e,t,n){if(p.setFromMatrixPosition(r.matrixWorld),u.setFromMatrixPosition(n.matrixWorld),m.extractRotation(r.matrixWorld),c.set(0,0,1),c.applyMatrix4(m),x.subVectors(p,u),x.dot(c)>0)return;x.reflect(c).negate(),x.add(p),m.extractRotation(n.matrixWorld),f.set(0,0,-1),f.applyMatrix4(m),f.add(u),b.subVectors(p,f),b.reflect(c).negate(),b.add(p),M.position.copy(x),M.up.set(0,1,0),M.up.applyMatrix4(m),M.up.reflect(c),M.lookAt(b),M.far=n.far,M.updateMatrixWorld(),M.projectionMatrix.copy(n.projectionMatrix),h.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),h.multiply(M.projectionMatrix),h.multiply(M.matrixWorldInverse),h.multiply(r.matrixWorld),d.setFromNormalAndCoplanarPoint(c,p),d.applyMatrix4(M.matrixWorldInverse),v.set(d.normal.x,d.normal.y,d.normal.z,d.constant);const a=M.projectionMatrix;g.x=(Math.sign(v.x)+a.elements[8])/a.elements[0],g.y=(Math.sign(v.y)+a.elements[9])/a.elements[5],g.z=-1,g.w=(1+a.elements[10])/a.elements[14],v.multiplyScalar(2/v.dot(g)),a.elements[2]=v.x,a.elements[6]=v.y,a.elements[10]=v.z+1-l,a.elements[14]=v.w,r.visible=!1;const o=e.getRenderTarget(),i=e.xr.enabled,s=e.shadowMap.autoUpdate,w=e.outputColorSpace,R=e.toneMapping;e.xr.enabled=!1,e.shadowMap.autoUpdate=!1,e.outputColorSpace=LinearSRGBColorSpace,e.toneMapping=NoToneMapping,e.setRenderTarget(y),e.state.buffers.depth.setMask(!0),!1===e.autoClear&&e.clear(),e.render(t,M),e.xr.enabled=i,e.shadowMap.autoUpdate=s,e.outputColorSpace=w,e.toneMapping=R,e.setRenderTarget(o);const S=n.viewport;void 0!==S&&e.state.viewport(S),r.visible=!0},this.getRenderTarget=function(){return y},this.dispose=function(){y.dispose(),r.material.dispose()}}}Reflector.ReflectorShader={uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:"\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}",fragmentShader:"\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\n\t\t}"};export{Reflector};