import{Color,Matrix4,Mesh,PerspectiveCamera,Plane,Quaternion,ShaderMaterial,UniformsUtils,Vector3,Vector4,WebGLRenderTarget,LinearSRGBColorSpace,NoToneMapping,HalfFloatType}from"three";class Refractor extends Mesh{constructor(e,t={}){super(e),this.isRefractor=!0,this.type="Refractor",this.camera=new PerspectiveCamera;const r=this,n=void 0!==t.color?new Color(t.color):new Color(8355711),a=t.textureWidth||512,o=t.textureHeight||512,i=t.clipBias||0,l=t.shader||Refractor.RefractorShader,s=void 0!==t.multisample?t.multisample:4,c=this.camera;c.matrixAutoUpdate=!1,c.userData.refractor=!0;const u=new Plane,m=new Matrix4,d=new WebGLRenderTarget(a,o,{samples:s,type:HalfFloatType});this.material=new ShaderMaterial({uniforms:UniformsUtils.clone(l.uniforms),vertexShader:l.vertexShader,fragmentShader:l.fragmentShader,transparent:!0}),this.material.uniforms.color.value=n,this.material.uniforms.tDiffuse.value=d.texture,this.material.uniforms.textureMatrix.value=m;const p=function(){const e=new Vector3,t=new Vector3,n=new Matrix4,a=new Vector3,o=new Vector3;return function(i){return e.setFromMatrixPosition(r.matrixWorld),t.setFromMatrixPosition(i.matrixWorld),a.subVectors(e,t),n.extractRotation(r.matrixWorld),o.set(0,0,1),o.applyMatrix4(n),a.dot(o)<0}}(),f=function(){const e=new Vector3,t=new Vector3,n=new Quaternion,a=new Vector3;return function(){r.matrixWorld.decompose(t,n,a),e.set(0,0,1).applyQuaternion(n).normalize(),e.negate(),u.setFromNormalAndCoplanarPoint(e,t)}}(),v=function(){const e=new Plane,t=new Vector4,r=new Vector4;return function(n){c.matrixWorld.copy(n.matrixWorld),c.matrixWorldInverse.copy(c.matrixWorld).invert(),c.projectionMatrix.copy(n.projectionMatrix),c.far=n.far,e.copy(u),e.applyMatrix4(c.matrixWorldInverse),t.set(e.normal.x,e.normal.y,e.normal.z,e.constant);const a=c.projectionMatrix;r.x=(Math.sign(t.x)+a.elements[8])/a.elements[0],r.y=(Math.sign(t.y)+a.elements[9])/a.elements[5],r.z=-1,r.w=(1+a.elements[10])/a.elements[14],t.multiplyScalar(2/t.dot(r)),a.elements[2]=t.x,a.elements[6]=t.y,a.elements[10]=t.z+1-i,a.elements[14]=t.w}}();this.onBeforeRender=function(e,t,n){!0!==n.userData.refractor&&1!=!p(n)&&(f(),function(e){m.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),m.multiply(e.projectionMatrix),m.multiply(e.matrixWorldInverse),m.multiply(r.matrixWorld)}(n),v(n),function(e,t,n){r.visible=!1;const a=e.getRenderTarget(),o=e.xr.enabled,i=e.shadowMap.autoUpdate,l=e.outputColorSpace,s=e.toneMapping;e.xr.enabled=!1,e.shadowMap.autoUpdate=!1,e.outputColorSpace=LinearSRGBColorSpace,e.toneMapping=NoToneMapping,e.setRenderTarget(d),!1===e.autoClear&&e.clear(),e.render(t,c),e.xr.enabled=o,e.shadowMap.autoUpdate=i,e.outputColorSpace=l,e.toneMapping=s,e.setRenderTarget(a);const u=n.viewport;void 0!==u&&e.state.viewport(u),r.visible=!0}(e,t,n))},this.getRenderTarget=function(){return d},this.dispose=function(){d.dispose(),r.material.dispose()}}}Refractor.RefractorShader={uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:"\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\n\t\t}"};export{Refractor};