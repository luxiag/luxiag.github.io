import WebGPUUniformsGroup from"../WebGPUUniformsGroup.js";import{FloatNodeUniform,Vector2NodeUniform,Vector3NodeUniform,Vector4NodeUniform,ColorNodeUniform,Matrix3NodeUniform,Matrix4NodeUniform}from"./WebGPUNodeUniform.js";import WebGPUNodeSampler from"./WebGPUNodeSampler.js";import{WebGPUNodeSampledTexture,WebGPUNodeSampledCubeTexture}from"./WebGPUNodeSampledTexture.js";import WebGPUUniformBuffer from"../WebGPUUniformBuffer.js";import WebGPUStorageBuffer from"../WebGPUStorageBuffer.js";import{getVectorLength,getStrideLength}from"../WebGPUBufferUtils.js";import WebGPURenderTarget from"../WebGPURenderTarget.js";import{NodeBuilder,WGSLNodeParser,CodeNode,NodeMaterial}from"three/nodes";const gpuShaderStageLib={vertex:GPUShaderStage.VERTEX,fragment:GPUShaderStage.FRAGMENT,compute:GPUShaderStage.COMPUTE},supports={instance:!0},wgslTypeLib={float:"f32",int:"i32",uint:"u32",bool:"bool",color:"vec3<f32>",vec2:"vec2<f32>",ivec2:"vec2<i32>",uvec2:"vec2<u32>",bvec2:"vec2<bool>",vec3:"vec3<f32>",ivec3:"vec3<i32>",uvec3:"vec3<u32>",bvec3:"vec3<bool>",vec4:"vec4<f32>",ivec4:"vec4<i32>",uvec4:"vec4<u32>",bvec4:"vec4<bool>",mat3:"mat3x3<f32>",imat3:"mat3x3<i32>",umat3:"mat3x3<u32>",bmat3:"mat3x3<bool>",mat4:"mat4x4<f32>",imat4:"mat4x4<i32>",umat4:"mat4x4<u32>",bmat4:"mat4x4<bool>"},wgslMethods={dFdx:"dpdx",dFdy:"dpdy",mod:"threejs_mod",lessThanEqual:"threejs_lessThanEqual",inversesqrt:"inverseSqrt"},wgslPolyfill={lessThanEqual:new CodeNode("\nfn threejs_lessThanEqual( a : vec3<f32>, b : vec3<f32> ) -> vec3<bool> {\n\n\treturn vec3<bool>( a.x <= b.x, a.y <= b.y, a.z <= b.z );\n\n}\n"),mod:new CodeNode("\nfn threejs_mod( x : f32, y : f32 ) -> f32 {\n\n\treturn x - y * floor( x / y );\n\n}\n"),repeatWrapping:new CodeNode("\nfn threejs_repeatWrapping( uv : vec2<f32>, dimension : vec2<u32> ) -> vec2<u32> {\n\n\tlet uvScaled = vec2<u32>( uv * vec2<f32>( dimension ) );\n\n\treturn ( ( uvScaled % dimension ) + dimension ) % dimension;\n\n}\n")};class WebGPUNodeBuilder extends NodeBuilder{constructor(e,t){super(e,t,new WGSLNodeParser),this.bindings={vertex:[],fragment:[],compute:[]},this.bindingsOffset={vertex:0,fragment:0,compute:0},this.uniformsGroup={},this.builtins={vertex:new Map,fragment:new Map,compute:new Map,attribute:new Map}}build(){const{object:e,material:t}=this;return null!==t?NodeMaterial.fromMaterial(t).build(this):this.addFlow("compute",e),super.build()}getSampler(e,t,r=this.shaderStage){return"fragment"===r?`textureSample( ${e}, ${e}_sampler, ${t} )`:(this._include("repeatWrapping"),`textureLoad( ${e}, threejs_repeatWrapping( ${t}, textureDimensions( ${e}, 0 ) ), 0 )`)}getVideoSampler(e,t,r=this.shaderStage){if("fragment"===r)return`textureSampleBaseClampToEdge( ${e}, ${e}_sampler, vec2<f32>( ${t}.x, 1.0 - ${t}.y ) )`;console.error(`WebGPURenderer: THREE.VideoTexture does not support ${r} shader.`)}getSamplerLevel(e,t,r,n=this.shaderStage){return"fragment"===n?`textureSampleLevel( ${e}, ${e}_sampler, ${t}, ${r} )`:(this._include("repeatWrapping"),`textureLoad( ${e}, threejs_repeatWrapping( ${t}, textureDimensions( ${e}, 0 ) ), i32( ${r} ) )`)}getTexture(e,t,r,n=this.shaderStage){let i=null;return i=!0===e.isVideoTexture?this.getVideoSampler(t,r,n):this.getSampler(t,r,n),i}getTextureLevel(e,t,r,n,i=this.shaderStage){let o=null;return o=!0===e.isVideoTexture?this.getVideoSampler(t,r,i):this.getSamplerLevel(t,r,n,i),o}getPropertyName(e,t=this.shaderStage){if(!0===e.isNodeVarying&&!0===e.needsInterpolation){if("vertex"===t)return`NodeVaryings.${e.name}`}else if(!0===e.isNodeUniform){const t=e.name,r=e.type;return"texture"===r||"cubeTexture"===r?t:"buffer"===r||"storageBuffer"===r?`NodeBuffer_${e.node.id}.${t}`:`NodeUniforms.${t}`}return super.getPropertyName(e)}getBindings(){const e=this.bindings;return null!==this.material?[...e.vertex,...e.fragment]:e.compute}getUniformFromNode(e,t,r){const n=super.getUniformFromNode(e,t,r),i=this.getDataFromNode(e,t);if(void 0===i.uniformGPU){let o;const s=this.bindings[t];if("texture"===r||"cubeTexture"===r){const e=new WebGPUNodeSampler(`${n.name}_sampler`,n.node);let i=null;"texture"===r?i=new WebGPUNodeSampledTexture(n.name,n.node):"cubeTexture"===r&&(i=new WebGPUNodeSampledCubeTexture(n.name,n.node));const a=s[s.length-1],u=a&&a.isUniformsGroup?s.length-1:s.length;"fragment"===t?(s.splice(u,0,e,i),o=[e,i]):(s.splice(u,0,i),o=[i])}else if("buffer"===r||"storageBuffer"===r){const n=new("storageBuffer"===r?WebGPUStorageBuffer:WebGPUUniformBuffer)("NodeBuffer_"+e.id,e.value);n.setVisibility(gpuShaderStageLib[t]);const i=s[s.length-1],a=i&&i.isUniformsGroup?s.length-1:s.length;s.splice(a,0,n),o=n}else{let i=this.uniformsGroup[t];if(void 0===i&&(i=new WebGPUUniformsGroup("nodeUniforms"),i.setVisibility(gpuShaderStageLib[t]),this.uniformsGroup[t]=i,s.push(i)),!0===e.isArrayUniformNode){o=[];for(const t of e.nodes){const e=this._getNodeUniform(t,r);e.boundary=getVectorLength(e.itemSize),e.itemSize=getStrideLength(e.itemSize),i.addUniform(e),o.push(e)}}else o=this._getNodeUniform(n,r),i.addUniform(o)}i.uniformGPU=o,"vertex"===t&&(this.bindingsOffset.fragment=s.length)}return n}isReference(e){return super.isReference(e)||"texture_2d"===e||"texture_cube"===e}getBuiltin(e,t,r,n=this.shaderStage){const i=this.builtins[n];return!1===i.has(e)&&i.set(e,{name:e,property:t,type:r}),t}getInstanceIndex(){return"vertex"===this.shaderStage?this.getBuiltin("instance_index","instanceIndex","u32","attribute"):"instanceIndex"}getFrontFacing(){return this.getBuiltin("front_facing","isFront","bool")}getFragCoord(){return this.getBuiltin("position","fragCoord","vec4<f32>","fragment")}isFlipY(){return!1}getAttributes(e){const t=[];if("compute"===e&&this.getBuiltin("global_invocation_id","id","vec3<u32>","attribute"),"vertex"===e||"compute"===e){for(const{name:e,property:r,type:n}of this.builtins.attribute.values())t.push(`@builtin( ${e} ) ${r} : ${n}`);const e=this.attributes,r=e.length;for(let n=0;n<r;n++){const r=e[n],i=r.name,o=this.getType(r.type);t.push(`@location( ${n} ) ${i} : ${o}`)}}return t.join(",\n\t")}getVars(e){const t=[],r=this.vars[e];for(const e of r){const r=e.name,n=this.getType(e.type);t.push(`\tvar ${r} : ${n};`)}return`\n${t.join("\n")}\n`}getVaryings(e){const t=[];if("vertex"===e&&this.getBuiltin("position","Vertex","vec4<f32>","vertex"),"vertex"===e||"fragment"===e){const r=this.varyings,n=this.vars[e];for(let e=0;e<r.length;e++){const i=r[e];i.needsInterpolation?t.push(`@location( ${e} ) ${i.name} : ${this.getType(i.type)}`):!1===n.includes(i)&&n.push(i)}}for(const{name:r,property:n,type:i}of this.builtins[e].values())t.push(`@builtin( ${r} ) ${n} : ${i}`);const r=t.join(",\n\t");return"vertex"===e?this._getWGSLStruct("NodeVaryingsStruct","\t"+r):r}getUniforms(e){const t=this.uniforms[e],r=[],n=[],i=[];let o=this.bindingsOffset[e];for(const s of t)if("texture"===s.type||"cubeTexture"===s.type){"fragment"===e&&r.push(`@group( 0 ) @binding( ${o++} ) var ${s.name}_sampler : sampler;`);const t=s.node.value;let n;n=!0===t.isCubeTexture?"texture_cube<f32>":!0===t.isDepthTexture?"texture_depth_2d":!0===t.isVideoTexture?"texture_external":"texture_2d<f32>",r.push(`@group( 0 ) @binding( ${o++} ) var ${s.name} : ${n};`)}else if("buffer"===s.type||"storageBuffer"===s.type){const e=s.node,t=this.getType(e.bufferType),r=e.bufferCount,i=r>0?", "+r:"",a=`\t${s.name} : array< ${t}${i} >\n`,u=e.isStorageBufferNode?"storage,read_write":"uniform";n.push(this._getWGSLStructBinding("NodeBuffer_"+e.id,a,u,o++))}else{const e=this.getType(this.getVectorType(s.type));if(!0===Array.isArray(s.value)){const t=s.value.length;i.push(`uniform ${e}[ ${t} ] ${s.name}`)}else i.push(`\t${s.name} : ${e}`)}let s=r.join("\n");return s+=n.join("\n"),i.length>0&&(s+=this._getWGSLStructBinding("NodeUniforms",i.join(",\n"),"uniform",o++)),s}buildCode(){const e=null!==this.material?{fragment:{},vertex:{}}:{compute:{}};for(const t in e){let r="// code\n\n";r+=this.flowCode[t];const n=this.flowNodes[t],i=n[n.length-1];for(const e of n){const n=this.getFlowData(e),o=e.name;o&&(r.length>0&&(r+="\n"),r+=`\t// flow -> ${o}\n\t`),r+=`${n.code}\n\t`,e===i&&"compute"!==t&&(r+="// result\n\t","vertex"===t?r+="NodeVaryings.Vertex = ":"fragment"===t&&(r+="return "),r+=`${n.result};`)}const o=e[t];o.uniforms=this.getUniforms(t),o.attributes=this.getAttributes(t),o.varyings=this.getVaryings(t),o.vars=this.getVars(t),o.codes=this.getCodes(t),o.flow=r}null!==this.material?(this.vertexShader=this._getWGSLVertexCode(e.vertex),this.fragmentShader=this._getWGSLFragmentCode(e.fragment)):this.computeShader=this._getWGSLComputeCode(e.compute,(this.object.workgroupSize||[64]).join(", "))}getRenderTarget(e,t,r){return new WebGPURenderTarget(e,t,r)}getMethod(e){return void 0!==wgslPolyfill[e]&&this._include(e),wgslMethods[e]||e}getType(e){return wgslTypeLib[e]||e}isAvailable(e){return!0===supports[e]}_include(e){wgslPolyfill[e].build(this)}_getNodeUniform(e,t){if("float"===t)return new FloatNodeUniform(e);if("vec2"===t)return new Vector2NodeUniform(e);if("vec3"===t)return new Vector3NodeUniform(e);if("vec4"===t)return new Vector4NodeUniform(e);if("color"===t)return new ColorNodeUniform(e);if("mat3"===t)return new Matrix3NodeUniform(e);if("mat4"===t)return new Matrix4NodeUniform(e);throw new Error(`Uniform "${t}" not declared.`)}_getWGSLVertexCode(e){return`${this.getSignature()}\n\n// uniforms\n${e.uniforms}\n\n// varyings\n${e.varyings}\n\n// codes\n${e.codes}\n\n@vertex\nfn main( ${e.attributes} ) -> NodeVaryingsStruct {\n\n\t// system\n\tvar NodeVaryings: NodeVaryingsStruct;\n\n\t// vars\n\t${e.vars}\n\n\t// flow\n\t${e.flow}\n\n\treturn NodeVaryings;\n\n}\n`}_getWGSLFragmentCode(e){return`${this.getSignature()}\n\n// uniforms\n${e.uniforms}\n\n// codes\n${e.codes}\n\n@fragment\nfn main( ${e.varyings} ) -> @location( 0 ) vec4<f32> {\n\n\t// vars\n\t${e.vars}\n\n\t// flow\n\t${e.flow}\n\n}\n`}_getWGSLComputeCode(e,t){return`${this.getSignature()}\n// system\nvar<private> instanceIndex : u32;\n\n// uniforms\n${e.uniforms}\n\n// codes\n${e.codes}\n\n@compute @workgroup_size( ${t} )\nfn main( ${e.attributes} ) {\n\n\t// system\n\tinstanceIndex = id.x;\n\n\t// vars\n\t${e.vars}\n\n\t// flow\n\t${e.flow}\n\n}\n`}_getWGSLStruct(e,t){return`\nstruct ${e} {\n${t}\n};`}_getWGSLStructBinding(e,t,r,n=0,i=0){const o=e+"Struct";return`${this._getWGSLStruct(o,t)}\n@binding( ${n} ) @group( ${i} )\nvar<${r}> ${e} : ${o};`}}export default WebGPUNodeBuilder;