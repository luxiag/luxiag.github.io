class WebGPUAttributes{constructor(e){this.buffers=new WeakMap,this.device=e}get(e){return e.isInterleavedBufferAttribute&&(e=e.data),this.buffers.get(e)}remove(e){e.isInterleavedBufferAttribute&&(e=e.data);const t=this.buffers.get(e);t&&(this._destroyBuffers(t),this.buffers.delete(e))}update(e,t=!1,r=null){e.isInterleavedBufferAttribute&&(e=e.data);let f=this.buffers.get(e);void 0===f?(null===r&&(r=!0===t?GPUBufferUsage.INDEX:GPUBufferUsage.VERTEX),f=this._createBuffer(e,r),this.buffers.set(e,f)):r&&r!==f.usage?(this._destroyBuffers(f),f=this._createBuffer(e,r),this.buffers.set(e,f)):f.version<e.version&&(this._writeBuffer(f.buffer,e),f.version=e.version)}async getArrayBuffer(e){const t=this.get(e),r=this.device,f=t.buffer,s=f.size;let u=t.readBuffer,a=!0;null===u&&(u=r.createBuffer({label:e.name,size:s,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),a=!1,t.readBuffer=u);const i=r.createCommandEncoder({});i.copyBufferToBuffer(f,0,u,0,s),a&&u.unmap();const n=i.finish();return r.queue.submit([n]),await u.mapAsync(GPUMapMode.READ),u.getMappedRange()}_createBuffer(e,t){const r=e.array,f=r.byteLength+(4-r.byteLength%4)%4,s=this.device.createBuffer({label:e.name,size:f,usage:t|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});return new r.constructor(s.getMappedRange()).set(r),s.unmap(),e.onUploadCallback(),{version:e.version,buffer:s,readBuffer:null,usage:t}}_writeBuffer(e,t){const r=this.device,f=t.array,s=t.updateRange;-1===s.count?r.queue.writeBuffer(e,0,f,0):(r.queue.writeBuffer(e,0,f,s.offset*f.BYTES_PER_ELEMENT,s.count*f.BYTES_PER_ELEMENT),s.count=-1)}_destroyBuffers({buffer:e,readBuffer:t}){e.destroy(),null!==t&&t.destroy()}}export default WebGPUAttributes;