import{defaultShaderStages,NodeFrame,MathNode,GLSLNodeParser,NodeBuilder}from"three/nodes";import SlotNode from"./SlotNode.js";import{PerspectiveCamera,ShaderChunk,ShaderLib,UniformsUtils,UniformsLib}from"three";const nodeFrame=new NodeFrame;nodeFrame.camera=new PerspectiveCamera;const nodeShaderLib={LineBasicNodeMaterial:ShaderLib.basic,MeshBasicNodeMaterial:ShaderLib.basic,PointsNodeMaterial:ShaderLib.points,MeshStandardNodeMaterial:ShaderLib.standard,MeshPhysicalNodeMaterial:ShaderLib.physical},glslMethods={[MathNode.ATAN2]:"atan"},precisionLib={low:"lowp",medium:"mediump",high:"highp"};function getIncludeSnippet(e){return`#include <${e}>`}function getShaderStageProperty(e){return`${e}Shader`}class WebGLNodeBuilder extends NodeBuilder{constructor(e,t,o){super(e,t,new GLSLNodeParser),this.shader=o,this.slots={vertex:[],fragment:[]},this._parseShaderLib(),this._parseInclude("fragment","lights_physical_fragment","clearcoat_normal_fragment_begin","transmission_fragment"),this._parseObject(),this._sortSlotsToFlow()}getMethod(e){return glslMethods[e]||e}addSlot(e,t){this.slots[e].push(t)}_parseShaderLib(){const e=this.material;let t=e.type;if(e.isMeshPhysicalNodeMaterial?t="MeshPhysicalNodeMaterial":e.isMeshStandardNodeMaterial?t="MeshStandardNodeMaterial":e.isMeshBasicNodeMaterial?t="MeshBasicNodeMaterial":e.isPointsNodeMaterial?t="PointsNodeMaterial":e.isLineBasicNodeMaterial&&(t="LineBasicNodeMaterial"),void 0!==nodeShaderLib[t]){const e=nodeShaderLib[t],o=this.shader;o.vertexShader=e.vertexShader,o.fragmentShader=e.fragmentShader,o.uniforms=UniformsUtils.merge([e.uniforms,UniformsLib.lights])}}_parseObject(){const{material:e,renderer:t}=this;t.toneMappingNode&&!0===t.toneMappingNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.colorNode,nodeType:"vec4",source:getIncludeSnippet("tonemapping_fragment"),target:""})),e.colorNode&&e.colorNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.colorNode,nodeType:"vec4",source:"vec4 diffuseColor = vec4( diffuse, opacity );",target:"vec4 diffuseColor = %RESULT%;"})),e.opacityNode&&e.opacityNode.isNode?this.addSlot("fragment",new SlotNode({node:e.opacityNode,nodeType:"float",source:getIncludeSnippet("alphatest_fragment"),target:"diffuseColor.a = %RESULT%;",inclusionType:"append"})):this.addCode("fragment",getIncludeSnippet("alphatest_fragment"),"diffuseColor.a = opacity;",this.shader),e.normalNode&&e.normalNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.normalNode,nodeType:"vec3",source:getIncludeSnippet("normal_fragment_begin"),target:"normal = %RESULT%;",inclusionType:"append"})),e.emissiveNode&&e.emissiveNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.emissiveNode,nodeType:"vec3",source:getIncludeSnippet("emissivemap_fragment"),target:"totalEmissiveRadiance = %RESULT%;",inclusionType:"append"})),e.isMeshStandardNodeMaterial&&(e.metalnessNode&&e.metalnessNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.metalnessNode,nodeType:"float",source:getIncludeSnippet("metalnessmap_fragment"),target:"metalnessFactor = %RESULT%;",inclusionType:"append"})),e.roughnessNode&&e.roughnessNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.roughnessNode,nodeType:"float",source:getIncludeSnippet("roughnessmap_fragment"),target:"roughnessFactor = %RESULT%;",inclusionType:"append"})),e.isMeshPhysicalNodeMaterial&&(e.clearcoatNode&&e.clearcoatNode.isNode?(this.addSlot("fragment",new SlotNode({node:e.clearcoatNode,nodeType:"float",source:"material.clearcoat = clearcoat;",target:"material.clearcoat = %RESULT%;"})),e.clearcoatRoughnessNode&&e.clearcoatRoughnessNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.clearcoatRoughnessNode,nodeType:"float",source:"material.clearcoatRoughness = clearcoatRoughness;",target:"material.clearcoatRoughness = %RESULT%;"})),e.clearcoatNormalNode&&e.clearcoatNormalNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.clearcoatNormalNode,nodeType:"vec3",source:"vec3 clearcoatNormal = geometryNormal;",target:"vec3 clearcoatNormal = %RESULT%;"})),e.defines.USE_CLEARCOAT=""):delete e.defines.USE_CLEARCOAT,e.sheenNode&&e.sheenNode.isNode?(this.addSlot("fragment",new SlotNode({node:e.sheenNode,nodeType:"vec3",source:"material.sheenColor = sheenColor;",target:"material.sheenColor = %RESULT%;"})),e.sheenRoughnessNode&&e.sheenRoughnessNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.sheenRoughnessNode,nodeType:"float",source:"material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );",target:"material.sheenRoughness = clamp( %RESULT%, 0.07, 1.0 );"})),e.defines.USE_SHEEN=""):delete e.defines.USE_SHEEN,e.iridescenceNode&&e.iridescenceNode.isNode?(this.addSlot("fragment",new SlotNode({node:e.iridescenceNode,nodeType:"float",source:"material.iridescence = iridescence;",target:"material.iridescence = %RESULT%;"})),e.iridescenceIORNode&&e.iridescenceIORNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.iridescenceIORNode,nodeType:"float",source:"material.iridescenceIOR = iridescenceIOR;",target:"material.iridescenceIOR = %RESULT%;"})),e.iridescenceThicknessNode&&e.iridescenceThicknessNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.iridescenceThicknessNode,nodeType:"float",source:"material.iridescenceThickness = iridescenceThicknessMaximum;",target:"material.iridescenceThickness = %RESULT%;"})),e.defines.USE_IRIDESCENCE=""):delete e.defines.USE_IRIDESCENCE,e.iorNode&&e.iorNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.iorNode,nodeType:"float",source:"material.ior = ior;",target:"material.ior = %RESULT%;"})),e.specularColorNode&&e.specularColorNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.specularColorNode,nodeType:"vec3",source:"vec3 specularColorFactor = specularColor;",target:"vec3 specularColorFactor = %RESULT%;"})),e.specularIntensityNode&&e.specularIntensityNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.specularIntensityNode,nodeType:"float",source:"float specularIntensityFactor = specularIntensity;",target:"float specularIntensityFactor = %RESULT%;"})),e.transmissionNode&&e.transmissionNode.isNode?(this.addSlot("fragment",new SlotNode({node:e.transmissionNode,nodeType:"float",source:"material.transmission = transmission;",target:"material.transmission = %RESULT%;"})),e.thicknessNode&&e.thicknessNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.thicknessNode,nodeType:"float",source:"material.thickness = thickness;",target:"material.thickness = %RESULT%;"})),e.thicknessNode&&e.thicknessNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.thicknessNode,nodeType:"float",source:"material.thickness = thickness;",target:"material.thickness = %RESULT%;"})),e.attenuationDistanceNode&&e.attenuationDistanceNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.attenuationDistanceNode,nodeType:"float",source:"material.attenuationDistance = attenuationDistance;",target:"material.attenuationDistance = %RESULT%;"})),e.attenuationColorNode&&e.attenuationColorNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.attenuationColorNode,nodeType:"vec3",source:"material.attenuationColor = attenuationColor;",target:"material.attenuationColor = %RESULT%;"})),e.transmission=1,e.defines.USE_TRANSMISSION=""):(e.transmission=0,delete e.defines.USE_TRANSMISSION))),e.positionNode&&e.positionNode.isNode&&this.addSlot("vertex",new SlotNode({node:e.positionNode,nodeType:"vec3",source:getIncludeSnippet("begin_vertex"),target:"transformed = %RESULT%;",inclusionType:"append"})),e.sizeNode&&e.sizeNode.isNode&&this.addSlot("vertex",new SlotNode({node:e.sizeNode,nodeType:"float",source:"gl_PointSize = size;",target:"gl_PointSize = %RESULT%;"}))}getTexture(e,t,o){return e.isTextureCube?`textureCube( ${t}, ${o} )`:`texture2D( ${t}, ${o} )`}getTextureBias(e,t,o,a){return void 0!==this.material.extensions&&(this.material.extensions.shaderTextureLOD=!0),`textureLod( ${t}, ${o}, ${a} )`}getUniforms(e){const t=this.uniforms[e];let o="";for(const e of t){let t=null;t="texture"===e.type?`sampler2D ${e.name}; `:"cubeTexture"===e.type?`samplerCube ${e.name}; `:`${this.getVectorType(e.type)} ${e.name}; `;const a=e.node.precision;t=null!==a?"uniform "+precisionLib[a]+" "+t:"uniform "+t,o+=t}return o}getAttributes(e){let t="";if("vertex"===e){const e=this.attributes;for(const o of e)"uv"!==o.name&&"position"!==o.name&&"normal"!==o.name&&(t+=`attribute ${o.type} ${o.name}; `)}return t}getVaryings(e){let t="";const o=this.varyings;if("vertex"===e)for(const e of o)t+=`${e.needsInterpolation?"varying":"/*varying*/"} ${e.type} ${e.name}; `;else if("fragment"===e)for(const e of o)e.needsInterpolation&&(t+=`varying ${e.type} ${e.name}; `);return t}addCode(e,t,o,a=this){const s=getShaderStageProperty(e);let n=a[s];const r=n.indexOf(t);if(-1!==r){const e=n.substring(0,r+t.length),a=n.substring(r+t.length);n=`${e}\n${o}\n${a}`}a[s]=n}replaceCode(e,t,o,a=this){const s=getShaderStageProperty(e);a[s]=a[s].replaceAll(t,o)}getFrontFacing(){return"gl_FrontFacing"}getFragCoord(){return"gl_FragCoord"}isFlipY(){return!0}buildCode(){const e={};for(const t of defaultShaderStages){const o=this.getUniforms(t),a=this.getAttributes(t),s=this.getVaryings(t),n=this.getVars(t),r=this.getCodes(t);e[t]=`${this.getSignature()}\n// <node_builder>\n\n// uniforms\n${o}\n\n// attributes\n${a}\n\n// varyings\n${s}\n\n// vars\n${n}\n\n// codes\n${r}\n\n// </node_builder>\n\n${this.shader[getShaderStageProperty(t)]}\n`}this.vertexShader=e.vertex,this.fragmentShader=e.fragment}build(){return super.build(),this._addSnippets(),this._addUniforms(),this._updateUniforms(),this.shader.vertexShader=this.vertexShader,this.shader.fragmentShader=this.fragmentShader,this}_parseInclude(e,...t){for(const o of t){const t=getIncludeSnippet(o),a=ShaderChunk[o],s=getShaderStageProperty(e);this.shader[s]=this.shader[s].replaceAll(t,a)}}_sortSlotsToFlow(){for(const e of defaultShaderStages){const t=this.shader[getShaderStageProperty(e)],o=this.slots[e].sort(((e,o)=>t.indexOf(e.source)>t.indexOf(o.source)?1:-1));for(const t of o)this.addFlow(e,t)}}_addSnippets(){for(const e of defaultShaderStages){for(const t of this.slots[e]){const o=this.getFlowData(t),a=t.inclusionType,s=t.source,n=o.code+"\n\t"+t.target.replace("%RESULT%",o.result);"append"===a?this.addCode(e,s,n):"replace"===a?this.replaceCode(e,s,n):console.warn(`Inclusion type "${a}" not compatible.`)}this.addCode(e,"main() {","\n\t"+this.flowCode[e])}}_addUniforms(){for(const e of defaultShaderStages)for(const t of this.uniforms[e])this.shader.uniforms[t.name]=t}_updateUniforms(){nodeFrame.object=this.object,nodeFrame.renderer=this.renderer;for(const e of this.updateNodes)nodeFrame.updateNode(e)}}export{WebGLNodeBuilder};