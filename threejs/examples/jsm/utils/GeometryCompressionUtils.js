import{BufferAttribute,Matrix3,Matrix4,Vector3}from"three";import{PackedPhongMaterial}from"./PackedPhongMaterial.js";function compressNormals(e,t){e.geometry||console.error("Mesh must contain geometry. ");const r=e.geometry.attributes.normal;if(r||console.error("Geometry must contain normal attribute. "),r.isPacked)return;3!=r.itemSize&&console.error("normal.itemSize is not 3, which cannot be encoded. ");const n=r.array,a=r.count;let o;if("DEFAULT"==t){o=new Uint8Array(3*a);for(let e=0;e<n.length;e+=3){const t=defaultEncode(n[e],n[e+1],n[e+2],1);o[e+0]=t[0],o[e+1]=t[1],o[e+2]=t[2]}e.geometry.setAttribute("normal",new BufferAttribute(o,3,!0)),e.geometry.attributes.normal.bytes=1*o.length}else if("OCT1Byte"==t){o=new Int8Array(2*a);for(let e=0;e<n.length;e+=3){const t=octEncodeBest(n[e],n[e+1],n[e+2],1);o[e/3*2+0]=t[0],o[e/3*2+1]=t[1]}e.geometry.setAttribute("normal",new BufferAttribute(o,2,!0)),e.geometry.attributes.normal.bytes=1*o.length}else if("OCT2Byte"==t){o=new Int16Array(2*a);for(let e=0;e<n.length;e+=3){const t=octEncodeBest(n[e],n[e+1],n[e+2],2);o[e/3*2+0]=t[0],o[e/3*2+1]=t[1]}e.geometry.setAttribute("normal",new BufferAttribute(o,2,!0)),e.geometry.attributes.normal.bytes=2*o.length}else if("ANGLES"==t){o=new Uint16Array(2*a);for(let e=0;e<n.length;e+=3){const t=anglesEncode(n[e],n[e+1],n[e+2]);o[e/3*2+0]=t[0],o[e/3*2+1]=t[1]}e.geometry.setAttribute("normal",new BufferAttribute(o,2,!0)),e.geometry.attributes.normal.bytes=2*o.length}else console.error("Unrecognized encoding method, should be `DEFAULT` or `ANGLES` or `OCT`. ");e.geometry.attributes.normal.needsUpdate=!0,e.geometry.attributes.normal.isPacked=!0,e.geometry.attributes.normal.packingMethod=t,e.material instanceof PackedPhongMaterial||(e.material=(new PackedPhongMaterial).copy(e.material)),"ANGLES"==t&&(e.material.defines.USE_PACKED_NORMAL=0),"OCT1Byte"==t&&(e.material.defines.USE_PACKED_NORMAL=1),"OCT2Byte"==t&&(e.material.defines.USE_PACKED_NORMAL=1),"DEFAULT"==t&&(e.material.defines.USE_PACKED_NORMAL=2)}function compressPositions(e){e.geometry||console.error("Mesh must contain geometry. ");const t=e.geometry.attributes.position;if(t||console.error("Geometry must contain position attribute. "),t.isPacked)return;3!=t.itemSize&&console.error("position.itemSize is not 3, which cannot be packed. ");const r=quantizedEncode(t.array,2),n=r.quantized,a=r.decodeMat;null==e.geometry.boundingBox&&e.geometry.computeBoundingBox(),null==e.geometry.boundingSphere&&e.geometry.computeBoundingSphere(),e.geometry.setAttribute("position",new BufferAttribute(n,3)),e.geometry.attributes.position.isPacked=!0,e.geometry.attributes.position.needsUpdate=!0,e.geometry.attributes.position.bytes=2*n.length,e.material instanceof PackedPhongMaterial||(e.material=(new PackedPhongMaterial).copy(e.material)),e.material.defines.USE_PACKED_POSITION=0,e.material.uniforms.quantizeMatPos.value=a,e.material.uniforms.quantizeMatPos.needsUpdate=!0}function compressUvs(e){e.geometry||console.error("Mesh must contain geometry property. ");const t=e.geometry.attributes.uv;if(t||console.error("Geometry must contain uv attribute. "),t.isPacked)return;const r={min:1/0,max:-1/0},n=t.array;for(let e=0;e<n.length;e++)r.min=Math.min(r.min,n[e]),r.max=Math.max(r.max,n[e]);let a;if(r.min>=-1&&r.max<=1){a=new Uint16Array(n.length);for(let e=0;e<n.length;e+=2){const t=defaultEncode(n[e],n[e+1],0,2);a[e]=t[0],a[e+1]=t[1]}e.geometry.setAttribute("uv",new BufferAttribute(a,2,!0)),e.geometry.attributes.uv.isPacked=!0,e.geometry.attributes.uv.needsUpdate=!0,e.geometry.attributes.uv.bytes=2*a.length,e.material instanceof PackedPhongMaterial||(e.material=(new PackedPhongMaterial).copy(e.material)),e.material.defines.USE_PACKED_UV=0}else a=quantizedEncodeUV(n,2),e.geometry.setAttribute("uv",new BufferAttribute(a.quantized,2)),e.geometry.attributes.uv.isPacked=!0,e.geometry.attributes.uv.needsUpdate=!0,e.geometry.attributes.uv.bytes=2*a.quantized.length,e.material instanceof PackedPhongMaterial||(e.material=(new PackedPhongMaterial).copy(e.material)),e.material.defines.USE_PACKED_UV=1,e.material.uniforms.quantizeMatUV.value=a.decodeMat,e.material.uniforms.quantizeMatUV.needsUpdate=!0}function defaultEncode(e,t,r,n){if(1==n){const n=Math.round(.5*(e+1)*255),a=Math.round(.5*(t+1)*255),o=Math.round(.5*(r+1)*255);return new Uint8Array([n,a,o])}if(2==n){const n=Math.round(.5*(e+1)*65535),a=Math.round(.5*(t+1)*65535),o=Math.round(.5*(r+1)*65535);return new Uint16Array([n,a,o])}console.error("number of bytes must be 1 or 2")}function anglesEncode(e,t,r){const n=parseInt(.5*(1+Math.atan2(t,e)/Math.PI)*65535),a=parseInt(.5*(1+r)*65535);return new Uint16Array([n,a])}function octEncodeBest(e,t,r,n){let a,o,i,s,l;return i=a=m(e,t,r,"floor","floor"),o=u(a),l=c(e,t,r,o),a=m(e,t,r,"ceil","floor"),o=u(a),s=c(e,t,r,o),s>l&&(i=a,l=s),a=m(e,t,r,"floor","ceil"),o=u(a),s=c(e,t,r,o),s>l&&(i=a,l=s),a=m(e,t,r,"ceil","ceil"),o=u(a),s=c(e,t,r,o),s>l&&(i=a),i;function m(e,t,a,o,i){let s=e/(Math.abs(e)+Math.abs(t)+Math.abs(a)),l=t/(Math.abs(e)+Math.abs(t)+Math.abs(a));if(r<0){const e=(1-Math.abs(l))*(s>=0?1:-1),t=(1-Math.abs(s))*(l>=0?1:-1);s=e,l=t;let r=1-Math.abs(s)-Math.abs(l);r>0&&(r+=.001,s+=s>0?r/2:-r/2,l+=l>0?r/2:-r/2)}return 1==n?new Int8Array([Math[o](127.5*s+(s<0?1:0)),Math[i](127.5*l+(l<0?1:0))]):2==n?new Int16Array([Math[o](32767.5*s+(s<0?1:0)),Math[i](32767.5*l+(l<0?1:0))]):void 0}function u(e){let t=e[0],r=e[1];1==n?(t/=t<0?127:128,r/=r<0?127:128):2==n&&(t/=t<0?32767:32768,r/=r<0?32767:32768);const a=1-Math.abs(t)-Math.abs(r);if(a<0){const e=t;t=(1-Math.abs(r))*(t>=0?1:-1),r=(1-Math.abs(e))*(r>=0?1:-1)}const o=Math.sqrt(t*t+r*r+a*a);return[t/o,r/o,a/o]}function c(e,t,r,n){return e*n[0]+t*n[1]+r*n[2]}}function quantizedEncode(e,t){let r,n;1==t?(r=new Uint8Array(e.length),n=255):2==t?(r=new Uint16Array(e.length),n=65535):console.error("number of bytes error! ");const a=new Matrix4,o=new Float32Array(3),i=new Float32Array(3);o[0]=o[1]=o[2]=Number.MAX_VALUE,i[0]=i[1]=i[2]=-Number.MAX_VALUE;for(let t=0;t<e.length;t+=3)o[0]=Math.min(o[0],e[t+0]),o[1]=Math.min(o[1],e[t+1]),o[2]=Math.min(o[2],e[t+2]),i[0]=Math.max(i[0],e[t+0]),i[1]=Math.max(i[1],e[t+1]),i[2]=Math.max(i[2],e[t+2]);a.scale(new Vector3((i[0]-o[0])/n,(i[1]-o[1])/n,(i[2]-o[2])/n)),a.elements[12]=o[0],a.elements[13]=o[1],a.elements[14]=o[2],a.transpose();const s=new Float32Array([i[0]!==o[0]?n/(i[0]-o[0]):0,i[1]!==o[1]?n/(i[1]-o[1]):0,i[2]!==o[2]?n/(i[2]-o[2]):0]);for(let t=0;t<e.length;t+=3)r[t+0]=Math.floor((e[t+0]-o[0])*s[0]),r[t+1]=Math.floor((e[t+1]-o[1])*s[1]),r[t+2]=Math.floor((e[t+2]-o[2])*s[2]);return{quantized:r,decodeMat:a}}function quantizedEncodeUV(e,t){let r,n;1==t?(r=new Uint8Array(e.length),n=255):2==t?(r=new Uint16Array(e.length),n=65535):console.error("number of bytes error! ");const a=new Matrix3,o=new Float32Array(2),i=new Float32Array(2);o[0]=o[1]=Number.MAX_VALUE,i[0]=i[1]=-Number.MAX_VALUE;for(let t=0;t<e.length;t+=2)o[0]=Math.min(o[0],e[t+0]),o[1]=Math.min(o[1],e[t+1]),i[0]=Math.max(i[0],e[t+0]),i[1]=Math.max(i[1],e[t+1]);a.scale((i[0]-o[0])/n,(i[1]-o[1])/n),a.elements[6]=o[0],a.elements[7]=o[1],a.transpose();const s=new Float32Array([i[0]!==o[0]?n/(i[0]-o[0]):0,i[1]!==o[1]?n/(i[1]-o[1]):0]);for(let t=0;t<e.length;t+=2)r[t+0]=Math.floor((e[t+0]-o[0])*s[0]),r[t+1]=Math.floor((e[t+1]-o[1])*s[1]);return{quantized:r,decodeMat:a}}export{compressNormals,compressPositions,compressUvs};