import{BufferGeometry,Float32BufferAttribute,Vector3}from"three";import*as BufferGeometryUtils from"../utils/BufferGeometryUtils.js";const _cb=new Vector3,_ab=new Vector3;class SimplifyModifier{modify(e,t){const o=(e=e.clone()).attributes;for(const t in o)"position"!==t&&e.deleteAttribute(t);const s=[],i=[],r=(e=BufferGeometryUtils.mergeVertices(e)).getAttribute("position");for(let e=0;e<r.count;e++){const t=(new Vector3).fromBufferAttribute(r,e),o=new Vertex(t);s.push(o)}let n,h=e.getIndex();if(null!==h)for(let e=0;e<h.count;e+=3){const t=h.getX(e),o=h.getX(e+1),r=h.getX(e+2),n=new Triangle(s[t],s[o],s[r],t,o,r);i.push(n)}else for(let e=0;e<r.count;e+=3){const t=e,o=e+1,r=e+2,n=new Triangle(s[t],s[o],s[r],t,o,r);i.push(n)}for(let e=0,t=s.length;e<t;e++)computeEdgeCostAtVertex(s[e]);let l=t;for(;l--;){if(n=minimumCostEdge(s),!n){console.log("THREE.SimplifyModifier: No next vertex");break}collapse(s,i,n,n.collapseNeighbor)}const c=new BufferGeometry,a=[];h=[];for(let e=0;e<s.length;e++){const t=s[e].position;a.push(t.x,t.y,t.z),s[e].id=e}for(let e=0;e<i.length;e++){const t=i[e];h.push(t.v1.id,t.v2.id,t.v3.id)}return c.setAttribute("position",new Float32BufferAttribute(a,3)),c.setIndex(h),c}}function pushIfUnique(e,t){-1===e.indexOf(t)&&e.push(t)}function removeFromArray(e,t){const o=e.indexOf(t);o>-1&&e.splice(o,1)}function computeEdgeCollapseCost(e,t){const o=t.position.distanceTo(e.position);let s=0;const i=[];for(let o=0,s=e.faces.length;o<s;o++){const s=e.faces[o];s.hasVertex(t)&&i.push(s)}for(let t=0,o=e.faces.length;t<o;t++){let o=1;const r=e.faces[t];for(let e=0;e<i.length;e++){const t=i[e],s=r.normal.dot(t.normal);o=Math.min(o,(1.001-s)/2)}s=Math.max(s,o)}return i.length<2&&(s=1),o*s+0}function computeEdgeCostAtVertex(e){if(0===e.neighbors.length)return e.collapseNeighbor=null,void(e.collapseCost=-.01);e.collapseCost=1e5,e.collapseNeighbor=null;for(let t=0;t<e.neighbors.length;t++){const o=computeEdgeCollapseCost(e,e.neighbors[t]);e.collapseNeighbor||(e.collapseNeighbor=e.neighbors[t],e.collapseCost=o,e.minCost=o,e.totalCost=0,e.costCount=0),e.costCount++,e.totalCost+=o,o<e.minCost&&(e.collapseNeighbor=e.neighbors[t],e.minCost=o)}e.collapseCost=e.totalCost/e.costCount}function removeVertex(e,t){for(console.assert(0===e.faces.length);e.neighbors.length;)removeFromArray(e.neighbors.pop().neighbors,e);removeFromArray(t,e)}function removeFace(e,t){removeFromArray(t,e),e.v1&&removeFromArray(e.v1.faces,e),e.v2&&removeFromArray(e.v2.faces,e),e.v3&&removeFromArray(e.v3.faces,e);const o=[e.v1,e.v2,e.v3];for(let e=0;e<3;e++){const t=o[e],s=o[(e+1)%3];t&&s&&(t.removeIfNonNeighbor(s),s.removeIfNonNeighbor(t))}}function collapse(e,t,o,s){if(!s)return void removeVertex(o,e);const i=[];for(let e=0;e<o.neighbors.length;e++)i.push(o.neighbors[e]);for(let e=o.faces.length-1;e>=0;e--)o.faces[e]&&o.faces[e].hasVertex(s)&&removeFace(o.faces[e],t);for(let e=o.faces.length-1;e>=0;e--)o.faces[e].replaceVertex(o,s);removeVertex(o,e);for(let e=0;e<i.length;e++)computeEdgeCostAtVertex(i[e])}function minimumCostEdge(e){let t=e[0];for(let o=0;o<e.length;o++)e[o].collapseCost<t.collapseCost&&(t=e[o]);return t}class Triangle{constructor(e,t,o,s,i,r){this.a=s,this.b=i,this.c=r,this.v1=e,this.v2=t,this.v3=o,this.normal=new Vector3,this.computeNormal(),e.faces.push(this),e.addUniqueNeighbor(t),e.addUniqueNeighbor(o),t.faces.push(this),t.addUniqueNeighbor(e),t.addUniqueNeighbor(o),o.faces.push(this),o.addUniqueNeighbor(e),o.addUniqueNeighbor(t)}computeNormal(){const e=this.v1.position,t=this.v2.position,o=this.v3.position;_cb.subVectors(o,t),_ab.subVectors(e,t),_cb.cross(_ab).normalize(),this.normal.copy(_cb)}hasVertex(e){return e===this.v1||e===this.v2||e===this.v3}replaceVertex(e,t){e===this.v1?this.v1=t:e===this.v2?this.v2=t:e===this.v3&&(this.v3=t),removeFromArray(e.faces,this),t.faces.push(this),e.removeIfNonNeighbor(this.v1),this.v1.removeIfNonNeighbor(e),e.removeIfNonNeighbor(this.v2),this.v2.removeIfNonNeighbor(e),e.removeIfNonNeighbor(this.v3),this.v3.removeIfNonNeighbor(e),this.v1.addUniqueNeighbor(this.v2),this.v1.addUniqueNeighbor(this.v3),this.v2.addUniqueNeighbor(this.v1),this.v2.addUniqueNeighbor(this.v3),this.v3.addUniqueNeighbor(this.v1),this.v3.addUniqueNeighbor(this.v2),this.computeNormal()}}class Vertex{constructor(e){this.position=e,this.id=-1,this.faces=[],this.neighbors=[],this.collapseCost=0,this.collapseNeighbor=null}addUniqueNeighbor(e){pushIfUnique(this.neighbors,e)}removeIfNonNeighbor(e){const t=this.neighbors,o=this.faces,s=t.indexOf(e);if(-1!==s){for(let t=0;t<o.length;t++)if(o[t].hasVertex(e))return;t.splice(s,1)}}}export{SimplifyModifier};