const CHANNELS=4,TEXTURE_WIDTH=1024,TEXTURE_HEIGHT=4;import{DataTexture,RGBAFormat,FloatType,RepeatWrapping,Mesh,InstancedMesh,NearestFilter,DynamicDrawUsage,Matrix4}from"three";export function initSplineTexture(e=1){const t=new Float32Array(4096*e*4),n=new DataTexture(t,1024,4*e,RGBAFormat,FloatType);return n.wrapS=RepeatWrapping,n.wrapY=RepeatWrapping,n.magFilter=NearestFilter,n.needsUpdate=!0,n}export function updateSplineTexture(e,t,n=0){const r=Math.floor(1024);t.arcLengthDivisions=r/2,t.updateArcLengths();const a=t.getSpacedPoints(r),s=t.computeFrenetFrames(r,!0);for(let t=0;t<r;t++){const r=Math.floor(t/1024),i=t%1024;let o=a[t];setTextureValue(e,i,o.x,o.y,o.z,0+r+4*n),o=s.tangents[t],setTextureValue(e,i,o.x,o.y,o.z,1+r+4*n),o=s.normals[t],setTextureValue(e,i,o.x,o.y,o.z,2+r+4*n),o=s.binormals[t],setTextureValue(e,i,o.x,o.y,o.z,3+r+4*n)}e.needsUpdate=!0}function setTextureValue(e,t,n,r,a,s){const i=e.image,{data:o}=i,f=4096*s;o[4*t+f+0]=n,o[4*t+f+1]=r,o[4*t+f+2]=a,o[4*t+f+3]=1}export function getUniforms(e){return{spineTexture:{value:e},pathOffset:{type:"f",value:0},pathSegment:{type:"f",value:1},spineOffset:{type:"f",value:161},spineLength:{type:"f",value:400},flow:{type:"i",value:1}}}export function modifyShader(e,t,n=1){e.__ok||(e.__ok=!0,e.onBeforeCompile=e=>{if(e.__modified)return;e.__modified=!0,Object.assign(e.uniforms,t);const r=`\n\t\tuniform sampler2D spineTexture;\n\t\tuniform float pathOffset;\n\t\tuniform float pathSegment;\n\t\tuniform float spineOffset;\n\t\tuniform float spineLength;\n\t\tuniform int flow;\n\n\t\tfloat textureLayers = ${4*n}.;\n\t\tfloat textureStacks = 1.;\n\n\t\t${e.vertexShader}\n\t\t`.replace("#include <beginnormal_vertex>","").replace("#include <defaultnormal_vertex>","").replace("#include <begin_vertex>","").replace(/void\s*main\s*\(\)\s*\{/,"\nvoid main() {\n#include <beginnormal_vertex>\n\nvec4 worldPos = modelMatrix * vec4(position, 1.);\n\nbool bend = flow > 0;\nfloat xWeight = bend ? 0. : 1.;\n\n#ifdef USE_INSTANCING\nfloat pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\nfloat spineLengthFromInstanceMatrix = instanceMatrix[3][0];\nfloat spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\nfloat mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\n#else\nfloat spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\nfloat mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\n#endif\n\nmt = mod(mt, textureStacks);\nfloat rowOffset = floor(mt);\n\n#ifdef USE_INSTANCING\nrowOffset += instanceMatrix[3][1] * 4.;\n#endif\n\nvec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\nvec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\nmat3 basis = mat3(a, b, c);\n\nvec3 transformed = basis\n\t* vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\n\t+ spinePos;\n\nvec3 transformedNormal = normalMatrix * (basis * objectNormal);\n\t\t\t").replace("#include <project_vertex>","vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\t\t\t\tgl_Position = projectionMatrix * mvPosition;");e.vertexShader=r})}export class Flow{constructor(e,t=1){const n=e.clone(),r=initSplineTexture(t),a=getUniforms(r);n.traverse((function(e){(e instanceof Mesh||e instanceof InstancedMesh)&&(e.material=e.material.clone(),modifyShader(e.material,a,t))})),this.curveArray=new Array(t),this.curveLengthArray=new Array(t),this.object3D=n,this.splineTexure=r,this.uniforms=a}updateCurve(e,t){if(e>=this.curveArray.length)throw Error("Index out of range for Flow");const n=t.getLength();this.uniforms.spineLength.value=n,this.curveLengthArray[e]=n,this.curveArray[e]=t,updateSplineTexture(this.splineTexure,t,e)}moveAlongCurve(e){this.uniforms.pathOffset.value+=e}}const matrix=new Matrix4;export class InstancedFlow extends Flow{constructor(e,t,n,r){const a=new InstancedMesh(n,r,e);a.instanceMatrix.setUsage(DynamicDrawUsage),a.frustumCulled=!1,super(a,t),this.offsets=new Array(e).fill(0),this.whichCurve=new Array(e).fill(0)}writeChanges(e){matrix.makeTranslation(this.curveLengthArray[this.whichCurve[e]],this.whichCurve[e],this.offsets[e]),this.object3D.setMatrixAt(e,matrix),this.object3D.instanceMatrix.needsUpdate=!0}moveIndividualAlongCurve(e,t){this.offsets[e]+=t,this.writeChanges(e)}setCurve(e,t){if(isNaN(t))throw Error("curve index being set is Not a Number (NaN)");this.whichCurve[e]=t,this.writeChanges(e)}}