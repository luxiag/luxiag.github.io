import{BufferAttribute,BufferGeometry,Vector3}from"three";import*as BufferGeometryUtils from"../utils/BufferGeometryUtils.js";const _A=new Vector3,_B=new Vector3,_C=new Vector3;class EdgeSplitModifier{modify(t,e,r=!0){function o(t,e,r){_A.set(f[3*r],f[3*r+1],f[3*r+2]).normalize();const o={splitGroup:[],currentGroup:[r]};for(const n of t)n!==r&&(_B.set(f[3*n],f[3*n+1],f[3*n+2]).normalize(),_B.dot(_A)<e?o.splitGroup.push(n):o.currentGroup.push(n));return o}function n(t,e,r=null){if(0===t.length)return;const l=[];for(const r of t)l.push(o(t,e,r));let s=l[0];for(const t of l)t.currentGroup.length>s.currentGroup.length&&(s=t);null!=r&&a.push({original:r,indexes:s.currentGroup}),s.splitGroup.length&&n(s.splitGroup,e,r||s.currentGroup[0])}let l=!1,s=null;t.attributes.normal&&(l=!0,t=t.clone(),!0===r&&null!==t.index&&(s=t.attributes.normal.array),t.deleteAttribute("normal")),null==t.index&&(t=BufferGeometryUtils.mergeVertices(t));const i=t.index.array,u=t.getAttribute("position").array;let f,c;!function(){f=new Float32Array(3*i.length);for(let t=0;t<i.length;t+=3){let e=i[t];_A.set(u[3*e],u[3*e+1],u[3*e+2]),e=i[t+1],_B.set(u[3*e],u[3*e+1],u[3*e+2]),e=i[t+2],_C.set(u[3*e],u[3*e+1],u[3*e+2]),_C.sub(_B),_A.sub(_B);const r=_C.cross(_A).normalize();for(let e=0;e<3;e++)f[3*(t+e)]=r.x,f[3*(t+e)+1]=r.y,f[3*(t+e)+2]=r.z}}(),function(){c=Array(u.length/3);for(let t=0;t<i.length;t++){const e=i[t];null==c[e]&&(c[e]=[]),c[e].push(t)}}();const a=[];for(const t of c)n(t,Math.cos(e)-.001);const m={};for(const e of Object.keys(t.attributes)){const r=t.attributes[e],o=new r.array.constructor((i.length+a.length)*r.itemSize);o.set(r.array),m[e]=new BufferAttribute(o,r.itemSize,r.normalized)}const p=new Uint32Array(i.length);p.set(i);for(let t=0;t<a.length;t++){const e=a[t],r=i[e.original];for(const e of Object.values(m))for(let o=0;o<e.itemSize;o++)e.array[(i.length+t)*e.itemSize+o]=e.array[r*e.itemSize+o];for(const r of e.indexes)p[r]=i.length+t}(t=new BufferGeometry).setIndex(new BufferAttribute(p,1));for(const e of Object.keys(m))t.setAttribute(e,m[e]);if(l&&(t.computeVertexNormals(),null!==s)){const e=new Array(s.length/3).fill(!1);for(const t of a)e[t.original]=!0;for(let r=0;r<e.length;r++)if(!1===e[r])for(let e=0;e<3;e++)t.attributes.normal.array[3*r+e]=s[3*r+e]}return t}}export{EdgeSplitModifier};