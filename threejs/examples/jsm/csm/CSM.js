import{Vector2,Vector3,DirectionalLight,MathUtils,ShaderChunk,Matrix4,Box3}from"three";import{CSMFrustum}from"./CSMFrustum.js";import{CSMShader}from"./CSMShader.js";const _cameraToLightMatrix=new Matrix4,_lightSpaceFrustum=new CSMFrustum,_center=new Vector3,_bbox=new Box3,_uniformArray=[],_logArray=[],_lightOrientationMatrix=new Matrix4,_lightOrientationMatrixInverse=new Matrix4,_up=new Vector3(0,1,0);export class CSM{constructor(t){t=t||{},this.camera=t.camera,this.parent=t.parent,this.cascades=t.cascades||3,this.maxFar=t.maxFar||1e5,this.mode=t.mode||"practical",this.shadowMapSize=t.shadowMapSize||2048,this.shadowBias=t.shadowBias||1e-6,this.lightDirection=t.lightDirection||new Vector3(1,-1,1).normalize(),this.lightIntensity=t.lightIntensity||1,this.lightNear=t.lightNear||1,this.lightFar=t.lightFar||2e3,this.lightMargin=t.lightMargin||200,this.customSplitsCallback=t.customSplitsCallback,this.fade=!1,this.mainFrustum=new CSMFrustum,this.frustums=[],this.breaks=[],this.lights=[],this.shaders=new Map,this.createLights(),this.updateFrustums(),this.injectInclude()}createLights(){for(let t=0;t<this.cascades;t++){const t=new DirectionalLight(16777215,this.lightIntensity);t.castShadow=!0,t.shadow.mapSize.width=this.shadowMapSize,t.shadow.mapSize.height=this.shadowMapSize,t.shadow.camera.near=this.lightNear,t.shadow.camera.far=this.lightFar,t.shadow.bias=this.shadowBias,this.parent.add(t),this.parent.add(t.target),this.lights.push(t)}}initCascades(){const t=this.camera;t.updateProjectionMatrix(),this.mainFrustum.setFromProjectionMatrix(t.projectionMatrix,this.maxFar),this.mainFrustum.split(this.breaks,this.frustums)}updateShadowBounds(){const t=this.frustums;for(let e=0;e<t.length;e++){const t=this.lights[e].shadow.camera,i=this.frustums[e],a=i.vertices.near,s=i.vertices.far,r=s[0];let h;h=r.distanceTo(s[2])>r.distanceTo(a[2])?s[2]:a[2];let n=r.distanceTo(h);if(this.fade){const t=this.camera,e=Math.max(t.far,this.maxFar),a=i.vertices.far[0].z/(e-t.near);n+=.25*Math.pow(a,2)*(e-t.near)}t.left=-n/2,t.right=n/2,t.top=n/2,t.bottom=-n/2,t.updateProjectionMatrix()}}getBreaks(){const t=this.camera,e=Math.min(t.far,this.maxFar);switch(this.breaks.length=0,this.mode){case"uniform":i(this.cascades,t.near,e,this.breaks);break;case"logarithmic":a(this.cascades,t.near,e,this.breaks);break;case"practical":!function(t,e,s,r,h){_uniformArray.length=0,_logArray.length=0,a(t,e,s,_logArray),i(t,e,s,_uniformArray);for(let e=1;e<t;e++)h.push(MathUtils.lerp(_uniformArray[e-1],_logArray[e-1],.5));h.push(1)}(this.cascades,t.near,e,0,this.breaks);break;case"custom":void 0===this.customSplitsCallback&&console.error("CSM: Custom split scheme callback not defined."),this.customSplitsCallback(this.cascades,t.near,e,this.breaks)}function i(t,e,i,a){for(let s=1;s<t;s++)a.push((e+(i-e)*s/t)/i);a.push(1)}function a(t,e,i,a){for(let s=1;s<t;s++)a.push(e*(i/e)**(s/t)/i);a.push(1)}}update(){const t=this.camera,e=this.frustums;_lightOrientationMatrix.lookAt(new Vector3,this.lightDirection,_up),_lightOrientationMatrixInverse.copy(_lightOrientationMatrix).invert();for(let i=0;i<e.length;i++){const a=this.lights[i],s=a.shadow.camera,r=(s.right-s.left)/this.shadowMapSize,h=(s.top-s.bottom)/this.shadowMapSize;_cameraToLightMatrix.multiplyMatrices(_lightOrientationMatrixInverse,t.matrixWorld),e[i].toSpace(_cameraToLightMatrix,_lightSpaceFrustum);const n=_lightSpaceFrustum.vertices.near,o=_lightSpaceFrustum.vertices.far;_bbox.makeEmpty();for(let t=0;t<4;t++)_bbox.expandByPoint(n[t]),_bbox.expandByPoint(o[t]);_bbox.getCenter(_center),_center.z=_bbox.max.z+this.lightMargin,_center.x=Math.floor(_center.x/r)*r,_center.y=Math.floor(_center.y/h)*h,_center.applyMatrix4(_lightOrientationMatrix),a.position.copy(_center),a.target.position.copy(_center),a.target.position.x+=this.lightDirection.x,a.target.position.y+=this.lightDirection.y,a.target.position.z+=this.lightDirection.z}}injectInclude(){ShaderChunk.lights_fragment_begin=CSMShader.lights_fragment_begin,ShaderChunk.lights_pars_begin=CSMShader.lights_pars_begin}setupMaterial(t){t.defines=t.defines||{},t.defines.USE_CSM=1,t.defines.CSM_CASCADES=this.cascades,this.fade&&(t.defines.CSM_FADE="");const e=[],i=this,a=this.shaders;t.onBeforeCompile=function(s){const r=Math.min(i.camera.far,i.maxFar);i.getExtendedBreaks(e),s.uniforms.CSM_cascades={value:e},s.uniforms.cameraNear={value:i.camera.near},s.uniforms.shadowFar={value:r},a.set(t,s)},a.set(t,null)}updateUniforms(){const t=Math.min(this.camera.far,this.maxFar);this.shaders.forEach((function(e,i){if(null!==e){const i=e.uniforms;this.getExtendedBreaks(i.CSM_cascades.value),i.cameraNear.value=this.camera.near,i.shadowFar.value=t}!this.fade&&"CSM_FADE"in i.defines?(delete i.defines.CSM_FADE,i.needsUpdate=!0):this.fade&&!("CSM_FADE"in i.defines)&&(i.defines.CSM_FADE="",i.needsUpdate=!0)}),this)}getExtendedBreaks(t){for(;t.length<this.breaks.length;)t.push(new Vector2);t.length=this.breaks.length;for(let e=0;e<this.cascades;e++){const i=this.breaks[e],a=this.breaks[e-1]||0;t[e].x=a,t[e].y=i}}updateFrustums(){this.getBreaks(),this.initCascades(),this.updateShadowBounds(),this.updateUniforms()}remove(){for(let t=0;t<this.lights.length;t++)this.parent.remove(this.lights[t].target),this.parent.remove(this.lights[t])}dispose(){const t=this.shaders;t.forEach((function(t,e){delete e.onBeforeCompile,delete e.defines.USE_CSM,delete e.defines.CSM_CASCADES,delete e.defines.CSM_FADE,null!==t&&(delete t.uniforms.CSM_cascades,delete t.uniforms.cameraNear,delete t.uniforms.shadowFar),e.needsUpdate=!0})),t.clear()}}