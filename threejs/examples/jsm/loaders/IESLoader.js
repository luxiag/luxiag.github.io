import{DataTexture,FileLoader,FloatType,RedFormat,MathUtils,Loader,UnsignedByteType,LinearFilter,HalfFloatType,DataUtils}from"three";class IESLoader extends Loader{constructor(e){super(e),this.type=HalfFloatType}_getIESValues(e,t){const l=new Array(64800);function r(t,l){let r=0,n=0,a=0,s=0,o=0,u=0;for(let t=0;t<e.numHorAngles-1;++t)if(l<e.horAngles[t+1]||t==e.numHorAngles-2){n=t,a=e.horAngles[t],s=e.horAngles[t+1];break}for(let l=0;l<e.numVerAngles-1;++l)if(t<e.verAngles[l+1]||l==e.numVerAngles-2){r=l,o=e.verAngles[l],u=e.verAngles[l+1];break}const i=s-a,m=u-o;if(0===m)return 0;const g=0===i?0:(l-a)/i,c=(t-o)/m,p=0===i?n:n+1,A=MathUtils.lerp(e.candelaValues[n][r],e.candelaValues[p][r],g),d=MathUtils.lerp(e.candelaValues[n][r+1],e.candelaValues[p][r+1],g);return MathUtils.lerp(A,d,c)}const n=e.horAngles[0],a=e.horAngles[e.numHorAngles-1];for(let e=0;e<64800;++e){let t=e%360;const s=Math.floor(e/360);a-n!=0&&(t<n||t>=a)&&(t%=2*a,t>a&&(t=2*a-t)),l[s+180*t]=r(s,t)}let s=null;return t===UnsignedByteType?s=Uint8Array.from(l.map((e=>Math.min(255*e,255)))):t===HalfFloatType?s=Uint16Array.from(l.map((e=>DataUtils.toHalfFloat(e)))):t===FloatType?s=Float32Array.from(l):console.error("IESLoader: Unsupported type:",t),s}load(e,t,l,r){const n=new FileLoader(this.manager);n.setResponseType("text"),n.setCrossOrigin(this.crossOrigin),n.setWithCredentials(this.withCredentials),n.setPath(this.path),n.setRequestHeader(this.requestHeader),n.load(e,(e=>{t(this.parse(e))}),l,r)}parse(e){const t=this.type,l=new IESLamp(e),r=this._getIESValues(l,t),n=new DataTexture(r,180,1,RedFormat,t);return n.minFilter=LinearFilter,n.magFilter=LinearFilter,n.needsUpdate=!0,n}}function IESLamp(e){const t=this,l=e.split("\n");let r,n=0;function a(e){return(e=(e=(e=e.replace(/^\s+|\s+$/g,"")).replace(/,/g," ")).replace(/\s\s+/g," ")).split(" ")}function s(e,t){for(;;){const r=a(l[n++]);for(let e=0;e<r.length;++e)t.push(Number(r[e]));if(t.length===e)break}}for(t.verAngles=[],t.horAngles=[],t.candelaValues=[],t.tiltData={},t.tiltData.angles=[],t.tiltData.mulFactors=[];r=l[n++],!r.includes("TILT"););r.includes("NONE")||r.includes("INCLUDE")&&function(){let e=l[n++],r=a(e);t.tiltData.lampToLumGeometry=Number(r[0]),e=l[n++],r=a(e),t.tiltData.numAngles=Number(r[0]),s(t.tiltData.numAngles,t.tiltData.angles),s(t.tiltData.numAngles,t.tiltData.mulFactors)}(),function(){const e=[];s(10,e),t.count=Number(e[0]),t.lumens=Number(e[1]),t.multiplier=Number(e[2]),t.numVerAngles=Number(e[3]),t.numHorAngles=Number(e[4]),t.gonioType=Number(e[5]),t.units=Number(e[6]),t.width=Number(e[7]),t.length=Number(e[8]),t.height=Number(e[9])}(),function(){const e=[];s(3,e),t.ballFactor=Number(e[0]),t.blpFactor=Number(e[1]),t.inputWatts=Number(e[2])}();for(let e=0;e<t.numHorAngles;++e)t.candelaValues.push([]);s(t.numVerAngles,t.verAngles),s(t.numHorAngles,t.horAngles);for(let e=0;e<t.numHorAngles;++e)s(t.numVerAngles,t.candelaValues[e]);for(let e=0;e<t.numHorAngles;++e)for(let l=0;l<t.numVerAngles;++l)t.candelaValues[e][l]*=t.candelaValues[e][l]*t.multiplier*t.ballFactor*t.blpFactor;let o=-1;for(let e=0;e<t.numHorAngles;++e)for(let l=0;l<t.numVerAngles;++l){const r=t.candelaValues[e][l];o=o<r?r:o}if(o>0)for(let e=0;e<t.numHorAngles;++e)for(let l=0;l<t.numVerAngles;++l)t.candelaValues[e][l]/=o}export{IESLoader};