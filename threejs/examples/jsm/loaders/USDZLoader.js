import{BufferAttribute,BufferGeometry,ClampToEdgeWrapping,FileLoader,Group,Loader,Mesh,MeshStandardMaterial,MirroredRepeatWrapping,RepeatWrapping,SRGBColorSpace,TextureLoader,Object3D}from"three";import*as fflate from"../libs/fflate.module.js";class USDAParser{parse(e){const t={},r=e.split("\n"),n=r.length;let i=0,o=null,s=t;const a=[t];return function e(){const t=r[i];if(t.includes("=")){const e=t.split("="),r=e[0].trim(),n=e[1].trim();if(n.endsWith("{")){const e={};a.push(e),s[r]=e,s=e}else s[r]=n}else if(t.endsWith("{")){const e=s[o]||{};a.push(e),s[o]=e,s=e}else if(t.endsWith("}")){if(a.pop(),0===a.length)return;s=a[a.length-1]}else if(t.endsWith("(")){const e={};a.push(e),o=t.split("(")[0].trim()||o,s[o]=e,s=e}else t.endsWith(")")?(a.pop(),s=a[a.length-1]):o=t.trim();i++,i<n&&e()}(),t}}class USDZLoader extends Loader{constructor(e){super(e)}load(e,t,r,n){const i=this,o=new FileLoader(i.manager);o.setPath(i.path),o.setResponseType("arraybuffer"),o.setRequestHeader(i.requestHeader),o.setWithCredentials(i.withCredentials),o.load(e,(function(r){try{t(i.parse(r))}catch(t){n?n(t):console.error(t),i.manager.itemError(e)}}),r,n)}parse(e){const t=new USDAParser,r=fflate.unzipSync(new Uint8Array(e)),n=function(e){const r={};(new FileLoader).setResponseType("arraybuffer");for(const n in e){if(n.endsWith("png")){const t=new Blob([e[n]],{type:{type:"image/png"}});r[n]=URL.createObjectURL(t)}if(n.endsWith("usd")){const i=fflate.strFromU8(e[n]);r[n]=t.parse(i)}}return r}(r),i=function(e){for(const t in e)if(t.endsWith("usda"))return e[t]}(r);if(void 0===i)return console.warn("THREE.USDZLoader: No usda file found."),new Group;const o=fflate.strFromU8(i),s=t.parse(o);function a(e,t){if(void 0!==t){const r=`def "${t}"`;if(r in e)return e[r]}for(const t in e){const r=e[t];if(t.startsWith("def Mesh"))return"point3f[] points"in e&&(r["point3f[] points"]=e["point3f[] points"]),"float2[] primvars:st"in e&&(r["float2[] primvars:st"]=e["float2[] primvars:st"]),"int[] primvars:st:indices"in e&&(r["int[] primvars:st:indices"]=e["int[] primvars:st:indices"]),r;if("object"==typeof r){const e=a(r);if(e)return e}}}function f(e,t=""){for(const r in e){const n=e[r];if(r.startsWith("def Material"+t))return n;if("object"==typeof n){const e=f(n,t);if(e)return e}}}function p(e,t){for(const r in e){const n=e[r];if(r.startsWith(`def Shader "${t}"`))return n;if("object"==typeof n){const e=p(n,t);if(e)return e}}}function c(e){if("asset inputs:file"in e){const t=e["asset inputs:file"].replace(/@*/g,""),r=(new TextureLoader).load(n[t]),i={'"clamp"':ClampToEdgeWrapping,'"mirror"':MirroredRepeatWrapping,'"repeat"':RepeatWrapping};return"token inputs:wrapS"in e&&(r.wrapS=i[e["token inputs:wrapS"]]),"token inputs:wrapT"in e&&(r.wrapT=i[e["token inputs:wrapT"]]),r}return null}function l(e){const t=function(e){if(!e)return;let t=new BufferGeometry;if("int[] faceVertexIndices"in e){const r=JSON.parse(e["int[] faceVertexIndices"]);t.setIndex(new BufferAttribute(new Uint16Array(r),1))}if("point3f[] points"in e){const r=JSON.parse(e["point3f[] points"].replace(/[()]*/g,"")),n=new BufferAttribute(new Float32Array(r),3);t.setAttribute("position",n)}if("normal3f[] normals"in e){const r=JSON.parse(e["normal3f[] normals"].replace(/[()]*/g,"")),n=new BufferAttribute(new Float32Array(r),3);t.setAttribute("normal",n)}else t.computeVertexNormals();if("float2[] primvars:st"in e&&(e["texCoord2f[] primvars:st"]=e["float2[] primvars:st"]),"texCoord2f[] primvars:st"in e){const r=JSON.parse(e["texCoord2f[] primvars:st"].replace(/[()]*/g,"")),n=new BufferAttribute(new Float32Array(r),2);if("int[] primvars:st:indices"in e){t=t.toNonIndexed();const r=JSON.parse(e["int[] primvars:st:indices"]);t.setAttribute("uv",function(e,t){const r=e.array,n=e.itemSize,i=new r.constructor(t.length*n);let o=0,s=0;for(let e=0,a=t.length;e<a;e++){o=t[e]*n;for(let e=0;e<n;e++)i[s++]=r[o++]}return new BufferAttribute(i,n)}(n,r))}else t.setAttribute("uv",n)}return t}(function(e){if(e){if("prepend references"in e){const t=e["prepend references"].split("@"),r=t[1].replace(/^.\//,""),i=t[2].replace(/^<\//,"").replace(/>$/,"");return a(n[r],i)}return a(e)}}(e)),r=function(e){const t=new MeshStandardMaterial;if(void 0!==e){if('def Shader "PreviewSurface"'in e){const r=e['def Shader "PreviewSurface"'];if("color3f inputs:diffuseColor.connect"in r){const e=r["color3f inputs:diffuseColor.connect"],n=p(s,/(\w+).output/.exec(e)[1]);t.map=c(n),t.map.colorSpace=SRGBColorSpace}else if("color3f inputs:diffuseColor"in r){const e=r["color3f inputs:diffuseColor"].replace(/[()]*/g,"");t.color.fromArray(JSON.parse("["+e+"]"))}if("normal3f inputs:normal.connect"in r){const e=r["normal3f inputs:normal.connect"],n=p(s,/(\w+).output/.exec(e)[1]);t.normalMap=c(n)}"float inputs:roughness"in r&&(t.roughness=parseFloat(r["float inputs:roughness"])),"float inputs:metallic"in r&&(t.metalness=parseFloat(r["float inputs:metallic"]))}if('def Shader "diffuseColor_texture"'in e){const r=e['def Shader "diffuseColor_texture"'];t.map=c(r),t.map.colorSpace=SRGBColorSpace}if('def Shader "normal_texture"'in e){const r=e['def Shader "normal_texture"'];t.normalMap=c(r)}}return t}(function(e){if(e){if("rel material:binding"in e){const t=e["rel material:binding"].replace(/^<\//,"").replace(/>$/,"").split("/");return f(s,` "${t[1]}"`)}return f(e)}}(e)),i=t?new Mesh(t,r):new Object3D;if("matrix4d xformOp:transform"in e){const t=JSON.parse("["+e["matrix4d xformOp:transform"].replace(/[()]*/g,"")+"]");i.matrix.fromArray(t),i.matrix.decompose(i.position,i.quaternion,i.scale)}return i}const u=new Group;return function e(t,r){for(const n in t)if(n.startsWith("def Scope"))e(t[n],r);else if(n.startsWith("def Xform")){const i=l(t[n]);/def Xform "(\w+)"/.test(n)&&(i.name=/def Xform "(\w+)"/.exec(n)[1]),r.add(i),e(t[n],i)}}(s,u),u}}export{USDZLoader};