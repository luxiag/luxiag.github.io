import{BufferAttribute,BufferGeometry,FileLoader,Float32BufferAttribute,Loader}from"three";import*as fflate from"../libs/fflate.module.js";class VTKLoader extends Loader{constructor(t){super(t)}load(t,e,r,n){const s=this,o=new FileLoader(s.manager);o.setPath(s.path),o.setResponseType("arraybuffer"),o.setRequestHeader(s.requestHeader),o.setWithCredentials(s.withCredentials),o.load(t,(function(r){try{e(s.parse(r))}catch(e){n?n(e):console.error(e),s.manager.itemError(t)}}),r,n)}parse(t){function e(t,e){const r=t.length,n=new Float32Array(r+e.length);return n.set(t),n.set(e,r),n}function r(t,e){const r=t.length,n=new Int32Array(r+e.length);return n.set(t),n.set(e,r),n}const n=new TextDecoder,s=n.decode(new Uint8Array(t,0,250)).split("\n");return-1!==s[0].indexOf("xml")?function(t){function n(t){const e="undefined"!=typeof Uint8Array?Uint8Array:Array,r=[],n="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(let t=0,e=n.length;t<e;++t)r[n.charCodeAt(t)]=t;r["-".charCodeAt(0)]=62,r["_".charCodeAt(0)]=63;const s=t.length;if(s%4>0)throw new Error("Invalid string. Length must be a multiple of 4");const o="="===t[s-2]?2:"="===t[s-1]?1:0,a=new e(3*s/4-o),l=o>0?s-4:s;let i,f,u=0;for(i=0,f=0;i<l;i+=4,f+=3){const e=r[t.charCodeAt(i)]<<18|r[t.charCodeAt(i+1)]<<12|r[t.charCodeAt(i+2)]<<6|r[t.charCodeAt(i+3)];a[u++]=(16711680&e)>>16,a[u++]=(65280&e)>>8,a[u++]=255&e}if(2===o){const e=r[t.charCodeAt(i)]<<2|r[t.charCodeAt(i+1)]>>4;a[u++]=255&e}else if(1===o){const e=r[t.charCodeAt(i)]<<10|r[t.charCodeAt(i+1)]<<4|r[t.charCodeAt(i+2)]>>2;a[u++]=e>>8&255,a[u++]=255&e}return a}function s(t,s){let a,l,i=0;if("UInt64"===o.attributes.header_type?i=8:"UInt32"===o.attributes.header_type&&(i=4),"binary"===t.attributes.format&&s){"Float32"===t.attributes.type?a=new Float32Array:"Int32"!==t.attributes.type&&"Int64"!==t.attributes.type||(a=new Int32Array);const s=t["#text"],o=n(Array.isArray(s)?s[0]:s),f=8;let u=o[0];for(let t=1;t<i-1;t++)u|=o[t]<<t*f;let c=(u+3)*i;c+=c%3>0?3-c%3:0;const p=[];let A=c;p.push(A);const d=3*i;for(let t=0;t<u;t++){let e=o[t*i+d];for(let r=1;r<i-1;r++)e|=o[t*i+d+r]<<r*f;A+=e,p.push(A)}for(let n=0;n<p.length-1;n++)l=fflate.unzlibSync(o.slice(p[n],p[n+1])).buffer,"Float32"===t.attributes.type?(l=new Float32Array(l),a=e(a,l)):"Int32"!==t.attributes.type&&"Int64"!==t.attributes.type||(l=new Int32Array(l),a=r(a,l));delete t["#text"],"Int64"===t.attributes.type&&"binary"===t.attributes.format&&(a=a.filter((function(t,e){if(e%2!=1)return!0})))}else"binary"!==t.attributes.format||s?l=t["#text"]?t["#text"].split(/\s+/).filter((function(t){if(""!==t)return t})):new Int32Array(0).buffer:(l=n(t["#text"]),l=l.slice(i).buffer),delete t["#text"],"Float32"===t.attributes.type?a=new Float32Array(l):"Int32"===t.attributes.type?a=new Int32Array(l):"Int64"===t.attributes.type&&(a=new Int32Array(l),"binary"===t.attributes.format&&(a=a.filter((function(t,e){if(e%2!=1)return!0}))));return a}const o=function t(e){let r={};if(1===e.nodeType){if(e.attributes&&e.attributes.length>0){r.attributes={};for(let t=0;t<e.attributes.length;t++){const n=e.attributes.item(t);r.attributes[n.nodeName]=n.nodeValue.trim()}}}else 3===e.nodeType&&(r=e.nodeValue.trim());if(e.hasChildNodes())for(let n=0;n<e.childNodes.length;n++){const s=e.childNodes.item(n),o=s.nodeName;if(void 0===r[o]){const e=t(s);""!==e&&(r[o]=e)}else{if(void 0===r[o].push){const t=r[o];r[o]=[t]}const e=t(s);""!==e&&r[o].push(e)}}return r}((new DOMParser).parseFromString(t,"application/xml").documentElement);let a=[],l=[],i=[];if(o.PolyData){const t=o.PolyData.Piece,e=o.attributes.hasOwnProperty("compressor"),r=["PointData","Points","Strips","Polys"];let n=0;const f=r.length;for(;n<f;){const o=t[r[n]];if(o&&o.DataArray){let f;f=Array.isArray(o.DataArray)?o.DataArray:[o.DataArray];let u=0;const c=f.length;for(;u<c;)"#text"in f[u]&&f[u]["#text"].length>0&&(f[u].text=s(f[u],e)),u++;switch(r[n]){case"PointData":{const e=parseInt(t.attributes.NumberOfPoints),r=o.attributes.Normals;if(e>0)for(let t=0,n=f.length;t<n;t++)if(r===f[t].attributes.Name){const r=f[t].attributes.NumberOfComponents;l=new Float32Array(e*r),l.set(f[t].text,0)}}break;case"Points":{const e=parseInt(t.attributes.NumberOfPoints);if(e>0){const t=o.DataArray.attributes.NumberOfComponents;a=new Float32Array(e*t),a.set(o.DataArray.text,0)}}break;case"Strips":{const e=parseInt(t.attributes.NumberOfStrips);if(e>0){const t=new Int32Array(o.DataArray[0].text.length),r=new Int32Array(o.DataArray[1].text.length);t.set(o.DataArray[0].text,0),r.set(o.DataArray[1].text,0);const n=e+t.length;i=new Uint32Array(3*n-9*e);let s=0;for(let n=0,o=e;n<o;n++){const e=[];for(let s=0,o=r[n],a=0;s<o-a;s++)e.push(t[s]),n>0&&(a=r[n-1]);for(let t=0,o=r[n],a=0;t<o-a-2;t++)t%2?(i[s++]=e[t],i[s++]=e[t+2],i[s++]=e[t+1]):(i[s++]=e[t],i[s++]=e[t+1],i[s++]=e[t+2]),n>0&&(a=r[n-1])}}}break;case"Polys":{const e=parseInt(t.attributes.NumberOfPolys);if(e>0){const t=new Int32Array(o.DataArray[0].text.length),r=new Int32Array(o.DataArray[1].text.length);t.set(o.DataArray[0].text,0),r.set(o.DataArray[1].text,0);const n=e+t.length;i=new Uint32Array(3*n-9*e);let s=0,a=0,l=0,f=0;const u=e;for(;l<u;){const e=[];let n=0;const o=r[l];for(;n<o-f;)e.push(t[a++]),n++;let u=1;for(;u<o-f-1;)i[s++]=e[0],i[s++]=e[u],i[s++]=e[u+1],u++;l++,f=r[l-1]}}}}}n++}const u=new BufferGeometry;return u.setIndex(new BufferAttribute(i,1)),u.setAttribute("position",new BufferAttribute(a,3)),l.length===a.length&&u.setAttribute("normal",new BufferAttribute(l,3)),u}throw new Error("Unsupported DATASET type")}(n.decode(t)):s[2].includes("ASCII")?function(t){const e=[],r=[],n=[],s=[];let o;const a=/^[^\d.\s-]+/,l=/(\-?\d+\.?[\d\-\+e]*)\s+(\-?\d+\.?[\d\-\+e]*)\s+(\-?\d+\.?[\d\-\+e]*)/g,i=/^(\d+)\s+([\s\d]*)/,f=/^POINTS /,u=/^POLYGONS /,c=/^TRIANGLE_STRIPS /,p=/^POINT_DATA[ ]+(\d+)/,A=/^CELL_DATA[ ]+(\d+)/,d=/^COLOR_SCALARS[ ]+(\w+)[ ]+3/,h=/^NORMALS[ ]+(\w+)[ ]+(\w+)/;let y=!1,b=!1,x=!1,I=!1,w=!1,g=!1,m=!1;const F=t.split("\n");for(const t in F){const D=F[t].trim();if(0===D.indexOf("DATASET")){const t=D.split(" ")[1];if("POLYDATA"!==t)throw new Error("Unsupported DATASET type: "+t)}else if(y)for(;null!==(o=l.exec(D))&&null===a.exec(D);){const t=parseFloat(o[1]),e=parseFloat(o[2]),n=parseFloat(o[3]);r.push(t,e,n)}else if(b){if(null!==(o=i.exec(D))){const t=parseInt(o[1]),r=o[2].split(/\s+/);if(t>=3){const n=parseInt(r[0]);let s=1;for(let o=0;o<t-2;++o){const t=parseInt(r[s]),o=parseInt(r[s+1]);e.push(n,t,o),s++}}}}else if(x){if(null!==(o=i.exec(D))){const t=parseInt(o[1]),r=o[2].split(/\s+/);if(t>=3)for(let n=0;n<t-2;n++)if(n%2==1){const t=parseInt(r[n]),s=parseInt(r[n+2]),o=parseInt(r[n+1]);e.push(t,s,o)}else{const t=parseInt(r[n]),s=parseInt(r[n+1]),o=parseInt(r[n+2]);e.push(t,s,o)}}}else if(I||w)if(g)for(;null!==(o=l.exec(D))&&null===a.exec(D);){const t=parseFloat(o[1]),e=parseFloat(o[2]),r=parseFloat(o[3]);n.push(t,e,r)}else if(m)for(;null!==(o=l.exec(D))&&null===a.exec(D);){const t=parseFloat(o[1]),e=parseFloat(o[2]),r=parseFloat(o[3]);s.push(t,e,r)}null!==u.exec(D)?(b=!0,y=!1,x=!1):null!==f.exec(D)?(b=!1,y=!0,x=!1):null!==c.exec(D)?(b=!1,y=!1,x=!0):null!==p.exec(D)?(I=!0,y=!1,b=!1,x=!1):null!==A.exec(D)?(w=!0,y=!1,b=!1,x=!1):null!==d.exec(D)?(g=!0,m=!1,y=!1,b=!1,x=!1):null!==h.exec(D)&&(m=!0,g=!1,y=!1,b=!1,x=!1)}let D=new BufferGeometry;if(D.setIndex(e),D.setAttribute("position",new Float32BufferAttribute(r,3)),s.length===r.length&&D.setAttribute("normal",new Float32BufferAttribute(s,3)),n.length!==e.length)n.length===r.length&&D.setAttribute("color",new Float32BufferAttribute(n,3));else{D=D.toNonIndexed();const t=D.attributes.position.count/3;if(n.length===3*t){const e=[];for(let r=0;r<t;r++){const t=n[3*r+0],s=n[3*r+1],o=n[3*r+2];e.push(t,s,o),e.push(t,s,o),e.push(t,s,o)}D.setAttribute("color",new Float32BufferAttribute(e,3))}}return D}(n.decode(t)):function(t){const e=new Uint8Array(t),r=new DataView(t);let n,s,o=[],a=[],l=[],i=0;function f(t,e){let r=e,n=t[r];const s=[];for(;10!==n;)s.push(String.fromCharCode(n)),r++,n=t[r];return{start:e,end:r,next:r+1,parsedString:s.join("")}}for(;;){if(n=f(e,i),s=n.parsedString,0===s.indexOf("DATASET")){const t=s.split(" ")[1];if("POLYDATA"!==t)throw new Error("Unsupported DATASET type: "+t)}else if(0===s.indexOf("POINTS")){const t=parseInt(s.split(" ")[1],10),e=4*t*3;o=new Float32Array(3*t);let a=n.next;for(let e=0;e<t;e++)o[3*e]=r.getFloat32(a,!1),o[3*e+1]=r.getFloat32(a+4,!1),o[3*e+2]=r.getFloat32(a+8,!1),a+=12;n.next=n.next+e+1}else if(0===s.indexOf("TRIANGLE_STRIPS")){const t=parseInt(s.split(" ")[1],10),e=parseInt(s.split(" ")[2],10),o=4*e;l=new Uint32Array(3*e-9*t);let a=0,i=n.next;for(let e=0;e<t;e++){const t=r.getInt32(i,!1),e=[];i+=4;for(let n=0;n<t;n++)e.push(r.getInt32(i,!1)),i+=4;for(let r=0;r<t-2;r++)r%2?(l[a++]=e[r],l[a++]=e[r+2],l[a++]=e[r+1]):(l[a++]=e[r],l[a++]=e[r+1],l[a++]=e[r+2])}n.next=n.next+o+1}else if(0===s.indexOf("POLYGONS")){const t=parseInt(s.split(" ")[1],10),e=parseInt(s.split(" ")[2],10),o=4*e;l=new Uint32Array(3*e-9*t);let a=0,i=n.next;for(let e=0;e<t;e++){const t=r.getInt32(i,!1),e=[];i+=4;for(let n=0;n<t;n++)e.push(r.getInt32(i,!1)),i+=4;for(let r=1;r<t-1;r++)l[a++]=e[0],l[a++]=e[r],l[a++]=e[r+1]}n.next=n.next+o+1}else if(0===s.indexOf("POINT_DATA")){const t=parseInt(s.split(" ")[1],10);n=f(e,n.next);const o=4*t*3;a=new Float32Array(3*t);let l=n.next;for(let e=0;e<t;e++)a[3*e]=r.getFloat32(l,!1),a[3*e+1]=r.getFloat32(l+4,!1),a[3*e+2]=r.getFloat32(l+8,!1),l+=12;n.next=n.next+o}if(i=n.next,i>=e.byteLength)break}const u=new BufferGeometry;return u.setIndex(new BufferAttribute(l,1)),u.setAttribute("position",new BufferAttribute(o,3)),a.length===o.length&&u.setAttribute("normal",new BufferAttribute(a,3)),u}(t)}}export{VTKLoader};