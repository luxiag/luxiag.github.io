import{FileLoader,Loader,Matrix4,Vector3}from"three";import*as fflate from"../libs/fflate.module.js";import{Volume}from"../misc/Volume.js";class NRRDLoader extends Loader{constructor(e){super(e)}load(e,t,r,n){const s=this,i=new FileLoader(s.manager);i.setPath(s.path),i.setResponseType("arraybuffer"),i.setRequestHeader(s.requestHeader),i.setWithCredentials(s.withCredentials),i.load(e,(function(r){try{t(s.parse(r))}catch(t){n?n(t):console.error(t),s.manager.itemError(e)}}),r,n)}setSegmentation(e){this.segmentation=e}parse(e){let t=e,r=0;const n=new Int8Array(new Int16Array([1]).buffer)[0]>0,s={},i=function(e,s){null==s&&(s=1);let i=1,a=Uint8Array;let o=new a(t.slice(r,r+=s*i));return 1!=n&&(o=function(e,t){const r=new Uint8Array(e.buffer,e.byteOffset,e.byteLength);for(let n=0;n<e.byteLength;n+=t)for(let e=n+t-1,s=n;e>s;e--,s++){const t=r[s];r[s]=r[e],r[e]=t}return e}(o,i)),1==s?o[0]:o}(0,e.byteLength),a=i.length;let o,c=null,l=0;for(o=1;o<a;o++)if(10==i[o-1]&&10==i[o]){c=this.parseChars(i,0,o-2),l=o+1;break}if(function(e){let t,r,n,i,a,o,c,l;const h=e.split(/\r?\n/);for(c=0,l=h.length;c<l;c++)a=h[c],a.match(/NRRD\d+/)?s.isNrrd=!0:!a.match(/^#/)&&(o=a.match(/(.*):(.*)/))&&(r=o[1].trim(),t=o[2].trim(),n=_fieldFunctions[r],n?n.call(s,t):s[r]=t);if(!s.isNrrd)throw new Error("Not an NRRD file");if("bz2"===s.encoding||"bzip2"===s.encoding)throw new Error("Bzip is not supported");if(!s.vectors&&(s.vectors=[],s.vectors.push([1,0,0]),s.vectors.push([0,1,0]),s.vectors.push([0,0,1]),s.spacings))for(i=0;i<=2;i++)if(!isNaN(s.spacings[i]))for(let e=0;e<=2;e++)s.vectors[i][e]*=s.spacings[i]}(c),t=i.subarray(l),"gz"===s.encoding.substring(0,2))t=fflate.gunzipSync(new Uint8Array(t));else if("ascii"===s.encoding||"text"===s.encoding||"txt"===s.encoding||"hex"===s.encoding)t=function(e,t,r){let n,i="";t=t||0,r=r||e.length;const a=s.sizes.reduce((function(e,t){return e*t}),1);let o=10;"hex"===s.encoding&&(o=16);const c=new s.__array(a);let l=0,h=parseInt;s.__array!==Float32Array&&s.__array!==Float64Array||(h=parseFloat);for(let s=t;s<r;s++)n=e[s],(n<9||n>13)&&32!==n?i+=String.fromCharCode(n):(""!==i&&(c[l]=h(i,o),l++),i="");return""!==i&&(c[l]=h(i,o),l++),c}(t);else if("raw"===s.encoding){const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t[r];t=e}t=t.buffer;const h=new Volume;h.header=s,h.segmentation=this.segmentation,h.data=new s.__array(t);const u=h.computeMinMax(),f=u[0],d=u[1];if(h.windowLow=f,h.windowHigh=d,h.dimensions=[s.sizes[0],s.sizes[1],s.sizes[2]],h.xLength=h.dimensions[0],h.yLength=h.dimensions[1],h.zLength=h.dimensions[2],s.vectors){const e=s.vectors.findIndex((e=>0!==e[0])),t=s.vectors.findIndex((e=>0!==e[1])),r=s.vectors.findIndex((e=>0!==e[2])),n=[];e!==t&&e!==r&&t!==r?(n[e]="x",n[t]="y",n[r]="z"):(n[0]="x",n[1]="y",n[2]="z"),h.axisOrder=n}else h.axisOrder=["x","y","z"];const p=(new Vector3).fromArray(s.vectors[0]).length(),g=(new Vector3).fromArray(s.vectors[1]).length(),y=(new Vector3).fromArray(s.vectors[2]).length();h.spacing=[p,g,y],h.matrix=new Matrix4;const m=new Matrix4;if("left-posterior-superior"===s.space?m.set(-1,0,0,0,0,-1,0,0,0,0,1,0,0,0,0,1):"left-anterior-superior"===s.space&&m.set(1,0,0,0,0,1,0,0,0,0,-1,0,0,0,0,1),s.vectors){const e=s.vectors,t=(new Matrix4).set(e[0][0],e[1][0],e[2][0],0,e[0][1],e[1][1],e[2][1],0,e[0][2],e[1][2],e[2][2],0,0,0,0,1),r=(new Matrix4).multiplyMatrices(t,m);h.matrix=r}else h.matrix.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return h.inverseMatrix=new Matrix4,h.inverseMatrix.copy(h.matrix).invert(),h.RASDimensions=[Math.floor(h.xLength*p),Math.floor(h.yLength*g),Math.floor(h.zLength*y)],h.lowerThreshold===-1/0&&(h.lowerThreshold=f),h.upperThreshold===1/0&&(h.upperThreshold=d),h}parseChars(e,t,r){void 0===t&&(t=0),void 0===r&&(r=e.length);let n="",s=0;for(s=t;s<r;++s)n+=String.fromCharCode(e[s]);return n}}const _fieldFunctions={type:function(e){switch(e){case"uchar":case"unsigned char":case"uint8":case"uint8_t":this.__array=Uint8Array;break;case"signed char":case"int8":case"int8_t":this.__array=Int8Array;break;case"short":case"short int":case"signed short":case"signed short int":case"int16":case"int16_t":this.__array=Int16Array;break;case"ushort":case"unsigned short":case"unsigned short int":case"uint16":case"uint16_t":this.__array=Uint16Array;break;case"int":case"signed int":case"int32":case"int32_t":this.__array=Int32Array;break;case"uint":case"unsigned int":case"uint32":case"uint32_t":this.__array=Uint32Array;break;case"float":this.__array=Float32Array;break;case"double":this.__array=Float64Array;break;default:throw new Error("Unsupported NRRD data type: "+e)}return this.type=e},endian:function(e){return this.endian=e},encoding:function(e){return this.encoding=e},dimension:function(e){return this.dim=parseInt(e,10)},sizes:function(e){let t;return this.sizes=function(){const r=e.split(/\s+/),n=[];for(let e=0,s=r.length;e<s;e++)t=r[e],n.push(parseInt(t,10));return n}()},space:function(e){return this.space=e},"space origin":function(e){return this.space_origin=e.split("(")[1].split(")")[0].split(",")},"space directions":function(e){let t,r;const n=e.match(/\(.*?\)/g);return this.vectors=function(){const e=[];for(let s=0,i=n.length;s<i;s++)r=n[s],e.push(function(){const e=r.slice(1,-1).split(/,/),n=[];for(let r=0,s=e.length;r<s;r++)t=e[r],n.push(parseFloat(t));return n}());return e}()},spacings:function(e){let t;const r=e.split(/\s+/);return this.spacings=function(){const e=[];for(let n=0,s=r.length;n<s;n++)t=r[n],e.push(parseFloat(t));return e}()}};export{NRRDLoader};