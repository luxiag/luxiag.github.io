import{BufferGeometry,FileLoader,Float32BufferAttribute,Int32BufferAttribute,Loader,Points,PointsMaterial}from"three";class PCDLoader extends Loader{constructor(t){super(t),this.littleEndian=!0}load(t,e,i,n){const s=this,r=new FileLoader(s.manager);r.setPath(s.path),r.setResponseType("arraybuffer"),r.setRequestHeader(s.requestHeader),r.setWithCredentials(s.withCredentials),r.load(t,(function(i){try{e(s.parse(i))}catch(e){n?n(e):console.error(e),s.manager.itemError(t)}}),i,n)}parse(t){const e=(new TextDecoder).decode(t),i=function(t){const e={},i=t.search(/[\r\n]DATA\s(\S*)\s/i),n=/[\r\n]DATA\s(\S*)\s/i.exec(t.slice(i-1));if(e.data=n[1],e.headerLen=n[0].length+i,e.str=t.slice(0,e.headerLen),e.str=e.str.replace(/#.*/gi,""),e.version=/VERSION (.*)/i.exec(e.str),e.fields=/FIELDS (.*)/i.exec(e.str),e.size=/SIZE (.*)/i.exec(e.str),e.type=/TYPE (.*)/i.exec(e.str),e.count=/COUNT (.*)/i.exec(e.str),e.width=/WIDTH (.*)/i.exec(e.str),e.height=/HEIGHT (.*)/i.exec(e.str),e.viewpoint=/VIEWPOINT (.*)/i.exec(e.str),e.points=/POINTS (.*)/i.exec(e.str),null!==e.version&&(e.version=parseFloat(e.version[1])),e.fields=null!==e.fields?e.fields[1].split(" "):[],null!==e.type&&(e.type=e.type[1].split(" ")),null!==e.width&&(e.width=parseInt(e.width[1])),null!==e.height&&(e.height=parseInt(e.height[1])),null!==e.viewpoint&&(e.viewpoint=e.viewpoint[1]),null!==e.points&&(e.points=parseInt(e.points[1],10)),null===e.points&&(e.points=e.width*e.height),null!==e.size&&(e.size=e.size[1].split(" ").map((function(t){return parseInt(t,10)}))),null!==e.count)e.count=e.count[1].split(" ").map((function(t){return parseInt(t,10)}));else{e.count=[];for(let t=0,i=e.fields.length;t<i;t++)e.count.push(1)}e.offset={};let s=0;for(let t=0,i=e.fields.length;t<i;t++)"ascii"===e.data?e.offset[e.fields[t]]=t:(e.offset[e.fields[t]]=s,s+=e.size[t]*e.count[t]);return e.rowSize=s,e}(e),n=[],s=[],r=[],o=[],l=[];if("ascii"===i.data){const t=i.offset,a=e.slice(i.headerLen).split("\n");for(let e=0,d=a.length;e<d;e++){if(""===a[e])continue;const d=a[e].split(" ");if(void 0!==t.x&&(n.push(parseFloat(d[t.x])),n.push(parseFloat(d[t.y])),n.push(parseFloat(d[t.z]))),void 0!==t.rgb){const e=i.fields.findIndex((t=>"rgb"===t)),n=i.type[e],s=parseFloat(d[t.rgb]);let o=s;if("F"===n){const t=new Float32Array(1);t[0]=s,o=new Int32Array(t.buffer)[0]}const l=o>>16&255,a=o>>8&255,h=o>>0&255;r.push(l/255,a/255,h/255)}void 0!==t.normal_x&&(s.push(parseFloat(d[t.normal_x])),s.push(parseFloat(d[t.normal_y])),s.push(parseFloat(d[t.normal_z]))),void 0!==t.intensity&&o.push(parseFloat(d[t.intensity])),void 0!==t.label&&l.push(parseInt(d[t.label]))}}if("binary_compressed"===i.data){const e=new Uint32Array(t.slice(i.headerLen,i.headerLen+8)),a=e[0],d=e[1],h=function(t,e){const i=t.length,n=new Uint8Array(e);let s,r,o,l=0,a=0;do{if(s=t[l++],s<32){if(s++,a+s>e)throw new Error("Output buffer is not large enough");if(l+s>i)throw new Error("Invalid compressed data");do{n[a++]=t[l++]}while(--s)}else{if(r=s>>5,o=a-((31&s)<<8)-1,l>=i)throw new Error("Invalid compressed data");if(7===r&&(r+=t[l++],l>=i))throw new Error("Invalid compressed data");if(o-=t[l++],a+r+2>e)throw new Error("Output buffer is not large enough");if(o<0)throw new Error("Invalid compressed data");if(o>=a)throw new Error("Invalid compressed data");do{n[a++]=n[o++]}while(2+--r)}}while(l<i);return n}(new Uint8Array(t,i.headerLen+8,a),d),p=new DataView(h.buffer),f=i.offset;for(let t=0;t<i.points;t++){if(void 0!==f.x){const e=i.fields.indexOf("x"),s=i.fields.indexOf("y"),r=i.fields.indexOf("z");n.push(p.getFloat32(i.points*f.x+i.size[e]*t,this.littleEndian)),n.push(p.getFloat32(i.points*f.y+i.size[s]*t,this.littleEndian)),n.push(p.getFloat32(i.points*f.z+i.size[r]*t,this.littleEndian))}if(void 0!==f.rgb){const e=i.fields.indexOf("rgb");r.push(p.getUint8(i.points*f.rgb+i.size[e]*t+2)/255),r.push(p.getUint8(i.points*f.rgb+i.size[e]*t+1)/255),r.push(p.getUint8(i.points*f.rgb+i.size[e]*t+0)/255)}if(void 0!==f.normal_x){const e=i.fields.indexOf("normal_x"),n=i.fields.indexOf("normal_y"),r=i.fields.indexOf("normal_z");s.push(p.getFloat32(i.points*f.normal_x+i.size[e]*t,this.littleEndian)),s.push(p.getFloat32(i.points*f.normal_y+i.size[n]*t,this.littleEndian)),s.push(p.getFloat32(i.points*f.normal_z+i.size[r]*t,this.littleEndian))}if(void 0!==f.intensity){const e=i.fields.indexOf("intensity");o.push(p.getFloat32(i.points*f.intensity+i.size[e]*t,this.littleEndian))}if(void 0!==f.label){const e=i.fields.indexOf("label");l.push(p.getInt32(i.points*f.label+i.size[e]*t,this.littleEndian))}}}if("binary"===i.data){const e=new DataView(t,i.headerLen),a=i.offset;for(let t=0,d=0;t<i.points;t++,d+=i.rowSize)void 0!==a.x&&(n.push(e.getFloat32(d+a.x,this.littleEndian)),n.push(e.getFloat32(d+a.y,this.littleEndian)),n.push(e.getFloat32(d+a.z,this.littleEndian))),void 0!==a.rgb&&(r.push(e.getUint8(d+a.rgb+2)/255),r.push(e.getUint8(d+a.rgb+1)/255),r.push(e.getUint8(d+a.rgb+0)/255)),void 0!==a.normal_x&&(s.push(e.getFloat32(d+a.normal_x,this.littleEndian)),s.push(e.getFloat32(d+a.normal_y,this.littleEndian)),s.push(e.getFloat32(d+a.normal_z,this.littleEndian))),void 0!==a.intensity&&o.push(e.getFloat32(d+a.intensity,this.littleEndian)),void 0!==a.label&&l.push(e.getInt32(d+a.label,this.littleEndian))}const a=new BufferGeometry;n.length>0&&a.setAttribute("position",new Float32BufferAttribute(n,3)),s.length>0&&a.setAttribute("normal",new Float32BufferAttribute(s,3)),r.length>0&&a.setAttribute("color",new Float32BufferAttribute(r,3)),o.length>0&&a.setAttribute("intensity",new Float32BufferAttribute(o,1)),l.length>0&&a.setAttribute("label",new Int32BufferAttribute(l,1)),a.computeBoundingSphere();const d=new PointsMaterial({size:.005});return r.length>0&&(d.vertexColors=!0),new Points(a,d)}}export{PCDLoader};